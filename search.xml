<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用进程池提高Node.js并行计算能力</title>
      <link href="/2019/03/22/node-process-pool/"/>
      <url>/2019/03/22/node-process-pool/</url>
      
        <content type="html"><![CDATA[<h3 id="Node-Process-Pool"><a href="#Node-Process-Pool" class="headerlink" title="Node Process Pool"></a>Node Process Pool</h3><h4 id="背景-Background"><a href="#背景-Background" class="headerlink" title="背景 Background"></a>背景 Background</h4><p>Node是单线程模型，当需要执行多个独立且耗时任务的时候，只能通过child_process来分发任务，提高处理速度；不像Java这种多线程语言，可以通过线程来解决并行问题，Node只能创建进程来进行处理；但是进程相对于线程来说，开销太大。一旦进程数较多时，CPU和内存消耗严重（影响我干其他的事情），所以做了一个简易版的进程池，用来解决并行任务的处理。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主控进程+工作进程群</p><p>ProcessPool是我们管理进程的地方，我们通过传递配置参数（任务脚本、脚本需要的参数、最大并行进程数）生成一个ProcessPool实例，然后通过这个实例来管控进程池。</p><p>ProcessItem是我们进程池里的进程对象，ProcessItem对象除了process的信息，我们还增加了唯一标识和状态（忙碌、任务失败、任务完成、进程不可用）。</p><p>一批任务开始时，我们会一次性fork到最大并行进程数，然后开始监控是否有工作进程完成任务，如果有工作进程完成了任务，那我们就可以复用这个工作进程，让其执行新任务；如果任务执行失败，我们会将任务归还给进程池，等待下一次分发。</p><p>由于主控进程即要负责IPC又要不断监听批任务完成的情况，目前我采用的方式是setInterval切割，让IPC和监控能交替进行（ps：应该有更好的方法</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="ProcessPool-js"><a href="#ProcessPool-js" class="headerlink" title="ProcessPool.js"></a>ProcessPool.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProcessItem = <span class="built_in">require</span>(<span class="string">'./ProcessItem'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程池类 Process Pool</span></span><br><span class="line"><span class="comment"> * @param maxParallelProcess，最大并行工作进程数</span></span><br><span class="line"><span class="comment"> * @param timeToClose，任务最长耗时时间</span></span><br><span class="line"><span class="comment"> * @param task，任务脚本</span></span><br><span class="line"><span class="comment"> * @param taskParams，所有任务脚本需要的参数</span></span><br><span class="line"><span class="comment"> * Todo: 读写统一文件时出现任务丢失，待修复bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProcessPool</span>(<span class="params">&#123; maxParallelProcess = <span class="number">50</span>, timeToClose = <span class="number">60</span> * <span class="number">1000</span>, task = <span class="string">''</span>, taskParams = [] &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.processList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map存储进程对象</span></span><br><span class="line">  <span class="keyword">this</span>.currentProcessNum = <span class="number">0</span> <span class="comment">// 当前活动进程数</span></span><br><span class="line">  <span class="comment">// this.timeToClose = timeToClose</span></span><br><span class="line">  <span class="keyword">this</span>.task = task <span class="comment">// 任务脚本路径</span></span><br><span class="line">  <span class="keyword">this</span>.taskParamsTodo = taskParams <span class="comment">// 待完成的任务参数数组，包含了n个小任务所需参数，所以是一个二维数组</span></span><br><span class="line">  <span class="keyword">this</span>.taskParamsDone = [] <span class="comment">// 已完成的任务参数数组</span></span><br><span class="line">  <span class="keyword">this</span>.maxParallelProcess = maxParallelProcess <span class="comment">// 最大进程并行数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 复用空闲进程</span></span><br><span class="line"><span class="comment">   * @param key，可复用进程的pid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.reuseProcess = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> workProcess = <span class="keyword">this</span>.processList.get(key)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.taskParamsTodo.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> taskParam = <span class="keyword">this</span>.taskParamsTodo.shift()</span><br><span class="line">      workProcess.state = <span class="number">1</span> <span class="comment">// 设置为忙碌</span></span><br><span class="line">      workProcess.process.send(taskParam)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 进程池启动，处理任务</span></span><br><span class="line"><span class="comment">   * Todo：一方面要实时监控任务状态，另一方面要处理工作进程传递过来的message，由于单线程模型，二者只有一个能运行，目前采用定时器切换工作上下文，应该有更好的方法。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`开始时间：<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>)</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> flag = <span class="keyword">this</span>.hasWorkProcessRunning() <span class="comment">// 判断是否有工作进程正在执行或是否是第一次处理任务</span></span><br><span class="line">      <span class="keyword">const</span> taskTodoNum = <span class="keyword">this</span>.taskParamsTodo.length</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flag === <span class="number">1</span> &amp;&amp; taskTodoNum) &#123;</span><br><span class="line">        <span class="comment">// 初始阶段，fork min&#123;任务数，最大进程数&#125; 的进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.currentProcessNum &lt;= <span class="keyword">this</span>.maxParallelProcess &amp;&amp; <span class="keyword">this</span>.currentProcessNum &lt;= taskTodoNum) &#123;</span><br><span class="line">          <span class="keyword">this</span>.addProcess()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &gt; <span class="number">0</span> &amp;&amp; !taskTodoNum) &#123;</span><br><span class="line">        <span class="comment">// 如果有工作进程正在执行且没有新的任务要执行，那么等待工作进程结束任务</span></span><br><span class="line">        <span class="comment">// console.log('没有新任务，但有正在执行的任务，耐心等待')</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &gt; <span class="number">0</span> &amp;&amp; taskTodoNum) &#123;</span><br><span class="line">        <span class="comment">// 如果有工作进程正在执行且有新的任务要执行，如果有空闲进程，那么重用空闲进程执行新任务</span></span><br><span class="line">        <span class="comment">// console.log('有新任务，且有正在执行的任务，重用空闲进程执行新任务')</span></span><br><span class="line">        <span class="keyword">const</span> processList = <span class="keyword">this</span>.processList.values()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> processList) &#123;</span><br><span class="line">          <span class="keyword">if</span> (p.state !== <span class="number">1</span> || p.state !== <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reuseProcess(p.id)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &lt; <span class="number">0</span> &amp;&amp; taskTodoNum) &#123;</span><br><span class="line">        <span class="comment">// 如果没有工作进程正在执行且有新的任务要执行，如果有空闲进程，那么重用空闲进程执行新任务，如果没有则新启动进程进行执行任务</span></span><br><span class="line">        <span class="comment">// console.log('有新任务，但没有正在执行的任务，重用空闲进程执行新任务')</span></span><br><span class="line">        <span class="keyword">const</span> processList = <span class="keyword">this</span>.processList.values()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> processList) &#123;</span><br><span class="line">          <span class="keyword">if</span> (p.state !== <span class="number">1</span> || p.state !== <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reuseProcess(p.id)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &lt; <span class="number">0</span> &amp;&amp; !taskTodoNum) &#123;</span><br><span class="line">        <span class="comment">// 如果没有工作进程正在执行且没有新的任务要执行，关闭进程池，任务完成</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'所有任务已完成'</span>)</span><br><span class="line">        <span class="keyword">this</span>.closeProcessPool()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监测当前是否有正在处理任务的进程</span></span><br><span class="line"><span class="comment">   * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.hasWorkProcessRunning = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.processList.size) <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 进程池刚启动，尚无进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> <span class="keyword">this</span>.processList.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.state === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 有忙碌的进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.listenProcessFinish = <span class="function">(<span class="params">workProcess, params</span>) =&gt;</span> &#123;</span><br><span class="line">    workProcess.process.on(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (message === <span class="string">'finish'</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(`收到来自工作进程$&#123;workProcess.id&#125;的完成消息`)</span></span><br><span class="line">        <span class="keyword">this</span>.taskParamsDone.push(params)</span><br><span class="line">        workProcess.finishTask()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message === <span class="string">'failed'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskParamsTodo.unshift(params)</span><br><span class="line">        <span class="comment">// console.log(`收到来自工作进程$&#123;workProcess.id&#125;的失败消息`)</span></span><br><span class="line">        workProcess.unFinishTask()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.addProcess = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentProcessNum &lt;= <span class="keyword">this</span>.maxParallelProcess) &#123;</span><br><span class="line">      <span class="keyword">let</span> workParam = <span class="keyword">this</span>.taskParamsTodo.shift()</span><br><span class="line">      <span class="keyword">const</span> newProcess = <span class="keyword">new</span> ProcessItem(&#123;<span class="attr">task</span>: <span class="keyword">this</span>.task, workParam&#125;)</span><br><span class="line">      <span class="keyword">this</span>.processList.set(newProcess.id, newProcess)</span><br><span class="line">      <span class="keyword">this</span>.currentProcessNum++</span><br><span class="line">      <span class="keyword">this</span>.listenProcessFinish(newProcess, workParam)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'已经达到系统最大进程并行数'</span> + <span class="keyword">this</span>.currentProcessNum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从进程池中移除[进程id]</span></span><br><span class="line"><span class="comment">   * @param id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.removeProcess = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processList.has(id)) &#123;</span><br><span class="line">      <span class="keyword">const</span> processToTerminate = <span class="keyword">this</span>.processList.get(id)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'系统正关闭进程'</span> + processToTerminate.id)</span><br><span class="line">      processToTerminate.terminate()</span><br><span class="line">      <span class="keyword">this</span>.currentProcessNum--</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不存在进程'</span> + id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭所有进程并清空进程池</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.closeProcessPool = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭所有工作进程'</span>)</span><br><span class="line">    <span class="keyword">const</span> processItems = <span class="keyword">this</span>.processList.values()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> processItem <span class="keyword">of</span> processItems) &#123;</span><br><span class="line">      <span class="comment">// console.log('关闭工作进程' + processItem.id)</span></span><br><span class="line">      processItem.terminate()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空进程池</span></span><br><span class="line">    <span class="keyword">this</span>.processList = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`结束时间：<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭主控进程'</span>)</span><br><span class="line">    process.kill(process.pid)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ProcessPool</span><br></pre></td></tr></table></figure><h5 id="ProcessItem-js"><a href="#ProcessItem-js" class="headerlink" title="ProcessItem.js"></a>ProcessItem.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作进程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ChildProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProcessItem</span>(<span class="params">&#123; task = <span class="string">''</span>, workParam = [] &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * state 状态码</span></span><br><span class="line"><span class="comment">   * 1: 忙碌</span></span><br><span class="line"><span class="comment">   * 2: 完成任务</span></span><br><span class="line"><span class="comment">   * 3: 未完成任务</span></span><br><span class="line"><span class="comment">   * 4： 不可用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.process = <span class="keyword">this</span>.createProcess(task, workParam)</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="number">1</span></span><br><span class="line">  <span class="keyword">this</span>.id = <span class="keyword">this</span>.process.pid</span><br><span class="line">  <span class="keyword">this</span>.finishTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.terminate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.process.kill()</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.unFinishTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ProcessItem.prototype.createProcess = <span class="function">(<span class="params">task, workParam</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> childProcess = ChildProcess.fork(task, workParam)</span><br><span class="line">  <span class="keyword">if</span> (childProcess) &#123;</span><br><span class="line">    <span class="keyword">return</span> childProcess</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建进程失败'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'create process failed'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ProcessItem</span><br></pre></td></tr></table></figure><h5 id="Task-js"><a href="#Task-js" class="headerlink" title="Task.js"></a>Task.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当进程被子进程创建后，立刻执行工作任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">firstTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> workParam = process.argv.slice(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">await</span> task(workParam)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成任务，提示进程池已完成，工作进程空闲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">finishTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> process.send(<span class="string">'finish'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务失败，提示进程池未完成，归还任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unFinishTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> process.send(<span class="string">'failed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听进程池后续指派的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="keyword">async</span> workParam =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> task(workParam)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> finishTask()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> unFinishTask()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程被创建时立即执行进程池指派的任务</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;void&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> firstTask()</span><br><span class="line">    <span class="keyword">await</span> finishTask()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> unFinishTask()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 工作进程负责的任务</span></span><br><span class="line"><span class="comment"> * @param workParam // 执行任务所需的参数数组</span></span><br><span class="line"><span class="comment"> * 动态添加任务脚本到此task.js尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-process-pool</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程池使用示例</span></span><br><span class="line"><span class="keyword">const</span> ProcessPool = <span class="built_in">require</span>(<span class="string">'node-process-pool'</span>)</span><br><span class="line"><span class="keyword">const</span> taskParams = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">  taskParams[i] = [i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建进程池实例</span></span><br><span class="line"><span class="keyword">const</span> processPool = <span class="keyword">new</span> ProcessPool(&#123;</span><br><span class="line">  maxParallelProcess: <span class="number">50</span>, <span class="comment">// 支持最大进程并行数</span></span><br><span class="line">  timeToClose: <span class="number">60</span> * <span class="number">1000</span>, <span class="comment">// 单个任务被执行最大时长</span></span><br><span class="line">  script: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params">taskParams</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(taskParams)</span><br><span class="line">  &#125;,</span><br><span class="line">  taskParams <span class="comment">// 需要执行的任务参数列表，二维数组</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 利用进程池进行处理大规模任务</span></span><br><span class="line">processPool.run()</span><br><span class="line"><span class="comment">// 测试任务1：写时间戳到文本中</span></span><br><span class="line"><span class="comment">// 进程池：5000个任务，耗时2.7s，每个任务耗时0.54ms</span></span><br><span class="line"><span class="comment">// 单线程：5000个任务，耗时0.456s，每个任务耗时0.0934ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试任务2：写时间戳到文本中，但每个任务需要至少耗时20ms（while空循环）</span></span><br><span class="line"><span class="comment">// 进程池：5000个任务，耗时15.089s，每个任务耗时3.02ms</span></span><br><span class="line"><span class="comment">// 单线程：5000个任务，耗时100.260s，每个任务耗时20.052ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然，当处理独立且耗时任务时，使用进程池更加合适。例如爬取信息，直接会将对方服务器503，2333333～</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 单线程 </tag>
            
            <tag> 进程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何评价前端性能好坏？</title>
      <link href="/2019/02/27/perfomance/"/>
      <url>/2019/02/27/perfomance/</url>
      
        <content type="html"><![CDATA[<h3 id="如何评价前端性能好坏？"><a href="#如何评价前端性能好坏？" class="headerlink" title="如何评价前端性能好坏？"></a>如何评价前端性能好坏？</h3><p><strong>加载时间</strong>是我们用于评价前端性能好坏的一个参考数据，但是加载时间与用户使用的手机类型以及当前网络状况有关，除此之外，即使页面加载完成用户也可能无法操作，所以仅仅用一个<strong>加载时间</strong>是不能描述前端性能的好坏，我们需要一套完整的性能评价体系。</p><a id="more"></a><p>此前，我们有两个主要的事件来测量性能：</p><ol><li>DomContentLoaded：页面加载时触发，但脚本刚刚开始执行</li><li>load：在页面完全加载后触发，此时用户已经可以使用页面和应用</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*hFyHeo1-iI62aMQT8P8ORw.png" alt=""></p><p>但是，如果在网络环境较差或者脚本执行时间太长的时候，我们从DCL到load会经历一段很长很长的时间，并且load事件触发太晚，就无法分析出页面的性能瓶颈，所以我们需要建立一个从页面开始加载到加载完成的评价体系，记录用户整个感知过程。</p><h4 id="渐进式网页指标"><a href="#渐进式网页指标" class="headerlink" title="渐进式网页指标"></a>渐进式网页指标</h4><p><img src="https://cdn-images-1.medium.com/max/2000/1*-zjNpHphoKaaZJgG7omu2w.png" alt="img"></p><p><img src="https://github.com/w3c/paint-timing/raw/master/filmstrip.png" alt=""></p><p><strong>首次绘制(FP)</strong>： 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点</p><p><strong>首次内容绘制(FCP)</strong>：标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 <code>&lt;canvas&gt;</code> 元素。</p><p><strong>首次有效绘制（FMP）/主角元素计时</strong>：标记的是页面主要内容绘制的时间点，例如视频应用的视频组件、天气应用的天气信息、新闻应用中的新闻条目。</p><p><strong>可交互时间（TTI）</strong>：页面渲染完成，能可靠的响应用户的操作的时间点。（这个时间不仅取决于之前的加载时间，还取决于当前是否有长任务阻塞主线程）</p><h4 id="浏览器页面加载流程"><a href="#浏览器页面加载流程" class="headerlink" title="浏览器页面加载流程"></a>浏览器页面加载流程</h4><p>先谈谈浏览器的页面大致的加载流程：</p><ol><li>浏览器输入url，浏览器发送请求到服务器，服务器发送HTML给浏览器。</li><li>浏览器下载HTML然后从上往下解析</li><li>如果在解析HTML过程中遇到CSS、JS外链，会执行下列操作<ol><li>Send Request：向这个外链对应的服务器发送请求</li><li>Receive Response：接受响应，表示可以开始从网络接受数据</li><li>Receive Data：开始接受数据</li><li>Finish Loding：表示完成数据的下载</li><li>Parse Stylesheet/Evaluate：解析CSS或执行JS</li></ol></li><li>所有的CSS下载完成后进行parse，构建CSSOM</li><li>DOM和CSSOM合成一个Render tree</li><li>根据Render tree的内容计算处各个节点在网页中的大小和位置（Layout）</li><li>根据Layout绘制内容在浏览器上（Paint）</li></ol><h4 id="如何统计上述的指标"><a href="#如何统计上述的指标" class="headerlink" title="如何统计上述的指标"></a>如何统计上述的指标</h4><p>通过performance接口，我们可以获得当前页面与性能相关的信息；然后通过navogator.sendBeacon或Google Analytics向服务器发送与性能相关的信息。</p><p>那么，具体的性能指标如何统计呢？👇👇👇</p><h5 id="首次绘制-First-Paint，FP"><a href="#首次绘制-First-Paint，FP" class="headerlink" title="首次绘制(First Paint，FP)"></a>首次绘制(First Paint，FP)</h5><p>这个指标表示页面绘制的时间点，也就是<strong>用户第一次看到“白屏”的时间</strong>，标志“It is happening?”</p><p><strong>首次绘制包括了任何用户自定义的背景绘制，它是首先将像素绘制到屏幕的时刻。</strong></p><p>什么时候触发FP事件呢？<strong>FP事件是在图层进行绘制的时候触发</strong>，而不是文本、图片、SVG等元素出现的时候（这个时候触发的是FCP事件）</p><p>怎么统计这个FP时间呢？</p><ol><li><p>window.perfomance.getEntriesByType(‘paint’)，这会返回FP、FCP发生的时间点。具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p></li><li><p>通过使用 Google Analytics，可跟踪首次绘制时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Add the async Google Analytics snippet first. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.ga=<span class="built_in">window</span>.ga||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(ga.q=ga.q||[]).push(<span class="built_in">arguments</span>)&#125;;ga.l=+<span class="keyword">new</span> <span class="built_in">Date</span>;</span></span><br><span class="line"><span class="javascript">  ga(<span class="string">'create'</span>, <span class="string">'UA-XXXXX-Y'</span>, <span class="string">'auto'</span>);</span></span><br><span class="line"><span class="javascript">  ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">'https://www.google-analytics.com/analytics.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Register the PerformanceObserver to track paint timing. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// `name` will be either 'first-paint' or 'first-contentful-paint'.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> metricName = entry.name;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> time = <span class="built_in">Math</span>.round(entry.startTime + entry.duration);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span></span><br><span class="line"><span class="javascript">        eventCategory:<span class="string">'Performance Metrics'</span>,</span></span><br><span class="line"><span class="undefined">        eventAction: metricName,</span></span><br><span class="line"><span class="undefined">        eventValue: time,</span></span><br><span class="line"><span class="javascript">        nonInteraction: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  observer.observe(&#123;<span class="attr">entryTypes</span>: [<span class="string">'paint'</span>]&#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Include any stylesheets after creating the PerformanceObserver. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="首次内容绘制-First-Content-Paint，FCP"><a href="#首次内容绘制-First-Content-Paint，FCP" class="headerlink" title="首次内容绘制(First Content Paint，FCP)"></a>首次内容绘制(First Content Paint，FCP)</h5><p>当用户首次看见一些元素（文本、图片、SVG等），非”白屏“的时刻就是FCP，这个标志“it is running?”</p><p>统计的方法与上述FP的统计方法类似，Google的Analysis监听的paint实际有两种类型，‘<strong>first paint</strong>’和‘<strong>first content pain</strong>’。</p><p>FCP在文本、图片、SVG等绘制的时候就触发了，所以跟FP可以相差几毫秒～几秒的时间。</p><h5 id="首次有效绘制-First-Meaningful-Paint，FMP"><a href="#首次有效绘制-First-Meaningful-Paint，FMP" class="headerlink" title="首次有效绘制(First Meaningful Paint，FMP)"></a>首次有效绘制(First Meaningful Paint，FMP)</h5><p>FMP就是页面主要内容呈现的时刻，目前没有标准化的FMP定义，所以很以通用的方式确定“有效”对于所有页面意味着什么。</p><p>所以，我们怎么统计FMP呢？它的统计在页面发生了重大的布局变化之后；LayoutAnalyzer会统计所有的布局变化，当布局变化最大时，这个时刻就是FMP。</p><p>如果主要内容渲染太慢，我们可以在样式、字体、脚本、图片上去思考，因为这些元素有很大可能阻塞了FMP。</p><h5 id="可交互时间（Time-To-Interactive，TTI）"><a href="#可交互时间（Time-To-Interactive，TTI）" class="headerlink" title="可交互时间（Time To Interactive，TTI）"></a>可交互时间（Time To Interactive，TTI）</h5><p>与 FMP 相同，很难规范化适用于所有网页的 TTI 指标定义，但我们也可以使用Google Analytics来跟踪应用TTI。</p><p>TTI发生在什么时候？<strong>FMP &amp;&amp; DOMContentLoader事件触发 &amp;&amp; 页面视觉加载85%</strong></p><p>TTI又可以分为两个指标，TTFI（首次交互时间）、TTCI（首次持续交互时间）</p><p><strong>TTFI</strong>:</p><p><img src="https://cdn-images-1.medium.com/max/800/0*xWGGBiXh0pLiPeuk." alt=""></p><p>在FMP发生后应该有3s的quiet window，这个时间足够说明页面对用户是可交互的，但是可能会有长任务在这个quiet window期间或之后开始执行，它们可以被忽略。</p><p><strong>TTCI</strong>:</p><p><img src="https://cdn-images-1.medium.com/max/800/0*6qzJAADPmBaNSwFw." alt=""></p><p>从追终线的尾部开始看，页面加载后有5s的quiet并且没有长任务需要执行，得到了一段quiet window。quiet window之后到第一个长任务之前的时间就是TTCI。</p><h5 id="影响上面某些指标的因素"><a href="#影响上面某些指标的因素" class="headerlink" title="影响上面某些指标的因素"></a>影响上面某些指标的因素</h5><p>FP/FCP：“白屏”，从文档的 <code>&lt;head&gt;</code> 中移除任何阻塞渲染的脚本或样式表，可以减少首次绘制和首次内容绘制前的等待时间。FCP：首次内容绘制耗时太长，直观上就是<strong>“白板时间太长”</strong>，影响因素就是网络连接存在性能问题、资源（例如index.html）太大传输耗时。</p><p>FMP/TTI：如果主要内容很久都没展示出来，那么很有可能是图片、样式、字体、JavaScript有较高的加载优先级，阻塞了FMP。确定页面上最关键的界面元素（主角元素）之后，您应确保初始脚本加载仅包含渲染这些元素并使其可交互所需的代码。</p><h4 id="分析关键渲染路径"><a href="#分析关键渲染路径" class="headerlink" title="分析关键渲染路径"></a>分析关键渲染路径</h4><p><strong>优化关键渲染路径就是让刘篮球尽可能快地绘制网页</strong>，减少用户看到“白屏的时间”，从FP到FCP；所以整个时间就包括了获取资源（CSS、JS、HTML）以及浏览器处理对应的文件。</p><p><strong>关键资源</strong>：可能阻止网页首次渲染的资源</p><p><strong>关键路径长度</strong>：获取所有关键资源所需的往返次数或总时间</p><p><strong>关键字节</strong>：实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。</p><h5 id="HTML、Image"><a href="#HTML、Image" class="headerlink" title="HTML、Image"></a>HTML、Image</h5><p>对于HTML，浏览器下载HTML文件，当HTML内容可用时，浏览器就会解析HTML，生成token，进而构建DOM树，DOM树构建完成同时意味着DOMContentLoaded事件触发；获取图片并不会影响DOMContentLoaded事件的触发，所以<strong>图片不会影响到首次绘制</strong>。</p><p><img src="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/images/analysis-dom.png" alt=""></p><p>关键资源（HTML），关键路径长度（最少1次），关键字节（5KB）</p><h5 id="HTML、CSS"><a href="#HTML、CSS" class="headerlink" title="HTML、CSS"></a>HTML、CSS</h5><p>加载解析HTML，然后获取CSS文件，解析为CSSOM，生成渲染树，绘制页面。</p><p><img src="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/images/analysis-dom-css.png" alt=""></p><p>关键资源（HTML、CSS），关键路径长度（最少2次），关键字节（9KB）</p><h5 id="CSS、JavaScript、HTML"><a href="#CSS、JavaScript、HTML" class="headerlink" title="CSS、JavaScript、HTML"></a>CSS、JavaScript、HTML</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Measure Script<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"measureCRP()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"timing.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了获取HTML、解析为DOM树，我们还会去加载CSS文件构建CSSOM，然后通过DOM和CSSOM构建渲染树，按道理来说，DCL也应该在DOM树生成后就触发，但是浏览器在下载解析CSS文件之前会阻止DCL事件，这是因为JS可能会去查询CSSOM。即使将脚本更改为内联，也无济于事。</p><p>所以，<strong>只要浏览器遇到script标记就会阻止，并等到CSSOM构建完毕。</strong><img src="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/images/analysis-dom-css-js.png" alt=""></p><p>关键资源（HTML、CSS、JS），关键路径（最少2次，获取css、js时为并行），关键字节（11KB）</p><p><strong>async，异步脚本的用处</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Measure Script<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"measureCRP()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"timing.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，解析HTML之后不久就会触发DCL事件，浏览器知道不需要阻止JS，不必等到CSS文件加载解析后再执行JS。</p><p><img src="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/images/analysis-dom-css-js-async.png" alt=""></p><p>关键资源（HTML、CSS），关键路径（最少2次），关键字节（9KB）</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>上面提到，有三种因素（关键资源、关键路径、关键字节）影响着首次渲染，所以优化也应该从这三点入手。</p><ol><li>减少关键资源的数量：删除、延迟、标记异步等</li><li>优化关键字节数以缩短下载时间（压缩）</li><li>优化其余关键资源的加载顺序（尽早下载所有的关键资产，缩短关键路径长度）</li></ol></li></ol><h4 id="业界一些常见的优化策略"><a href="#业界一些常见的优化策略" class="headerlink" title="业界一些常见的优化策略"></a>业界一些常见的优化策略</h4><h5 id="Google-PageSpeed-Insights-Rules"><a href="#Google-PageSpeed-Insights-Rules" class="headerlink" title="Google PageSpeed Insights Rules"></a>Google PageSpeed Insights Rules</h5><pre><code>1. **消除阻塞渲染的JavaScript和CSS**(最大限度减少网页上关键资源的数量并尽可能消除这些资源，减少下载关键字节数，优化关键路径长度)2. **优化JavaScript的使用**（JavaScript资源会阻塞解析器，所以将其标记为async或通过专门的JavaScript代码进行添加。**阻塞解析器的JavaScript强制浏览器等待CSSOM并暂停DOM的构建，继而大大延迟首次渲染的时间**）3. **延迟解析JavaScript**（延迟加载对构建首次渲染的可见内容无关紧要的脚本）4. **避免运行时间长的JavaScript**5. **优化CSS的使用**（CSS置于文档head标签内、避免使用CSS import、内联阻塞渲染的CSS）</code></pre><h5 id="Yahoo-Best-Practices-for-Speeding-Up-Your-Web-Site"><a href="#Yahoo-Best-Practices-for-Speeding-Up-Your-Web-Site" class="headerlink" title="Yahoo Best Practices for Speeding Up Your Web Site"></a>Yahoo Best Practices for Speeding Up Your Web Site</h5><ol><li>减少http请求</li><li>使用CDN</li><li>利用浏览器缓存</li><li>压缩页面元素</li><li>样式表放在head</li><li>JavaScript文件放在底部</li><li>避免CSS表达式</li><li>JS、CSS放在外部文件中</li><li>减少CDN查询</li><li>压缩JavaScript</li><li>避免重定向</li></ol><h4 id="现代前端应用的优化策略"><a href="#现代前端应用的优化策略" class="headerlink" title="现代前端应用的优化策略"></a>现代前端应用的优化策略</h4><p>   前端资源文件离线化</p><p>   页面组件化并按需加载</p><p>   预渲染提升感官性能</p><h4 id="RAIL"><a href="#RAIL" class="headerlink" title="RAIL"></a>RAIL</h4><p><img src="https://developers.google.com/web/fundamentals/performance/images/rail.png?hl=zh-cn" alt=""></p><h5 id="响应：在100ms以内响应"><a href="#响应：在100ms以内响应" class="headerlink" title="响应：在100ms以内响应"></a>响应：在100ms以内响应</h5><p>在用户注意到滞后之前有100ms的时间可以响应用户输入。</p><h5 id="动画：每10ms生成一帧"><a href="#动画：每10ms生成一帧" class="headerlink" title="动画：每10ms生成一帧"></a>动画：每10ms生成一帧</h5><p>尽管每秒生成60帧，一帧16.6ms，但是每帧只有10ms来执行代码，其余的时间用于将新帧绘制到屏幕上。</p><h5 id="空闲：最大程度增加空闲时间"><a href="#空闲：最大程度增加空闲时间" class="headerlink" title="空闲：最大程度增加空闲时间"></a>空闲：最大程度增加空闲时间</h5><p>利用空闲时间完成推迟的工作，换句话说，就是让主线程在UI线程和JS线程中切换。</p><h5 id="加载：在1000ms以内呈现内容"><a href="#加载：在1000ms以内呈现内容" class="headerlink" title="加载：在1000ms以内呈现内容"></a>加载：在1000ms以内呈现内容</h5><p>在 1 秒钟内加载您的网站。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://developers.google.com/web/fundamentals/performance/images/perf-metrics-test-cycle.png?hl=zh-cn" alt=""></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://codeburst.io/performance-metrics-whats-this-all-about-1128461ad6b" target="_blank" rel="noopener">Performance metrics. What’s this all about?</a></li><li><a href="https://w3c.github.io/paint-timing/" target="_blank" rel="noopener">Paint Timing 1</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics?hl=en" target="_blank" rel="noopener">User-centric Performance Metrics</a></li><li><a href="https://speedcurve.com/blog/user-timing-and-custom-metrics/" target="_blank" rel="noopener">User Timing and Custom Metrics</a></li><li><a href="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/analyzing-crp" target="_blank" rel="noopener">分析关键渲染路径性能</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/?hl=zh-cn" target="_blank" rel="noopener">性能为何如此重要</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn" target="_blank" rel="noopener">使用RAIL模型评估性能</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FP/FCP </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端路由的设计思想与实现 &amp;&amp; React-Router v4</title>
      <link href="/2019/02/25/react-router/"/>
      <url>/2019/02/25/react-router/</url>
      
        <content type="html"><![CDATA[<h3 id="前端路由的实现"><a href="#前端路由的实现" class="headerlink" title="前端路由的实现"></a>前端路由的实现</h3><p>前端路由分为两种实现方式：</p><ol><li><strong>HashHistory</strong>，通过修改<code>location.hash</code>，然后监听<code>hashchange</code>事件来进行对应操作。</li><li><strong>BroswerHistory</strong>，通过HTML5提供的History对象的<code>pushState</code>、<code>replaceState</code>API，然后监听<code>popstate</code>事件来进行对应操作。</li></ol><p>二者的优劣：</p><p>第一种方法兼容性更好，但是<strong>实现比较复杂</strong>，并且url<strong>比较丑陋</strong>（例如：<code>http://www.test.com/#/xxx</code>）。</p><p>第二种方法是浏览器提供的能力，所以实现比较简单，url与正常相同（例如：<code>http://www.test.com/xxx</code>），但是可能<strong>存在兼容性问题</strong>。</p><p>其实还有第三种，<strong>MemoryHistory</strong>，用于non-DOM环境下，例如React Native。</p><a id="more"></a><h4 id="基于hash的前端路由实现"><a href="#基于hash的前端路由实现" class="headerlink" title="基于hash的前端路由实现"></a>基于hash的前端路由实现</h4><p>_routes用来存储路由对应的回调函数，当hash变化时调用refresh函数（从_routes总找到对应的回调函数然后执行）；通过back函数进行回退，所以我们需要引入布尔值判定当前操作是否为回退。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._routes = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">this</span>._history = []</span><br><span class="line">        <span class="keyword">this</span>._currentUrl = <span class="string">''</span></span><br><span class="line">        <span class="keyword">this</span>._backIndex = <span class="keyword">this</span>._routes.length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>._currentIndex = <span class="keyword">this</span>._routes.length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>._isBack = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">this</span>._bindEvent()</span><br><span class="line">    &#125;</span><br><span class="line">    _bindEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'laod'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>)<span class="comment">// 加载后就触发更新</span></span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>)<span class="comment">//监听hash的变化，然后调用更新函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    route(path, cb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>._routes.set(path, cb)</span><br><span class="line">    &#125;</span><br><span class="line">    refresh = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span> <span class="comment">//读取url中'#'后面的内容</span></span><br><span class="line">        <span class="keyword">this</span>._history.push(<span class="keyword">this</span>._currentUrl)</span><br><span class="line">        <span class="keyword">this</span>._currentIndex++</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._isBack) &#123;</span><br><span class="line">            <span class="keyword">this</span>._backIndex = <span class="keyword">this</span>._currentIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> cb = <span class="keyword">this</span>._routes.get(<span class="keyword">this</span>._currentUrl)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) cb()<span class="comment">//执行路由对应的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>._isBack = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    back = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._isBack = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._backIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._backIndex = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>._backIndex -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        location.hash = <span class="string">`#&#123;this._history[this._backIndex]&#125;`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于History的前端路由实现"><a href="#基于History的前端路由实现" class="headerlink" title="基于History的前端路由实现"></a>基于History的前端路由实现</h4><p>依赖于HTML5提供的History对象，Router的实现简便很多；使用go来进行前往指定路由，用back回退。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BroswerRouter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._routes = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">this</span>._bindEvent()</span><br><span class="line">    &#125;</span><br><span class="line">    _bindEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> path = e.state &amp;&amp; e.state.path</span><br><span class="line">            <span class="keyword">let</span> cb = <span class="keyword">this</span>._routes.get(path)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cb = <span class="string">'function'</span>) cb()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    init(path) &#123;</span><br><span class="line">        history.replaceState(&#123;<span class="attr">path</span>: path&#125;, <span class="string">''</span>, path)</span><br><span class="line">        <span class="keyword">let</span> cb = <span class="keyword">this</span>._routes.get(path)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cb = <span class="string">'function'</span>) cb()</span><br><span class="line">    &#125;</span><br><span class="line">    route(path, cb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>._routes.set(path, cb)</span><br><span class="line">    &#125;</span><br><span class="line">    go = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">        history.pushState(&#123;<span class="attr">path</span>: path&#125;, <span class="string">''</span>, path)</span><br><span class="line">        <span class="keyword">let</span> cb = <span class="keyword">this</span>._routes.get(path)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) cb()</span><br><span class="line">    &#125;</span><br><span class="line">    back = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        history.back()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-Router-v4"><a href="#React-Router-v4" class="headerlink" title="React-Router v4"></a>React-Router v4</h3><p>👆👆👆只是简单的前度路由的模拟，但是涉及到React或者Vue的时候，我们需要另外处理渲染逻辑，所以会牵扯到生命周期和组件通信。</p><p>下面简单分析概述一下React-Router v4</p><h4 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h4><p>React-Router分为4个package，分别为：react-router、react-router-dom、react-router-native、react-router-config。</p><p><strong>react-router</strong>：负责通用的路由逻辑，被其他package所依赖，无需特别引入。</p><p><strong>react-router-dom</strong>: 负责浏览器的路由管理。</p><p>react-router-native：负责react-native的路由管理。</p><p>react-router-config: 用于配置特别的react-router，比如SSR环境下。</p><p>下面介绍一下react-router中只要的模块👇👇👇</p><h5 id="Router（react-router-Router、react-router-RouterContext、react-router-dom-BrowserRouter）"><a href="#Router（react-router-Router、react-router-RouterContext、react-router-dom-BrowserRouter）" class="headerlink" title="Router（react-router/Router、react-router/RouterContext、react-router-dom/BrowserRouter）"></a>Router（react-router/Router、react-router/RouterContext、react-router-dom/BrowserRouter）</h5><p>BroswerRouter在内部创建一个全局对象history，然后通过props传递给Router组件，Router组件再将这个history属性作为context传递给子组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建context，用于全局传递信息</span></span><br><span class="line"><span class="keyword">const</span> createNamedContext = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> context = React.createContext();</span><br><span class="line">  context.Provider.displayName = <span class="string">`<span class="subst">$&#123;name&#125;</span>.Provider`</span>;</span><br><span class="line">  context.Consumer.displayName = <span class="string">`<span class="subst">$&#123;name&#125;</span>.Consumer`</span>;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> RouterContext = createNamedContext(<span class="string">'Router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> computeRootMatch(pathname) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">url</span>: <span class="string">"/"</span>, <span class="attr">params</span>: &#123;&#125;, <span class="attr">isExact</span>: pathname === <span class="string">"/"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      location: props.history.location</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a bit of a hack. We have to start listening for location</span></span><br><span class="line">    <span class="comment">// changes here in the constructor in case there are any &lt;Redirect&gt;s</span></span><br><span class="line">    <span class="comment">// on the initial render. If there are, they will replace/push when</span></span><br><span class="line">    <span class="comment">// they mount and since cDM fires in children before parents, we may</span></span><br><span class="line">    <span class="comment">// get a new location before the &lt;Router&gt; is mounted.</span></span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingLocation = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!props.staticContext) &#123;</span><br><span class="line">        <span class="comment">//！！！在这里进行监听，每次路由变化都会触发顶层Router的回调事件，然后Router进行setState，再向下传递context，最下面的Route根据context内容判断是否进行渲染！！！</span></span><br><span class="line">      <span class="keyword">this</span>.unlisten = props.history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._pendingLocation = location;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingLocation) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">location</span>: <span class="keyword">this</span>._pendingLocation &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unlisten) <span class="keyword">this</span>.unlisten();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Provider</span><br><span class="line">        children=&#123;<span class="keyword">this</span>.props.children || <span class="literal">null</span>&#125;</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          history: <span class="keyword">this</span>.props.history,</span><br><span class="line">          location: <span class="keyword">this</span>.state.location,</span><br><span class="line">          match: Router.computeRootMatch(<span class="keyword">this</span>.state.location.pathname),</span><br><span class="line">          staticContext: <span class="keyword">this</span>.props.staticContext</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props);</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="Route（react-router-Route）"><a href="#Route（react-router-Route）" class="headerlink" title="Route（react-router/Route）"></a>Route（react-router/Route）</h5><p>Router是借助context向Route传递内容的，Router作为Provider、Route作为Comsumer，所以Route必须包含在Router内部。</p><p>同时，Route借助context将history、location、match作为三个独立的属性传递给要渲染的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || context.location</span><br><span class="line">          <span class="keyword">const</span> match = <span class="keyword">this</span>.props.computedMatch</span><br><span class="line">            ? <span class="keyword">this</span>.props.computedMatch <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line">            : <span class="keyword">this</span>.props.path</span><br><span class="line">              ? matchPath(location.pathname, <span class="keyword">this</span>.props)</span><br><span class="line">              : context.match</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> props = &#123; ...context, location, match &#125;<span class="comment">//传递给要渲染的组件</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Preact uses an empty array as children by</span></span><br><span class="line">          <span class="comment">// default, so use null if that's the case.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp; children.length === <span class="number">0</span>) &#123;</span><br><span class="line">            children = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">"function"</span>) &#123;</span><br><span class="line">            children = children(props);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (children === <span class="literal">undefined</span>) &#123;</span><br><span class="line">              children = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">              <span class="comment">//提供了多种渲染的方式，children(子元素)、component（props）、render(props)</span></span><br><span class="line">            &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">              &#123;children &amp;&amp; !isEmptyChildren(children)</span><br><span class="line">                ? children</span><br><span class="line">                : props.match</span><br><span class="line">                  ? component</span><br><span class="line">                    ? React.createElement(component, props)<span class="comment">//这里是通过React.creareElement创建组件的，所以React Diff认为每次都不一样，更新的时候会先卸载之前的组件再重新安装新的组件。</span></span><br><span class="line">                    : render</span><br><span class="line">                      ? render(props)</span><br><span class="line">                      : <span class="literal">null</span></span><br><span class="line">                  : <span class="literal">null</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">          );</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>RouterContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Switch（react-router-Switch）"><a href="#Switch（react-router-Switch）" class="headerlink" title="Switch（react-router/Switch）"></a>Switch（react-router/Switch）</h5><p>Switch的作用是，当Switch中的第一个Route匹配后就不会渲染其他的Route，类似swich这个语法。源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || context.location;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> element, match;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We use React.Children.forEach instead of React.Children.toArray().find()</span></span><br><span class="line">          <span class="comment">// here because toArray adds keys to all child elements and we do not want</span></span><br><span class="line">          <span class="comment">// to trigger an unmount/remount for two &lt;Route&gt;s that render the same</span></span><br><span class="line">          <span class="comment">// component at different URLs.</span></span><br><span class="line">          React.Children.forEach(<span class="keyword">this</span>.props.children, child =&gt; &#123;</span><br><span class="line">         <span class="comment">//按children的顺序依次遍历子元素，成功就标记这个子元素和对应的location和comutedMatch，最后调用React.cloneElement渲染，否则返回null</span></span><br><span class="line">            <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">              element = child;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"><span class="comment">//Switch通过matchPath来判断是否匹配成功</span></span><br><span class="line">              match = path</span><br><span class="line">                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class="line">                : context.match;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> match</span><br><span class="line">            ? React.cloneElement(element, &#123; location, <span class="attr">computedMatch</span>: match &#125;)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="matchPath（react-router-matchPath）"><a href="#matchPath（react-router-matchPath）" class="headerlink" title="matchPath（react-router/matchPath）"></a>matchPath（react-router/matchPath）</h5><p>前面多次提到使用matchPath来判断是否匹配成功，那么到底是如何进行匹配的呢？下面是matchPath的源码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存，不必每次都生成一个正则表达式用于判断</span></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> cacheLimit = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> cacheCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilePath</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cacheKey = <span class="string">`<span class="subst">$&#123;options.end&#125;</span><span class="subst">$&#123;options.strict&#125;</span><span class="subst">$&#123;options.sensitive&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> pathCache = cache[cacheKey] || (cache[cacheKey] = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pathCache[path]) <span class="keyword">return</span> pathCache[path];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = [];</span><br><span class="line">  <span class="keyword">const</span> regexp = pathToRegexp(path, keys, options);</span><br><span class="line">  <span class="keyword">const</span> result = &#123; regexp, keys &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCount &lt; cacheLimit) &#123;</span><br><span class="line">    pathCache[path] = result;</span><br><span class="line">    cacheCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Public API for matching a URL pathname to a path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchPath</span>(<span class="params">pathname, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">"string"</span>) options = &#123; <span class="attr">path</span>: options &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; path, exact = <span class="literal">false</span>, strict = <span class="literal">false</span>, sensitive = <span class="literal">false</span> &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paths = [].concat(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths.reduce(<span class="function">(<span class="params">matched, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span> matched;</span><br><span class="line">    <span class="keyword">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class="line">      end: exact,</span><br><span class="line">      strict,</span><br><span class="line">      sensitive</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> match = regexp.exec(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [url, ...values] = match;</span><br><span class="line">    <span class="keyword">const</span> isExact = pathname === url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &amp;&amp; !isExact) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      path, <span class="comment">// the path used to match</span></span><br><span class="line">      url: path === <span class="string">"/"</span> &amp;&amp; url === <span class="string">""</span> ? <span class="string">"/"</span> : url, <span class="comment">// the matched portion of the URL</span></span><br><span class="line">      isExact, <span class="comment">// whether or not we matched exactly</span></span><br><span class="line">      params: keys.reduce(<span class="function">(<span class="params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">        memo[key.name] = values[index];</span><br><span class="line">        <span class="keyword">return</span> memo;</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Link（react-router-dom-Link）"><a href="#Link（react-router-dom-Link）" class="headerlink" title="Link（react-router-dom/Link）"></a>Link（react-router-dom/Link）</h5><p>Link是react-router-dom中的，而不是通用模块里的元素；Link是一个用a标签包裹、用来实现跳转的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(event, history) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onClick) <span class="keyword">this</span>.props.onClick(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !event.defaultPrevented &amp;&amp; <span class="comment">// onClick prevented default</span></span><br><span class="line">      event.button === <span class="number">0</span> &amp;&amp; <span class="comment">// ignore everything but left clicks</span></span><br><span class="line">      (!<span class="keyword">this</span>.props.target || <span class="keyword">this</span>.props.target === <span class="string">"_self"</span>) &amp;&amp; <span class="comment">// let browser handle "target=_blank" etc.</span></span><br><span class="line">      !isModifiedEvent(event) <span class="comment">// ignore clicks with modifier keys</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> method = <span class="keyword">this</span>.props.replace ? history.replace : history.push;</span><br><span class="line"></span><br><span class="line">      method(<span class="keyword">this</span>.props.to);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; innerRef, replace, to, ...rest &#125; = <span class="keyword">this</span>.props; <span class="comment">// eslint-disable-line no-unused-vars</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> location =</span><br><span class="line">            <span class="keyword">typeof</span> to === <span class="string">"string"</span></span><br><span class="line">              ? createLocation(to, <span class="literal">null</span>, <span class="literal">null</span>, context.location)</span><br><span class="line">              : to;</span><br><span class="line">          <span class="keyword">const</span> href = location ? context.history.createHref(location) : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;a</span><br><span class="line">              &#123;...rest&#125;</span><br><span class="line">              onClick=&#123;event =&gt; <span class="keyword">this</span>.handleClick(event, context.history)&#125;</span><br><span class="line">              href=&#123;href&#125;</span><br><span class="line">              ref=&#123;innerRef&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>H5的history对象中通过pushState、replaceState只会改变路由而不会发生跳转，但是之前提的Router中的listen可以监听到路由的变化然后更新props和context，让下层的Route重新匹配，完成需要渲染部分的更新。如何监听的呢？这部分在history库中的createTransitionManager中（React-Router依赖于history）。</p><h5 id="createTransitionManager（history-createTransitionManager）"><a href="#createTransitionManager（history-createTransitionManager）" class="headerlink" title="createTransitionManager（history/createTransitionManager）"></a>createTransitionManager（history/createTransitionManager）</h5><p>下面就是源码，观察者模式的一个应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTransitionManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prompt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setPrompt</span>(<span class="params">nextPrompt</span>) </span>&#123;</span><br><span class="line">    prompt = nextPrompt;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prompt === nextPrompt) prompt = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">confirmTransitionTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    location,</span></span></span><br><span class="line"><span class="function"><span class="params">    action,</span></span></span><br><span class="line"><span class="function"><span class="params">    getUserConfirmation,</span></span></span><br><span class="line"><span class="function"><span class="params">    callback</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> If another transition starts while we're still confirming</span></span><br><span class="line">    <span class="comment">// the previous one, we may end up in a weird state. Figure out the</span></span><br><span class="line">    <span class="comment">// best way to handle this.</span></span><br><span class="line">    <span class="keyword">if</span> (prompt != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result =</span><br><span class="line">        <span class="keyword">typeof</span> prompt === <span class="string">'function'</span> ? prompt(location, action) : prompt;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> getUserConfirmation === <span class="string">'function'</span>) &#123;</span><br><span class="line">          getUserConfirmation(result, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         </span><br><span class="line">          callback(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Return false from a transition hook to cancel the transition.</span></span><br><span class="line">        callback(result !== <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">appendListener</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isActive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isActive) fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listeners.push(listener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      isActive = <span class="literal">false</span>;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">notifyListeners</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(...args));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setPrompt,</span><br><span class="line">    confirmTransitionTo,</span><br><span class="line">    appendListener,</span><br><span class="line">    notifyListeners</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WithRouter（react-router-WithRouter）"><a href="#WithRouter（react-router-WithRouter）" class="headerlink" title="WithRouter（react-router/WithRouter）"></a>WithRouter（react-router/WithRouter）</h5><p>光从名字上看就知道，这是一个HOC，这个高阶组件的作用就是让我们在非Route中的组件也能获取到路由信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> C = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route</span><br><span class="line">        children=&#123;routeComponentProps =&gt; (</span><br><span class="line">          &lt;Component</span><br><span class="line">            &#123;...remainingProps&#125;</span><br><span class="line">            &#123;...routeComponentProps&#125;</span><br><span class="line">            ref=&#123;wrappedComponentRef&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  C.displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span>;</span><br><span class="line">  C.WrappedComponent = Component;</span><br><span class="line">  <span class="keyword">return</span> hoistStatics(C, Component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们来大致梳理一下，前端路由的过程。</p><ol><li>当Router组件创建时，我们会在上面注册一个事件用于监听路由的变化，一旦路由变化就会触发setState。</li><li>点击Link其实就是点击a标签进行跳转，但是我们阻止了跳转；实际上我们在这里调用history的pushState方法，将当前path存储，并<strong>修改路由</strong>（此时并没有改变页面的渲染）。</li><li>每次路由的变化就会触发Router的setState，所以此时会成新context传递给下层。</li><li>下层的Route拿到新的context后根据matchPath判断path是否和location匹配，匹配就渲染，不匹配不渲染，此时<strong>页面的渲染改变</strong>。</li></ol><p>所以说整个前端路由的思路（以React-Router为例）就是：</p><ol><li>首先创建一个全局对象，通过context API向下传递histpry对象，从而控制具体的渲染；（渲染变化）</li><li>添加一个Event Emitter，用于响应路由变化/Hash变化，然后进行对应的逻辑处理；（路由变化）</li><li>路由变化/Hash变化导致context变化，context变化又导致渲染改变；（渲染变化）</li></ol><p><strong>那么，前端路由跟后端路由有什么区别呢？</strong></p><p>后端路由，数据渲染是由服务器解决，例如利用express构建的服务端应用，render(‘xxx.pug’)，服务器渲染好页面后返回给浏览器端，浏览器显示。表现形式就是，跳转页面会白屏，加载～</p><p>前端路由，数据渲染是由浏览器端解决，例如上述的例子，但是路由变化和渲染变化是分隔开的，所以我们需要通过<code>hashchange</code> or <code>popstate</code>将路由变化和渲染变化连接起来。表现形式则是，跳转页面不会白屏～</p><p>那是不是前端路由就可以完全取代后端路由了呢？不是的，前端路由也存在不足，SEO就是一个big problem。</p><p>那是不是前端路由和后端路由就是相互隔绝的呢？不是的，二者之间又衍生出许多新的hack手段，例如预渲染（服务端线构建出一部分静态HTML，用于直出浏览器，然后剩余使用前端渲染来实现）、SSR。</p><p><strong>既然谈到了预渲染和SSR；那就先占个坑位，学习一下SSR和预渲染～</strong></p><h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><ol><li><a href="https://segmentfault.com/a/1190000007238999#articleHeader1" target="_blank" rel="noopener">前端路由的两种实现原理</a></li><li><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b" target="_blank" rel="noopener">面试官：你了解前端路由吗</a></li><li><a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router" target="_blank" rel="noopener">React-Router源码</a></li><li><a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener">history源码—Manage session history with JavaScript</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Processes and Threads</title>
      <link href="/2018/12/09/processes-and-threads/"/>
      <url>/2018/12/09/processes-and-threads/</url>
      
        <content type="html"><![CDATA[<p>Process and Thread are most important concepts in Operating System.</p><a id="more"></a><h2 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h4><p>In process model, all the runnable software on the computer, sometimes include operating system, is organized into a number of <strong>sequential process</strong>.</p><p>A process is just an instance of an executing program, including the current vlaues of program counter, registers, and variables.</p><p>A CPU can really run only one process at a time.</p><p>In traditional operating systems, each process has an address space and a single thread of control.</p><p>In many situations , it is desirable to have multiple threads of control in the same address space running in quasi-parallel, as though they were (almost) separate processes(except for the shared address spaces).</p><h4 id="Process-Creation"><a href="#Process-Creation" class="headerlink" title="Process Creation"></a>Process Creation</h4><ol><li>System initialization.</li><li>Execution of a process-creation system call by running process.</li><li>A user request to create a new process.</li><li>A initiation of a batch job.</li></ol><p>Daemons: Processes that stay in the background to handle some activity.</p><p>Fork: this system call creates an exact clone of the calling process. After the fork, the two processes, the parent and the child, have the same memory image, the same environment strings, and the same open files.</p><h4 id="Process-Termination"><a href="#Process-Termination" class="headerlink" title="Process Termination"></a>Process Termination</h4><ol><li>Normal exit(voluntary).</li><li>Error exit(voluntary).</li><li>Fatal error(involuntary).</li><li>Killed by aother process(involuntary).</li></ol><h4 id="Process-Hierarchies"><a href="#Process-Hierarchies" class="headerlink" title="Process Hierarchies"></a>Process Hierarchies</h4><p>In <strong>UNIX</strong>, a process and all of its children and further descendants together from a process group.</p><p><strong>Windows</strong> has no concept of a process hierarchy, all processes are equal. The only hint of a process hierarchy is that when a process is created, the parent is given a special token (called a handle) that it can use to control the child.</p><h4 id="Process-States"><a href="#Process-States" class="headerlink" title="Process States"></a>Process States</h4><ol><li>Running.（actually using the CPU at that instant）</li><li>Ready. (runnable; temporatily stopped to let another process run)</li><li>Blocked.(unable to run until some external event happens)</li></ol><h4 id="Implementation-of-Processes"><a href="#Implementation-of-Processes" class="headerlink" title="Implementation of Processes"></a>Implementation of Processes</h4><p><strong>Process Table</strong>: contains per process, each entry contains important information about the process state, including its program counter, stack pointer, memory allocation, the status of its open files, its accounting and scheduling infomation, and everything else about the process that must be saved when the process is switched from running to ready or blocked state so that it can be restarted later as if it had never been stopped.</p><p>Skeleton of what the lowest level of the operating system does when an interrupt occurs:</p><ol><li>Hardware stacks program counter, etc.</li><li>Hardware loads new program counter from interrupt vector.</li><li>Assembly-language procedure saves registers.</li><li>Assembly-language procedure sets up new stack.</li><li>C interrupt service runs (typically reads and buffers input).</li><li>Scheduler decides which process is to run next.</li><li>C procedure returns to the assembly code.</li><li>Assembly-language procedure starts up new current process.</li></ol><p>A process may be interrputed thousands of times during its execution, but the key idea is that after each interrupt the interrupted process returns to precisely the same state it was in before the interrupt occurred.</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="Concept-1"><a href="#Concept-1" class="headerlink" title="Concept"></a>Concept</h4><p>A thread can be reguard as  a miniprocess.</p><p>Why would anyone want to have threads?</p><ol><li>Only now with threads we add a element: the ability for parallel entities to share an address space and all of its data, which is why having multiple processes (with their separate address spaces) will not work.</li><li>Threads are lighter weight than processes, they are easier to create and destory than process.</li><li>Threads yield no performance gain when all of then are CPU bound, but when where is substantial computing and also substantial I/O, having threads allows these activities to overlap, thus speeding up the application.</li></ol><h4 id="The-Classical-Thread-Model"><a href="#The-Classical-Thread-Model" class="headerlink" title="The Classical Thread Model"></a>The Classical Thread Model</h4><p>The process model is based on two independent concepts: resource grouping and execution.</p><p>A process has a  thread of execution, usually shortened to just thread. </p><p>Processes are used to group resources together; threads are the entities scheduled for executing on the CPU.</p><h4 id="Implementing-Threads-in-User-Space"><a href="#Implementing-Threads-in-User-Space" class="headerlink" title="Implementing Threads in User Space"></a>Implementing Threads in User Space</h4><p>Advantage :</p><ol><li>When a thread is finished running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Furthermore, it can then call the thread scheduler to pick another thread to run. The procedure that saves the thread’s state and the scheduler are just local procedures, so invoking them is much more efficient than making a kernel call. Among other issues, no trap is needed, no context switch is needed, the memory cache need not be flushed, and so on. This makes thread scheduling very fast.</li><li>They allow each process to have its own customized scheduling algorithm.</li></ol><p>Problem:</p><ol><li>How implement blocking system call?</li><li>if a thread starts running, no other thread in that process will ever run unless the first thread voluntarily gives up the CPU.</li></ol><h4 id="Implementing-Threads-in-the-Kernel"><a href="#Implementing-Threads-in-the-Kernel" class="headerlink" title="Implementing Threads in the Kernel"></a>Implementing Threads in the Kernel</h4><ol><li>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. </li><li>Kernel threads do not require any new, nonblocking system calls.</li></ol><p>While kernel threads solve some problems, they do not solve all problems. </p><h4 id="Hybird-Implementations"><a href="#Hybird-Implementations" class="headerlink" title="Hybird Implementations"></a>Hybird Implementations</h4><p>Using kernel-level threads and then multiplex user-level threads onto some or all of them.With this approach, the kernel is aware of only the kernel-level threads and schedules those. Some of those threads may have multiple user-level threads multiplexed on top of them.</p><h4 id="Scheduler-Activations"><a href="#Scheduler-Activations" class="headerlink" title="Scheduler Activations"></a>Scheduler Activations</h4><p>The goals of the scheduler activation work are to mimic the functionality of kernel threads, but with the better performance and greater flexibility usually associated with threads packages implemented in user space.</p><p>When scheduler activations are used, the kernel assigns a certain number of virtual processors to each process and lets the (user-space) run-time system allocate threads to processors.</p><p>The basic idea that makes this scheme work is that when the kernel knows that a thread has blocked (e.g., by its having executed a blocking system call or caused a page fault), the kernel notifies the process’ run-time system, passing as parameters on the stack the number of the thread in question and a description of the event that occurred. The notification happens by having the kernel activate the run-time system at a known starting address, roughly analogous to a signal in UNIX. This mechanism is called an upcall.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1打造一款没人用的前端框架</title>
      <link href="/2018/12/07/X-react/"/>
      <url>/2018/12/07/X-react/</url>
      
        <content type="html"><![CDATA[<p>如果可以，为什么我们不自己打造一款没人用的前端框架呢？</p><p>首先介绍如何创建虚拟DOM节点以及将虚拟DOM节点转化为真实DOM节点，参照React/Preact</p><a id="more"></a><h3 id="创建虚拟DOM节点"><a href="#创建虚拟DOM节点" class="headerlink" title="创建虚拟DOM节点"></a>创建虚拟DOM节点</h3><p>我们在React会经常写出下列类似的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = &lt;span id='example'&gt;Hello, Example&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>这段代码不是合法的JavaScript代码，这段是JSX代码。<strong>JSX是JavaScript的语法拓展，用来声明React中的元素</strong>。看起来它就像一个模版语言，但是它并不是，它是完全是在JavaScript内部实现的。</p><p>那么我们写的JSX代码是如何被JavaScript解析的呢？</p><p>这里就不得不提一下Babel，Babel是一个JavaScript编译器，将用ES6/ES7等ES最新的语法书写的代码转换为浏览器支持的ES版本（如ES5、ES3）。这就让我们开发者能够最快的用上ES的新语法糖</p><p> Awesome！！！🎉🎉🎉</p><p>Babel在这里用于将我们书写的JSX代码转换为标准javaScript代码，上面的例子就被转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = h(<span class="string">'span'</span>, &#123;<span class="attr">id</span>: <span class="string">'example'</span>&#125;, <span class="string">'Hello, Example'</span>)</span><br></pre></td></tr></table></figure><p>所以我们需要书写一个h函数用于被转译的代码调用，至于为什么叫h，因为它来源于<a href="https://github.com/hyperhype/hyperscript" target="_blank" rel="noopener">hyperscript</a>中的h函数。</p><p>接下来就是完成一个非常非常简单的h函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个Virtual DOM 对象</span></span><br><span class="line"><span class="comment">* @param nodeName 标签名称</span></span><br><span class="line"><span class="comment">* @param attributes 属性</span></span><br><span class="line"><span class="comment">* @param ...args 组件的孩子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = args.length ? [].concat(...args) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        nodeName, attributes, children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个函数，我们就能创建一个简单的Virtual Dom对象，比如上面的JSX例子，调用这个函数我们会得到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    nodeName: "span",</span><br><span class="line">    attributes: &#123;</span><br><span class="line">        "id": "example"</span><br><span class="line">    &#125;,</span><br><span class="line">    children: ["Hello, Example"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个函数是远远不能满足实际生产中的要求，所以后面我们会慢慢完善它。</p><h3 id="虚拟DOM转换为真实DOM"><a href="#虚拟DOM转换为真实DOM" class="headerlink" title="虚拟DOM转换为真实DOM"></a>虚拟DOM转换为真实DOM</h3><p>接下来我们定义一个render函数，用于将Virtual DOM对象渲染为真实的DOM节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.split) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">document</span>.createElement(vnode.nodeName)</span><br><span class="line">    <span class="keyword">let</span> attributes = vnode.attributes || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(attributes).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">        node.setAttribute(k, attributes[k])</span><br><span class="line">    &#125;)</span><br><span class="line">    (vnode.children || []).forEach(<span class="function"><span class="params">c</span> =&gt;</span> node.appendChild(render(c)))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们通常会将创建出来的真实DOM节点挂在现存的节点上，所以render函数需要改造一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> container.appendChild(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Preact </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简析Redis集群</title>
      <link href="/2018/11/27/redis-cluster/"/>
      <url>/2018/11/27/redis-cluster/</url>
      
        <content type="html"><![CDATA[<p>Redis Cluster是Redis的分布式解决方案，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster的架构来达到负载均衡的目的。</p><a id="more"></a><h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即将数据姐划分到多个节点上，每个节点只负责整体数据的一个子集。常见的分区规则有顺序分区和哈希分区两种，Redis采用的哈希分区规则。</p><p>下面是常见的几种哈希分区规则</p><h4 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h4><p>使用特定的数据key，再根据节点的数量N使用公式：hash(key)%N计算出哈希值，用来决定数据 映射到哪个节点上。这样的方式比较简单，常用于数据库的分库分表规则，一般采用预分区的的方式，提前根据数据量规划好分区数。但是缺点也比较明显，扩容和收缩时，数据节点的映射关系需要重新计算，会导致数据的重写迁移。</p><h4 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h4><p>系统为每个节点分配一个token，范围一般在0～2^32，这些token构成一个哈希环。数据读写执行时，先根据key计算hash值，然后顺时针找到第一个不小于该哈希值的token节点。相对于节点取余的方式，加入或删除节点只影响哈喜欢中相邻的节点，对其他节点无影响。但是，一致性哈希也存在一些问题：加减节点会造成哈希环中部分数据无法命中；当使用少量节点时，节点变化将大范围影响哈希环中数据映射；普通的一致性哈希分区在增减节点时需要增加一倍或删去一杯节点才能保证数据和负载的均衡。<a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">白话解析—一致性哈希算法</a></p><h4 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h4><p>虚拟槽分区使用分散度良好的哈希函数把所有的数据映射到一个固定范围的整数集合中，整数定义为槽(slot)。Redis Cluster的槽范围为0～16383，远远大于实际中的数据节点数。slot是集群内数据管理和迁移的基本单位。</p><h4 id="Redis数据分区"><a href="#Redis数据分区" class="headerlink" title="Redis数据分区"></a>Redis数据分区</h4><p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383整数槽内。每一个结点复制维护一部分槽以及槽所映射的键值数据。这样做的好处是：解耦数据与节点之间的关系；节点自身维护槽的映射关系，不需要客户端或代理服务维护槽分区元数据；支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</p><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>搭建集群分为准备节点、节点握手、分配槽等三个步骤。（可以用redis-trib.rb搭建集群，也可以根据Redis手动建立一个集群）</p><h4 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h4><p>略</p><h4 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h4><p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。</p><h4 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h4><p>只有把16384个槽全部分配给节点后，集群才进入在线状态。Redis Cluster会把所有数据映射到这16384个槽中，每个key会映射到一个固定的槽中，只有当节点分配了槽，才能响应和这些槽关联的键命令。</p><h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><p>在分布式存储中需要提供维护节点元数据（节点负责哪些数据，是否出现故障等状态信息）信息的机制。Redis Cluster采用用于p2p的Gossip协议，Gossip协议的工作原理就是节点不断通信交换信息，一段时间后所有节点都会知道集群完整的信息，类似流行病传播。</p><h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><ol><li>集群中每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</li><li>每个节点在固定周期内通过特定规则选择几个节点发送ping消息。</li><li>接到ping消息的节点用pong消息作为响应。</li></ol><h4 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h4><p>Gossip协议的主要职责就是信息交换，信息交换的载体就是节点彼此发送的Gossip消息。常用的Gossip消息分为：ping消息、pong消息、meet消息、fail消息。所有的消息格式划分为消息头和消息体，消息头包含发送节点自身状态数据，接受节点根据消息头就可以获取到发送节点的相关数据。</p><p>meet消息：用于通知新节点加入。</p><p>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态消息。</p><p>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方 确认消息正常通信。pong消息内部风中了自身状态数据。</p><p>fail消息：当节点判断集群内另一个结点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</p><h4 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h4><p>Redis Cluster内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点选择过多虽然可以做到信息及时交换但成本过高，节点选择过少会降低集群内所有节点彼此信息交换频率，从而影响故障判断、新节点发现等需求的速度。</p><h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><p>Redis Cluster提供了灵活的节点扩容和收缩方案，在不影响对外服务的同时，为集群添加节点进行扩容或下线部分节点进行缩容，其中原理可抽象为槽和对应数据在不同节点之间灵活移动。</p><h4 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h4><p>扩容集群的过程为准备新节点、新节点加入集群、迁移槽和数据等三个步骤。</p><h5 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h5><p>槽在迁移过程中，集群可以正常提供读写服务。槽是Redis Cluster数据管理和迁移的最小单位，所以首先需要为新节点制定槽迁移计划。槽迁移计划需要确保每个节点分配的槽数量接近，从而保证各节点的数据均匀。</p><p>数据迁移过程是逐个槽进行的，大体流程为：（1）目标节点准备导入槽；（2）源节点准备导出槽；（3）获取槽下{count}个键；（4）批量迁移相关键的数据；（5）循环迁移键，重复第3、4步；（6）通知槽分配给目标节点。</p><h4 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h4><p>收缩集群以为需要下线部分节点，整个过程可分为下线迁移槽、忘记节点等两个步骤。</p><h5 id="下线迁移槽"><a href="#下线迁移槽" class="headerlink" title="下线迁移槽"></a>下线迁移槽</h5><p>与扩容集群中的迁移槽和数据相似～</p><h5 id="忘记节点"><a href="#忘记节点" class="headerlink" title="忘记节点"></a>忘记节点</h5><p>由于集群内的节点不断通过Gossip消息彼此交换节点状态，所以需要让其他节点不再与要下线的节点进行Gossip消息交换。</p><h3 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h3><p>为了追求性能最大化，Redis Cluster采用的是客户端直连节点的方式。</p><h4 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h4><p>在集群模式下，Redis接受任何key相关的命令时首先计算对应的槽，再根据槽找出对应的节点，如果节点是自身，则处理命令；否则返回MOVED重定向错误，通知客户端请求正确的节点。节点对于不属于它的键命令只回复重定向响应，并不负责转发。键命令执行步骤主要分为两步：计算槽、查找槽所对应的节点。</p><h5 id="计算槽"><a href="#计算槽" class="headerlink" title="计算槽"></a>计算槽</h5><p>通过CRC16计算key的有效部分的hash值，再对16383取余，使每个键都能映射到0～16383槽范围内。</p><h5 id="槽节点查询"><a href="#槽节点查询" class="headerlink" title="槽节点查询"></a>槽节点查询</h5><p>Redis计算得到key对应的槽后，需要查询对应的节点。集群内通过消息交换每个节点都会知道所有节点的槽信息，内部保存在clusterState结构中。</p><h4 id="Smart客户端"><a href="#Smart客户端" class="headerlink" title="Smart客户端"></a>Smart客户端</h4><p>Smart客户端在内部维护者从slot-&gt;node的映射关系，本地就可以实现键到节点的查询，从而保证IO效率最大化，而MOVED重定向负责协助Smart客户端更新slot-&gt;node映射。</p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p>Redis集群支持在线迁移槽和数据来完成水平伸缩。ASK重定向说明集群正在进行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。但是MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>Redis Cluster实现了高可用，当集群内少量节点出现故障时通过自动故障转移保证集群可以正常的对外提供服务。</p><h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><p>Redis集群内节点通过ping/pong消息实现节点通信，消息不但可以传播节点槽信息，还可以传播主从状态、节点故障等信息，所以故障发现也是通过消息传播机制实现的。</p><h5 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h5><p>指某个节点认为另一个节点不可用，即下线状态。</p><h5 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h5><p>指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。</p><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点，则需要从它的从节点中选出一个替换他，从而保证见的高可用。整个大致分为资格检查、准备选举时间、发起选举、选举投票、替换主节点。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简析Redis哨兵实现原理</title>
      <link href="/2018/11/23/redis-sentinel/"/>
      <url>/2018/11/23/redis-sentinel/</url>
      
        <content type="html"><![CDATA[<p>Redis Sentinel 是一个分布式架构(Sentinel节点、Redis数据节点、Redis客户端分布在不同的物理节点上)，其中包括了若干个Sentinel节点和Redis数据节点，每个Sentinel节点对数据节点和其他Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。若该节点为主节点，它会和其他Sentinel节点共同协商，若大部分节点皆表示该主节点不可达，那么就会从Sentinel中选举出一个Sentinel节点来完成自动故障转移的工作，同时将这个变化实时通知给Redis应用方。</p><a id="more"></a><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h3><p>Redis通过三个定时监控任务完成对各个节点的发现和监控。<strong>_</strong>s_</p><h4 id="获取最新拓扑结构"><a href="#获取最新拓扑结构" class="headerlink" title="获取最新拓扑结构"></a>获取最新拓扑结构</h4><p>每隔10s，每个Sentinel节点会向主节点和从节点发送<code>info</code>命令获取最新的拓扑结构。</p><p>作用：</p><ol><li>通过向主节点执行info命令，获取从节点信息，所以Sentinel节点不需要显式配置监控从节点。</li><li>当有新的从节点加入时都可以立刻感知出来。</li><li>节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。</li></ol><h4 id="Sentinel节点发布和订阅sentinel-hello频道"><a href="#Sentinel节点发布和订阅sentinel-hello频道" class="headerlink" title="Sentinel节点发布和订阅sentinel:hello频道"></a>Sentinel节点发布和订阅<strong>sentinel</strong>:hello频道</h4><p>每隔2s，每个Sentinel节点会向Redis数据节点的<strong>__</strong>sentinel__:hello频道发送该sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道来了解其他Sentinel节点以及它们对主节点的判断。</p><p>作用：</p><ol><li>发现新的Sentinel节点。</li><li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</li></ol><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>每隔1s，每隔Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确定这些节点是否可达。</p><p>作用：</p><ol><li>判断节点是否可达的重要依据。</li></ol><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>上面提到心跳检测，如果这些节点超过down-after-millionsections还没有进行有效回复，Sentinel节点就会对该节点做失败判断，这个行为叫做主观下线。Sentinel节点、从节点，主观下线后没有后续的故障转移操作。</p><h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当Sentinel节点主观下线的节点是主节点时，该Sentinel节点会通过<code>sentinel is-master-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel认为主节点的确出现问题，此时该Sentinel对主节点做出客观下线的决定。</quorum></p><h3 id="领导者Sentinel节点选举"><a href="#领导者Sentinel节点选举" class="headerlink" title="领导者Sentinel节点选举"></a>领导者Sentinel节点选举</h3><p>当Sentinel节点对主节点完成了客观下线后，Sentinel节点之间还会选举出一个结点作为领导者进行故障转移工作；Redis使用了Raft算法实现领导者选举。</p><h4 id="Raft算法大致思路"><a href="#Raft算法大致思路" class="headerlink" title="Raft算法大致思路"></a>Raft算法大致思路</h4><ol><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线后，会向其他节点发送<code>sentinel is-master-down-by-addr</code>命令，要求将自己设置为领导者。</li><li>收到命令的Sentinel节点，如果没有同意过其他的Sentinel节点的<code>sentinel is-master-down-by-addr</code>命令，将同意该请求，反之拒绝。</li><li>如果该Sentinel节点发现自己的票数已经大于或等于max(quorum, num(sentinels) / 2 + 1)，那么它就成为领导者。</li><li>如果此过程没有选举出领导者，将进入下一次选举。</li><li>基本上谁先完成客观下线，谁就是领导者。</li></ol><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>领导者选举出的Sentinel将负责故障转移。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>从节点列表中选举出一个节点作为新的主节点。<ul><li>过滤掉不主观下线、掉线、5秒内没有回复Sentinel ping响应等等的节点…</li><li>选择从节点优先级最高的节点，如果存在则返回，不存在则继续下一步。</li><li>选择复制偏移量最大的从节点，如果存在则返回，不存在则继续下一步。</li><li>选择runid最小的从节点。</li></ul></li><li>对选举出的节点执行slave of no one，升级为主节点。</li><li>Sentinel领导者节点向其他节点发送命令，让它们成为新主节点的从节点。</li><li>Sentinel集合节点将原主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哨兵 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简析Redis复制原理</title>
      <link href="/2018/11/11/Redis-Replication/"/>
      <url>/2018/11/11/Redis-Replication/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中为了解决单点问题，通常会把数据复制成多个副本部署到不同的机器上，以满足负载均衡和故障恢复等需求，Redis也是如此，Redis支持简单且易用的<strong>主从复制（master-slave replication）</strong>功能。</p><a id="more"></a><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="https://i.loli.net/2018/11/11/5be8246daff44.png" alt=""></p><ol><li>slave执行slaveof命令，slave只保存master的地址信息后就返回。</li><li>slave通过内部每秒运行的定时任务维护复制相关的逻辑，当定时任务发现新的master信息时，开始尝试与master建立网络连接。如果无法建立连接，slave会一直无限次重连直到连接成功或者取消复制。</li><li>连接建立成功后slave会发送ping请求进行首次通信，检测主从之间网络套接字是否可用、检测msater当前是否可接受处理命令。</li><li>如果master设置了requirepass参数，则需要密码验证。</li><li>首次建立复制，主从节点会进行一次全量复制。</li><li>同步数据集成功后，master持续把后续的写命令发送给slave，保证主从一致性。</li></ol><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><h4 id="如何进行数据同步？"><a href="#如何进行数据同步？" class="headerlink" title="如何进行数据同步？"></a>如何进行数据同步？</h4><h5 id="复制偏移量（offset）"><a href="#复制偏移量（offset）" class="headerlink" title="复制偏移量（offset）"></a>复制偏移量（offset）</h5><p>参与主从复制的master和slave会保存各自的复制偏移量，slave的复制偏移量初始值为-1。master处理写入命令后，会对自己的复制偏移量进行累加；slave收到master发送的命令后，也会对自己的复制偏移量进行累加，并且slave每秒上报自身的复制偏移量给master，所以master也保存了slave的复制偏移量。倘若主从复制偏移量差距过大，则有可能是因为阻塞或网络延迟高造成的。</p><h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>复制积压缓冲区是保存在master上的一个固定长度的队列。当master处理写入命令后，不仅会把命令发送给slave，也会把命令写入复制积压缓冲区。复制积压缓冲区用于保存最近已复制数据，可用于部分复制或复制命令丢失的数据补救。</p><h5 id="主节点运行ID（runId）"><a href="#主节点运行ID（runId）" class="headerlink" title="主节点运行ID（runId）"></a>主节点运行ID（runId）</h5><p>每个Redis启动后会动态分配一个40位的十六进制的字符串作为运行ID，运行ID的主要作用是唯一识别Redis节点。如果master运行ID发生变化后，主从节点将进行全量复制。</p><h5 id="psync命令"><a href="#psync命令" class="headerlink" title="psync命令"></a>psync命令</h5><p>slave使用psync命令完成部分复制和全量复制功能，命令格式：psync {runId} {offset}。slave发送psync命令给master，master根据psync的参数和自身数据决定响应结果（全量复制、部分复制、错误）。</p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>全量复制是redis最早支持的复制方式，也是主从第一次建立后必须经历的阶段。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><img src="https://i.loli.net/2018/11/11/5be83c2112548.png" alt=""></p><ol><li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点运行ID，所以发送psync ? -1。</li><li>主节点根据psync解析当前为全量复制，回复+FULLRESYNC响应。</li><li>slave接收到master的响应数据，保存runId和offset。</li><li>master开始执行bgsave，保存RDB到本地。</li><li>master发送RDB文件给slave，slave接受到RDB文件后存储为自己的数据文件。（如果文件过大，存在超时全量复制失败的风险）。</li><li>从slave开始接受RDB到接受完成期间，master仍在处理读写命令。在这期间，master将写命令写入客户端缓冲区，当slave加载完RDB后，再把缓冲区内的数据发送给slave，保证主从之间数据一致性。</li><li>slave接受完master传送的数据后会清空自身旧数据。</li><li>slave清空数据后开始价值RDB文件，如果RDB文件过大，这个过程非常耗时。如果slave正处于全量复制阶段或者复制中断，那么slave响应读命令时可能拿到过期或错误的数据，数据出现不一致。（可以通过设置slave-serve-stable-data参数来关闭对读命令的响应）</li><li>slave加载完RDB后，如果slave开启了AOF持久化，它会立即执行bgrewriteaof操作，保证全量复制后AOF持久化文件立刻可用。</li></ol><h5 id="时间开销"><a href="#时间开销" class="headerlink" title="时间开销"></a>时间开销</h5><ol><li>master bgsave时间</li><li>RDB文件网络传输时间</li><li>salve清空数据时间</li><li>slave加载RDB时间</li><li>可能的AOF重写时间</li></ol><p>由此可见，全量复制的时间开销大，除此之外，全量复制过程中也会消耗大量的CPU、内存、网络资源。所以除了第一次复制采用全量复制，其余场景应该规避全量复制的发生。</p><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>部分复制主要是Redis针对全量复制过高开销作出的一种优化措施。当slave正在复制master时，如果出现网络闪断或者命令丢失等异常情况时，slave会向master要求补发丢失的命令数据，如果master的复制积压缓冲区内存在这部分数据则之间发给slave，这样可以确保主从节点复制的一致性。补发的这部分数据一般远远小于全量数据，所以开销很小。</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><p><img src="https://i.loli.net/2018/11/11/5be83a9d22ddf.png" alt=""></p><ol><li>主从节点之间网络出现中断时，如果超过repl-timeout时间，master会认为slave故障并中断复制连接。</li><li>主从连接中断期间master依然响应客户端的命令，但复制连接中断命令无法发送给slave，不过master内部存在复制积压缓冲区，可以保存最近一段时间的命令数据，默认最大缓存1MB。</li><li>主从节点网络恢复后，slave再次连上master。</li><li>主从连接恢复后，由于slave保存了自身已复制的偏移量和主节点的运行ID，此时将他们作为参数发送给master，要求进行部分复制。</li><li>master接到psync命令后进行核对，然后根据offset在自身复制积压缓冲区插座，如果数据存在于缓冲区，则对slave发送+CONTINUE响应，表示可以进行部分复制。</li><li>master根据offset把复制积压缓冲区里的数据发送给slave，保证主从复制进入正常状态。</li></ol><h4 id="异步复制（写命令同步）"><a href="#异步复制（写命令同步）" class="headerlink" title="异步复制（写命令同步）"></a>异步复制（写命令同步）</h4><p>master不仅负责数据读写，还负责把写命令同步给slave。写命令的发送是异步完成，master自身处理完写命令后直接返回给客户端，并不等待slave复制完成。由于主从复制过程是异步的，就会造成salve数据相对master存在延迟。</p><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>主从节点建立复制后，它们之间维护着长连接并彼此发送心跳命令。</p><h5 id="主从心跳判断机制"><a href="#主从心跳判断机制" class="headerlink" title="主从心跳判断机制"></a>主从心跳判断机制</h5><ol><li>主从节点各自都有心跳检测机制，各自模拟成对方的客户端进行通信。</li><li>master默认每隔10s对slave发送ping命令，判断slave的存活性和连接状态。</li><li>slave每隔1s对master发送replconf ack {offset}命令，给master上报自身当前的复制偏移量。replconf命令常用于检测主从节点网络状态、上报自身复制偏移量，检测复制数据是否丢失，如果slave数据丢失，再从master的复制缓冲区拉取丢失数据。、实现保证slave的数量和延迟性功能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单了解Redis中的持久化机制</title>
      <link href="/2018/11/09/Redis-Rersistence/"/>
      <url>/2018/11/09/Redis-Rersistence/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是持久化？为什么需要持久化？"><a href="#什么是持久化？为什么需要持久化？" class="headerlink" title="什么是持久化？为什么需要持久化？"></a>什么是持久化？为什么需要持久化？</h3><p>持久化就是将内存中的数据模型转换为存储模型，更通俗的说，就是将数据保存到系统硬盘中。</p><p>Redis所有的数据都是存在内存中，一旦程序崩溃或重启，内存中的数据就会丢失，所以我们需要持久化。</p><a id="more"></a><h3 id="RDB（默认开启）"><a href="#RDB（默认开启）" class="headerlink" title="RDB（默认开启）"></a>RDB（默认开启）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，适用于备份、全量复制等场景。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>执行bgsave命令，父进程判断当前是否有正在执行的子进程如AOF子进程，若有直接返回。</li><li>父进程执行fork操作创建子进程，fork操作会阻塞父进程。</li><li>fork完成后，父进程处理其他命令。</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对旧文件进行原子替换。</li><li>子进程发送信号通知父进程表示完成，父进程更新统计消息。</li></ol><p><img src="https://i.loli.net/2018/11/09/5be58cf902601.png" alt=""></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>RDB是一个非常紧凑的二进制文件，保存着Redis在某个时间节点上的数据集，非常适合备份、全量复制等场景。</li><li>RDB非常适用于灾难恢复，因为它只有一个文件并且非常紧凑，可以加密后传送到其他数据中心。</li><li>父进程保存RDB文件时仅仅需要花费fork一个子进程的时间，无需执行任何磁盘I/O操作。</li><li>Redis加载RDB恢复数据远远快于AOF的方式。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>因为RDB文件需要保存整个数据集的状态，花费数分钟的时间，所以一旦发生故障停机，可能会丢失数分钟的数据。</li><li>每次保存RDB时，Redis需要fork一个子进程，并由子进程进行数据持久化；如果数据集很庞大，fork()可能会非常耗时，造成服务器在短时间（毫秒级）内停止处理客户端；如果CPU比较紧张，fork过程可能长达整整一秒。</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>AOF持久化是以独立的日志记录每次写命令，Redis重启的时候执行AOF文件中的命令来恢复数据。</p><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><ol><li>所有写命令都会追加到AOF缓冲区。</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写以达到压缩的目的。</li></ol><p><img src="https://i.loli.net/2018/11/09/5be5935373f4f.png" alt=""></p><h5 id="AOF缓冲区同步文件策略"><a href="#AOF缓冲区同步文件策略" class="headerlink" title="AOF缓冲区同步文件策略"></a>AOF缓冲区同步文件策略</h5><p>可以配置Redis多久将数据同步到磁盘一次。</p><ul><li>always: 每次有写命令追加到AOF缓冲区时就调用系统fsync操作同步到AOF文件。</li><li>everysec：命令写入AOF缓冲区后调用系统write操作，fsync同步文件操作由专门线程每秒调用一次。</li><li>no：命令写入AOF缓冲区后调用系统write操作，不对AOF文件做fsync操作，同步硬盘由系统负责，通常同步周期为30s。</li></ul><h5 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h5><p>AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。（因为重写AOF文件时，Redis会合并多条写命令、丢弃超时的数据、删除无效命令，所以重写后的AOF文件要小于旧文件）</p><p><img src="https://i.loli.net/2018/11/09/5be5998076507.png" alt=""></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>使用AOF持久化使得Redis更加耐久，AOF缓冲区同步文件策略可以使得Redis就算发生故障停机，也最多丢失1s的数据（实际上最多为2s）。</li><li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，文件内容易懂且容易分析、导出。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>AOF文件的体积通常大于RDB文件的体积。</li><li>AOF的速度可能慢于RDB。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久化 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门之初级排序（选择、插入、希尔）</title>
      <link href="/2018/10/03/sort-1/"/>
      <url>/2018/10/03/sort-1/</url>
      
        <content type="html"><![CDATA[<p>下面是选择排序、插入排序、希尔排序等初级排序的简单介绍及实现。</p><a id="more"></a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>首先找到数组中最小的元素，将其与第一个元素置换位置。</li><li>从剩余的元素中找到最小的元素，将其与第二个元素置换位置。</li><li>以此类推，直到数组完全有序。</li></ol><p><strong>选择排序所需的时间取决于元素的数量</strong></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>第二个元素与左侧的元素进行比较，将其插入到合适的位置。</li><li>第三个元素与左侧的元素进行比较，将其插入到合适的位置。</li><li>以此类推，直到数组完全有序。</li></ol><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; a[j-<span class="number">1</span>]) &#123;</span><br><span class="line">          temp = a[j];</span><br><span class="line">          a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">          a[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序所需的时间取决于元素的初始顺序</strong></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是<strong>基于插入排序</strong>的快速排序，思想是使数组中<strong>任意间隔为h的元素是有序的。</strong></p><h4 id="步骤（序列1-2-3-k-1-）"><a href="#步骤（序列1-2-3-k-1-）" class="headerlink" title="步骤（序列1/2(3^k - 1)）"></a>步骤（序列1/2(3^k - 1)）</h4><ol><li>增幅h为数组长度的某个倍数（最小值为1），然后计算出增长序列(1, 4, 13, …)。</li><li>h = h(max)，确保间隔为h的元素有序。</li><li>h = h / 3，确保间隔为h的元素有序。</li><li>重复第3步，直至数组完全有序。</li></ol><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    System.out.print(h);</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</span><br><span class="line">      h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h; j -= h) &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[j - h] &gt; a[j]) &#123;</span><br><span class="line">            temp = a[j - h];</span><br><span class="line">            a[j - h] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>使用场景</th><th>时间复杂度</th><th>效率影响因素</th></tr></thead><tbody><tr><td>选择排序</td><td>小型数组</td><td>O(N^2)</td><td>数组大小</td></tr><tr><td>插入排序</td><td>小型数组，数组部分有序</td><td>O(N^2)</td><td>元素初始顺序</td></tr><tr><td>希尔排序</td><td>中小型数组，数组部分有序</td><td>O(N^3/2), O(N^4/3), O(N^6/5)…</td><td>元素初始顺序，增长序列</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Diff</title>
      <link href="/2018/09/23/react-diff/"/>
      <url>/2018/09/23/react-diff/</url>
      
        <content type="html"><![CDATA[<p>计算一棵树形结构转换成另一棵树形结构，传统的diff算法算法复杂度达到<strong>O(n^3)</strong>。React通过制定策略，将O(n^3)复杂度的问题转换成<strong>O(n)</strong>复杂度。</p><a id="more"></a><h4 id="Diff-策略"><a href="#Diff-策略" class="headerlink" title="Diff 策略"></a>Diff 策略</h4><ol><li>Web UI 中DOM节点跨层级的移动操作特别少，可以忽略不计。</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>对于同一层级的一组子节点，它们可以通过唯一id进行区分。</li></ol><h4 id="Tree-Diff"><a href="#Tree-Diff" class="headerlink" title="Tree Diff"></a>Tree Diff</h4><p>对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p><p>当节点跨层级移动时，并不会出现想象中的移动操作，而是进行create-delete操作（影响性能）。</p><h4 id="Component-Diff"><a href="#Component-Diff" class="headerlink" title="Component Diff"></a>Component Diff</h4><ol><li>如果是同类型的组件，按原策略继续比较Virtual DOM tree。</li><li>如果不是同类型的组件，则将组件判断为dirty component，从而替换整个组件下的所有子节点。</li><li>如果是同一类型的组件，并且Virtual DOM没有发生变化，那么将会省下大量的diff运算时间，因此React允许用户通过shouldComponentUpdate()来判断组件是否需要进行diff。</li></ol><h4 id="Element-Diff"><a href="#Element-Diff" class="headerlink" title="Element Diff"></a>Element Diff</h4><p>当节点处于同一层级时，React Diff提供了三种节点操作，分别为：INSERT_MARKUP、MOVE_EXISTING、REMOVE_NODE</p><ul><li>INSERT_MARKUP:  原集合不包含新的component类型，新节点需执行插入操作</li><li>MOVE_EXISTING:  原集合包含新的component类型，且element时可更新的类型，generateComponentChildren已调用receiveComponet，这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。</li><li>REMOVE_NODE:  老compone类型，在新集合也有，但对应的element不同则不能直接复用和更新，需执行删除操作，或者老component不在新集合中，也需要执行删除操作。</li></ul><p>允许开发者对同一层级的同组子节点添加唯一key作为标识。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JavaScript之Event Loop</title>
      <link href="/2018/06/27/event-loop/"/>
      <url>/2018/06/27/event-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近阅读《高性能JavaScript》时，第六章谈到“通过定时器将JavaScript执行代码的控制权先让给浏览器用于更新UI状态，然后再将控制权交回给JavaScript代码，这样就可以使得页面更为流畅”，就联想到了之前理解的事件循环。</p><p>这篇文章就是为了解释为什么这么做可以提升页面的流畅度。<br><a id="more"></a></p><h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643fed5a4908e8a?w=574&amp;h=430&amp;f=gif&amp;s=6755" alt="Internal.gif"></p><h3 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的JavaScript</h3><p>总所周知，JavaScript语言的一大特点就是<strong>单线程</strong>，也就是说在一个时间段里，JavaScript只能做一件事情（浏览器是多线程）。<br><strong>多线程可以实现应用的并行处理，从而以更高的CPU利用率提高整个应用程序的性能和吞吐量</strong>。</p><p><em>但是JavaScript却以单线程进行，为什么呢？</em></p><p>JavaScript是浏览器脚本语言，用于与用户交互以及操作DOM。<br>考虑如下情况，如果有两个并发的操作，对同一个DOM节点分别进行删除和修改样式，此时浏览器就无法决定到底采用哪个线程的操作。类似数据库，我们可以采用“锁”来处理并发，但是这会平添复杂度。所以，JavaScript语言没有支持多线程操作。<br>那又考虑这种情况，既然JavaScript是单线程，<strong>在某一时刻内只能执行特定的一个任务，并且会阻塞其它任务执行</strong>。那么如果用户触发了一个非常耗时的I/O操作，那么按道理后续的所有操作都得等到I/O操作完成后方可进行。但是，事实上，后续的任务不必等待这个耗时的I/O操作完成，原因就是JavaScript与生俱来的<strong>异步和回调</strong>。</p><p>而这背后恰好就是本文的主题——————<strong>事件循环</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事件循环包含了至少两个任务队列，<strong>宏任务</strong>队列和<strong>微任务</strong>队列。</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务包含创建文档对象、解析HTML、执行主线JavaScript代码、更改当前URL以及各种事件，例如页面加载、输入、网络事件和定时器等等。宏任务运行完成后，浏览器继续其他的任务调度，如重新渲染页面或者垃圾回收。</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务包括promise、回调函数、DOM发生变化等。微任务更新应用程序的状态，必须在浏览器任务继续执行其他任务（渲染UI视图或者进行下一个宏任务）之前执行。</p><h3 id="两个基本原则"><a href="#两个基本原则" class="headerlink" title="两个基本原则"></a>两个基本原则</h3><ol><li>一次处理一个任务</li><li>一个任务开始直到运行完成，不会被其他任务中断</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643fed5a7765dd2?w=872&amp;h=1088&amp;f=png&amp;s=191689" alt="EC06193617CCE1FF11A9C3C68CF8DDF3.png"><br>无论是宏任务队列还是微任务队列，二者在同一时刻都只执行一个任务，不过二者也有重要的区别：<strong>在一次循环中，最多处理一个宏任务，而微任务队列中所有的微任务都会被处理</strong>。</p><p>在微任务队列清空后，事件循环会检查当前是否需要重新渲染UI，如果需要则渲染UI视图。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol><li>两个任务队列都是独立于事件循环的，这意味着任务队列的添加发生在事件循环外。</li><li>所有微任务都会在下一次渲染前完成，目的是在渲染前更新应用程序状态。</li><li>浏览器会尝试以每秒渲染60次页面，以达到每秒60帧的速度。所以，一次循环最理想的时间应该不超过16ms。</li><li>浏览器完成页面渲染后，进入下一轮事件循环迭代后，可能出现3种情况<ol><li>如果事件循环执行到“is rendering needed”且浏览器处于另一个16ms结束之前（即浏览器尚未自动触发页面渲染时），浏览器可能不会选择在当前的时间循环中执行更新UI操作，因为更新UI是一个复杂且耗性能的操作。</li><li>如果事件循环执行到“is rendering needed”且浏览器刚好离上一次渲染16ms左右时（即浏览器即将自动触发页面渲染时），此时浏览器会进行UI更新。</li><li>执行下一个事件循环耗时超过16ms，浏览器将无法以目标帧率重新渲染页面，且UI无法被更新。如果延迟不大是很难察觉到，但是，如果有非常耗时的操作，这个时候用户会觉得网页十分卡顿，甚至浏览器会提示“无响应脚本”。</li></ol></li></ol><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>现在，用事件循环和简单的例子来分析《高性能的JavaScript》中的那句话。<br>需求：给包含1000个数字的数组中的每个元素取绝对值（假设对一个数字进行需求操作耗时1ms）。</p><p>情况1（不使用定时器）:<br>由于JavaScript主线程代码属于宏任务的一种，所以一次事件循环需要处理1000个数字，所以1s事件循环才进行到UI更新阶段，但是由于耗时过长，UI状态不会被更新，页面出现卡顿甚至堵塞。</p><p>情况2（使用定时器）：<br>将一次处理1000个数字的任务分割为20个每次处理50个数字的任务。由于定时器是宏任务的一种，所以一次事件循环只处理50个数字，由于此时微任务队列为空，所以50ms后事件循环进行到UI更新阶段，然后根据情况进行UI渲染，页面未出现卡顿或者堵塞。</p><p>当然，如果只是单纯的处理数据，我们可以考虑使用<strong>Web Workers</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>JavaScript是单线程的，同一时刻是只能执行一个任务。</li><li>事件循环包含一个宏任务队列和至少一个微任务队列。事件循环一次迭代，至多执行一个宏任务但是会执行完所有的微任务。</li><li>Web应用越复杂，积极主动管理UI线程就越重要，即使JavaScript代码很重要，也不能影响用户体验。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/4183808/" target="_blank" rel="noopener">《High Performance JavaScript》</a></li><li><a href="https://book.douban.com/subject/3176860/" target="_blank" rel="noopener">《Secrets of the JavaScript Ninja》</a></li><li><a href="https://www.w3.org/TR/html52/webappapis.html#event-loops-definitions" target="_blank" rel="noopener">《HTML 5.2》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次面试经历</title>
      <link href="/2018/05/24/my-first-interview/"/>
      <url>/2018/05/24/my-first-interview/</url>
      
        <content type="html"><![CDATA[<p>第一次投简历面试……<br><a id="more"></a></p><h2 id="腾讯MIG事业群-云安全部（5-21）"><a href="#腾讯MIG事业群-云安全部（5-21）" class="headerlink" title="腾讯MIG事业群 云安全部（5.21）"></a>腾讯MIG事业群 云安全部（5.21）</h2><p>第一次技术面试，比较紧张，面试过程20多分钟，最后问了面试官鹅厂前端生态和部门技术栈，下面是面试内容：</p><ol><li>介绍一下自己，最近在看什么书，如何学习前端的。</li><li>CSS如何实现垂直居中、水平居中</li><li>对CSS3了解程度，用过哪些特性</li><li>HTTP状态码、Web缓存</li><li>跨域</li><li>介绍一下XSS和CSRF，如何避免</li><li>JavaScript中的异步编程</li><li>MVVM的原理</li><li>说说你的项目，讲讲收获大的地方。</li></ol><p>5.17就接到了腾讯面试官的电话，问了我一些基本情况，看了我的github和博客，后面也加了微信，给了我一些很好的建议，人非常nice。（严格来说，这是第一次面试）</p><h2 id="百度前端技术部（5-23）"><a href="#百度前端技术部（5-23）" class="headerlink" title="百度前端技术部（5.23）"></a>百度前端技术部（5.23）</h2><p>这次面试也是一位小姐姐官，一开始比较紧张，后面就好多了，面试过程50分钟。在第一个问题中，面试官认为我的方法不可行（filter + indexOf），后来被认可了。因为没问我JavaScript我觉得重要的概念（原型、闭包、事件循环等）比较惊讶，然后面试官让我介绍（虽然答上了，但是下次再也不主动给自己加题了🤦️），最后我问了问她们部门的业务和生态。下面是面试内容：</p><ol><li>数组去重</li><li>如何实现图片充满盒子</li><li>如何实现CSS垂直居中</li><li>CSS3的新特性</li><li>Flex布局</li><li>HTTP状态码</li><li>Web缓存</li><li>性能优化</li><li>事件流</li><li>用过的ES6特性</li><li>谈谈项目中比较难的地方</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>腾讯和百度两次面试都是很好的体验，因为才大二，所以没有做面试的准备，抱着试一试的心态投递了简历，面试过程中也发现自己的一些不足，大神们的建议会仔细听取的。最后也拿到了实习offer，Keep hungry, keep foolish.</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Nginx二级域名并部署hexo博客</title>
      <link href="/2018/05/09/how-to-deploy-a-static-website/"/>
      <url>/2018/05/09/how-to-deploy-a-static-website/</url>
      
        <content type="html"><![CDATA[<p>因为有不同的项目需要部署，所以我打算为每个项目分配一个二级域名。下面是整个流程的复盘:<br><a id="more"></a></p><h3 id="安装nginx和git"><a href="#安装nginx和git" class="headerlink" title="安装nginx和git"></a>安装nginx和git</h3><p><code>yum -y install nginx git</code></p><h3 id="获取资源文件"><a href="#获取资源文件" class="headerlink" title="获取资源文件"></a>获取资源文件</h3><ol><li>新建 <code>/var/www/blog</code> 目录：<code>mkidr /var/www/blog</code></li><li>切换到blog目录下并获取文件： <code>cd /var/www/blog &amp;&amp; git clone git@github.com:GeniusFunny/GeniusFunny.github.io.git</code>, 此时blog目录下有一个GeniusFunny.github.io文件夹，这就是我的hexo资源文件夹，配置.conf文件时会用到。</li></ol><h3 id="DNS添加二级域名"><a href="#DNS添加二级域名" class="headerlink" title="DNS添加二级域名"></a>DNS添加二级域名</h3><p>前往你购买的服务器商（我购买的是腾讯云的服务）为在域名解析中添加解析记录，如图所示：<br><a href="https://i.loli.net/2018/05/16/5afb7dc3b68dc.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc3b68dc.png" alt="nginx-subadmin.png"></a><br>点击添加记录，在主机记录添加你要的域名（如blog），在记录值处填写服务器的ip地址。那么就有一个新的域名，如:<a href="blog.geniusfunny.xyz">blog.geniusfunny.xyz</a>。<br>添加完成后，我们就开始配置我们的nginx。</p><h3 id="nginx配置二级域名并部署"><a href="#nginx配置二级域名并部署" class="headerlink" title="nginx配置二级域名并部署"></a>nginx配置二级域名并部署</h3><ol><li>进入nginx默认配置文件<code>vim /etc/nginx/nginx.conf</code></li><li>在http模块中添加一行代码（引入sites-enabled文件夹）：<code>include    /etc/nginx/sites-enabled/*;</code></li><li>在当前目录下，新建一个sites-enabled文件夹：<code>mkdir sites-enabled</code></li><li>进入sites-enabled文件夹，添加以二级域名（blog.geniusfunny.xyz）为名称的配置文件: <code>vim blog.geniusfunny.xyz</code></li><li>配置二级域名配置文件如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.geniusfunny.xyz;</span><br><span class="line">    root /var/www/blog/GeniusFunny.github.io;   //这是我们的资源文件目录</span><br><span class="line">    index index.html index.htm index.nginx-debian.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置快捷linux命令"><a href="#配置快捷linux命令" class="headerlink" title="配置快捷linux命令"></a>配置快捷linux命令</h3><ol><li>进入.bashrc文件，<code>vim ~/.bashrc</code></li><li>添加快捷linux自定义命令，<code>alias myBlog=&#39;cd /var/www/blog/GeniusFunny.github.io</code>, 保存</li><li>使.bashrc文件生效，<code>source ~/.bashrc</code></li><li>以后我们就可以在根目录下输入<code>myBlog</code>进入资源文件夹目录，然后<code>git pull</code>，获取最新的资源</li></ol><h3 id="常用的关于nginx的命令"><a href="#常用的关于nginx的命令" class="headerlink" title="常用的关于nginx的命令"></a>常用的关于nginx的命令</h3><p>检查nginx配置：<code>nginx -t nginx.conf</code><br>开启nginx服务：<code>nginx</code><br>关闭nginx服务：<code>nginx -s stop</code><br>强制关闭nginx服务：<code>pkill -9 nginx</code><br>重启nginx服务：<code>nginx -s reload</code></p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一行url到一个页面我们经历了什么？(更新中)</title>
      <link href="/2018/05/03/web-life-cycle/"/>
      <url>/2018/05/03/web-life-cycle/</url>
      
        <content type="html"><![CDATA[<p><strong>当我们在浏览器地址栏输入一行url，整个页面呈现，整个过程发生了什么？我大致把整个过程分为两个部分，即网络行为与页面周期。<br>浏览器缓存 —&gt; DNS  —&gt; TCP连接 –&gt; HTTP请求/响应 —&gt; 构建页面 —&gt; 事件处理</strong><br><a id="more"></a></p><h2 id="网络行为"><a href="#网络行为" class="headerlink" title="网络行为"></a>网络行为</h2><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><p>浏览器和服务器是应答模式，即：浏览器发起HTTP请求 —&gt; 服务器返回响应。如果是第一次发起请求，浏览器会根据拿到的HTTP响应头的配置来决定是否缓存此次的响应结果。过程如下：<br><a href="https://i.loli.net/2018/05/16/5afb7dc040b2d.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc040b2d.png" alt="第一次HTTP请求.png"></a><br><strong>1. 浏览器每次发起HTTP请求时，都会根据请求去浏览器缓存中匹配对应的请求结果和缓存标识。</strong><br><strong>2. 浏览器每次成功获取到请求结果，都会将请求结果和缓存标识存入浏览器缓存。</strong><br>根据浏览器是否需要向服务器重新发起HTTP请求，将缓存过程分为了两部分：<strong>强制缓存</strong>与<strong>协商缓存</strong></p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>强制缓存就是向浏览器缓存查找对应的请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</p><h5 id="场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求"><a href="#场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求" class="headerlink" title="场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求"></a>场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求</h5><p>如果浏览器缓存中不存在对应的缓存结果和缓存标识，那么浏览器会重新向服务器发起HTTP请求。<br><a href="https://i.loli.net/2018/05/16/5afb7dbfec6d6.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dbfec6d6.png" alt="ForcingCache-1.png"></a></p><h5 id="场景二：-存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存"><a href="#场景二：-存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存" class="headerlink" title="场景二： 存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存"></a>场景二： 存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存</h5><p>如果浏览器缓存中存在对应的缓存结果和缓存标识，但缓存已经失效（过期），那么浏览器会采用协商缓存。<br><a href="https://i.loli.net/2018/05/16/5afb7dc1aa00b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc1aa00b.png" alt="ForcingCache-2.png"></a></p><h5 id="场景三：-存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果"><a href="#场景三：-存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果" class="headerlink" title="场景三： 存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果"></a>场景三： 存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果</h5><p>如果浏览器缓存中存在对应的缓存结果和缓存标识且缓存尚未失效，那么浏览器缓存直接返回缓存结果。<br><a href="https://i.loli.net/2018/05/16/5afb7dc072ebb.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc072ebb.png" alt="ForcingCache-3.png"></a></p><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><p>强制缓存与HTTP响应头中的字段<strong>Cache-Control</strong>和<strong>Expires</strong>有关，Cache-Control优先于Expires。<br><strong>Cache-Control</strong>: HTTP/1.1，主要取值如下：</p><ol><li>public: 响应可以被任何缓存区（客户端、代理服务器）缓存</li><li>private: 响应只可以被客户端缓存（Cache-Control默认值）</li><li>no-cache: 可以存储在本地缓存中，但需要与服务器进行验证后方可使用</li><li>no-store: 禁止缓存对响应进行复制</li><li>max-age=xxx: 缓存将在xxx秒后过期<br><strong>Expires</strong>: HTTP/1.0, 附加一个Expires日期首部到响应中去,这个日期为绝对日期，例如：Expires: Fri, 05 Jul 2002, 05:00:00 GMT   </li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>协商缓存就是在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><h5 id="场景一：-协商缓存生效，返回304"><a href="#场景一：-协商缓存生效，返回304" class="headerlink" title="场景一： 协商缓存生效，返回304"></a>场景一： 协商缓存生效，返回304</h5><p>如果服务器提示资源尚未失效，则返回304，浏览器可继续使用浏览器缓存中该资源的缓存结果。<br><a href="https://i.loli.net/2018/05/16/5afb7dbfec715.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dbfec715.png" alt="consult-cache-1.png"></a></p><h5 id="场景二：-协商缓存失效，返回200"><a href="#场景二：-协商缓存失效，返回200" class="headerlink" title="场景二： 协商缓存失效，返回200"></a>场景二： 协商缓存失效，返回200</h5><p>如果服务器提示资源尚已失效，则返回200，服务器重新返回最新的资源，浏览器将缓存结果和缓存标识存入浏览器缓存。<br><a href="https://i.loli.net/2018/05/16/5afb7dc145822.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc145822.png" alt="consult-cache-2.png"></a></p><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><p><em>HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象的主体。—- 《HTTP权威指南》</em><br>协商缓存与HTTP头中的字段<strong>Last-Modified / If-Modified-Since（请求头）</strong>和<strong>Etag / If-None-Match(请求头)</strong>有关，Etag / If-None-Match优先级比Last-Modified / If-Modified-Since高。<br><strong>Last-Modified / If-Modified-Since</strong>:<br><strong>If-Modified-Since:Date再验证请求</strong>通常被称为IMS请求，只有某个日期之后资源发生了改变，IMS请求才会指示服务器执行请求：<br>1.如果自指定日期后，资源更新了，If-Modified-Since条件就为真，通常GET就会执行，携带新首部（除了其他信息还有一个新的过期日期）的新资源就会返回给缓存。<br>2.如果自指定日期后，资源未更新，If-Modified-Since条件就为假，就会向客户端返回一个小的304 Not Modified 响应报文，为了提高有效性，报文中不会包含资源的主体。<br>例：If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT<br><strong>Etag / If-None-Match 实体标签再验证</strong>:<br>有些情况（周期性地重写、资源修改无影响的部分、有些服务器无法准确判断其页面的最后修改时间等等）下仅根据修改日期进行再验证是不够的，HTTP允许用户对被称为<em>实体标签（Etag）</em>的“版本标识符”进行比较。当发布者对资源进行修改时，就可以修改资源的实体标签来说明这是一个新版本。<br>1.如果实体标签仍匹配，If-None-Match再验证成功，返回304 Not Modified。<br>2.如果服务器上的实体标签已经发生了变化，服务器会在一个200 OK 响应中返回新的内容及相应的新Etag。<br>例：<br>If-None-Match: “v2.6”<br>If-None-Match: “v2.4”, “v2.5”</p><h4 id="浏览器的缓存放在哪里？"><a href="#浏览器的缓存放在哪里？" class="headerlink" title="浏览器的缓存放在哪里？"></a>浏览器的缓存放在哪里？</h4><p>浏览器的缓存通常存放入硬盘（from disk cache）或内存（from memory cache）。</p><h5 id="from-disk-cache"><a href="#from-disk-cache" class="headerlink" title="from disk cache"></a>from disk cache</h5><p>硬盘缓存(from disk cache)则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p><h5 id="from-memory-cache"><a href="#from-memory-cache" class="headerlink" title="from memory cache"></a>from memory cache</h5><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是<strong>快速读取</strong>和<strong>时效性</strong>：<br><strong>快速读取</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。<br><strong>时效性</strong>：一旦该进程关闭，则该进程的内存则会清空。</p><h5 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h5><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h4 id="缓存有什么优点？"><a href="#缓存有什么优点？" class="headerlink" title="缓存有什么优点？"></a>缓存有什么优点？</h4><ol><li>减少了数据的冗余传输</li><li>缓解了网络的带宽瓶颈问题</li><li>减轻了服务器的负担</li><li>减轻了距离时延</li></ol><h4 id="缓存与cookie"><a href="#缓存与cookie" class="headerlink" title="缓存与cookie"></a>缓存与cookie</h4><p>缓存那些与cookie事务有关的文档时要特别小心，cookie和缓存的规则没有很好地建立起来。下面是处理缓存时的一些指导性规则：</p><ol><li>如果无法缓存文档，要将其表示出来。<br>如对不可缓存的文档设置：<strong>Cache-Control:no-cache=”Set-Cookie”</strong>，对可缓存的文档设置： Cache-Control:public。</li><li>缓存Set-Cookie首部要小心。<br>如果向多个用户发送了相同的Set-Cookie首部可能会破坏用户的定位；有些缓存会在将响应缓存起来之前删除Set-Cookie首部，那么请求缓存的时候客户端就拿不到cookie了。<br>强制缓存与原始服务器重新验证每条请求，并将Set-Cookie首部合并到客户端的响应中去，就可以改善这种情况，原始服务器可向缓存副本添加这个首部来进行这种验证：Cache-Control: must-revalidate, max-age=0</li><li>小心处理带有cookie首部的请求<br>带有cookie的请求结果到达时，就是提示我们，这个请求结果可能是私有内容，必须将私有内容标识为不可缓存。</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>DNS（<strong>Domain Name System，域名解析系统</strong>）的作用是将主机名（hostname）解析为对应的IP地址。DNS是一个由<strong>分层</strong>的DNS服务器实现的分布式数据库，一个使得主机能够查询分布式数据库的<strong>应用层协议</strong>。DNS协议运行在UDP上，使用53号端口。</p><h4 id="常规流程"><a href="#常规流程" class="headerlink" title="常规流程"></a>常规流程</h4><ol><li>浏览器从URL中抽出主机名，将其发送给运行中的DNS应用客户端。</li><li>DNS客户端向DNS服务器发送一个带有主机名的请求。</li><li>DNS客户端会收到来自DNS服务器的回答报文，其中包含了与主机名对应的IP地址。</li><li>浏览器获取到IP地址，向位于该地址的服务器进程的某个端口（HTTP为80端口，HTTPS为443端口）发起一个TCP连接。</li></ol><h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><p>DNS服务器层次结构中的DNS服务器大致有三种，<em>根DNS服务器</em>、<em>顶级域DNS服务器</em>、<em>权威DNS服务器</em>。根DNS服务器—&gt;顶级域DNS服务器—&gt;权威DNS服务器（自顶向下）。<br>如果要查询www.baidu.com对应的IP地址，查询过程大致如下（分级查询）：</p><ol><li>首先跟根服务器之一联系，获得顶级域名com的TLD服务器的IP地址。</li><li>然后TLD服务器之一联系，获得baidu.com权威服务器的IP地址。</li><li>最后与baidu.com权威服务器之一联系，获得主机名www.baidu.com对应的IP地址。</li></ol><p>除此之外，还有一类DNS服务器很重要，即：本地DNS服务器（尽管它不在DNS服务器层次结构中）。每个ISP都有一个本地DNS服务器，当主机与该ISP连接时，ISP会返回一个IP地址，该地址具有一台或多台的本地DNS服务器的IP地址。<strong>当主机发起DNS请求时，请求被发送到本地DNS服务器，它起着代理和将请求转发到DNS服务器层次结构中（类似HTTP的代理服务器）</strong>。<br><a href="https://i.loli.net/2018/05/16/5afb92dfa36da.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb92dfa36da.png" alt="DNS查询（一）.png"></a><br>从请求主机到本地DNS服务器的查询是<strong>递归查询</strong>（因为查询请求是以自己的名义，查询结果直接返回给请求主机），其余为<strong>迭代查询</strong>（查询请求是以本地DNS服务器为名义，返回的结果也是给本地DNS服务器）</p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>为了改善实验性能并减少在因特网上到处传播的DNS报文数量，DNS广泛使用了缓存技术。<strong>在一个请求链中，当某个DNS服务器接收到一个DNS回答时，它能将该信息缓存在本地存储器中</strong>（例如，共用一个ISP的小明、小红，如果小明查询了www.baidu.com的IP地址，那么这个IP地址就存在了本地DNS服务器中，在缓存失效前，小红可以直接在本地DNS服务器中获取到www.baidu.com的IP地址）。本地服务器能够缓存顶级域服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>一个TCP连接是由一对端点或套接字构成，其中通信的每一端都由一对（IP地址，端口号）所唯一标识。<br>一个TCP连接通常分为三个阶段：启动（三次握手）、数据传输、退出（四次挥手）。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><p><a href="https://i.loli.net/2018/05/16/5afb7dc3ce2c6.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc3ce2c6.png" alt="three-shake.png"></a><br>如图所示，客户端中的TCP会用一下方式与服务器中TCP建立一条TCP连接：</p><ol><li>第一步，客户端的TCP首先向服务器的TCP发送一个特殊的TCP报文段，该报文段不包含应用层的数据，但是在报文段的首部中的一个标志位（即SYN比特）被置为1，因此这个特殊报文段被称为<strong>SYN报文段</strong>。客户端会随机选择一个初始序号（J）并将此序号放置于该起始的TCP SYN报文段的序号字段里，整个报文字段会封装在一个IP数据报中并发给服务器。此时，客户端进入<strong>SYN-SENT状态</strong>。</li><li>第二步，一旦包含TCP SYN报文段的IP数据报到达了服务器，服务器就会从数据报中提取出TCP SYN报文段，为该TCP连接分配缓存和变量，并向客户端发送允许连接的报文段（ACK(J + 1)），该报文段也不包含应用层数据。与此同时服务器也随机选择一个初始序号（K）并将此序号放置于TCP报文段首部的序号字段中，即（SYN(K)）,随确认字段ACK一并发送给客户端。此报文字段通常被称为<strong>SYNACK报文段</strong>，此时服务器进入<strong>SYN-RECEIVED状态</strong>。</li><li>第三步，客户端接收到<strong>SYNACK报文段</strong>，为该连接分配缓存和变量，此时客户端进入<strong>ESTABLISHED状态</strong>。客户端向服务器发送另外一个报文段，这个报文段是对服务器的允许连接的报文段的确认（ACK(K + 1)），与前两次不同，这次报文段中可携带应用层数据，由于连接已经建立，SYN比特被置为0。服务器收到这个报文段后，也进入<strong>ESTABISHED状态</strong>。<br>完成这三个步骤后，客户端和服务器的每一个报文段中都可以携带应用层的数据，且SYN比特都将被置为0。建立TCP连接的三个步骤也被称为TCP<strong>三次握手</strong>。<br><em>三次握手的目的不仅在于让通信双方了解一个连接正在建立， 还在于利用数据包的选项来承载特殊的信息，交换初始序列号。——-《TCP/IP 详解 卷一：协议》</em></li></ol><h5 id="为什么是三次握手？为什么不是两次握手？"><a href="#为什么是三次握手？为什么不是两次握手？" class="headerlink" title="为什么是三次握手？为什么不是两次握手？"></a>为什么是三次握手？为什么不是两次握手？</h5><p>三次握手：<br>A—-&gt;B: [A: I’m A.]<br>B—-&gt;A: [B: Hello A, I’m B.]<br>A—-&gt;B: [A: Hello B, nice to meet you.]<br>然后愉快的py</p><p>二次握手：<br>A—-&gt;B: [I’m A.]<br>B—-&gt;A: [Hello A, I’m B.]<br>如果A收到了“Hello A,I’m B”，愉快的py<br>如果A没有收到“Hello A,I’m B”，那么while(true){ A—-&gt;B: [I’m A.] }, 疯狂握手<br>三次握手的目的是确认A—&gt;B, B—&gt;A这两个信道都是可靠的；如果只有两次握手就无法确认B—&gt;A的信道是否可靠。如果只需要A—&gt;B信道可靠，那就类似于UDP的需求了。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h5 id="概览-2"><a href="#概览-2" class="headerlink" title="概览"></a>概览</h5><p>连接的任何一方都可以发起关闭连接，在传统情况下往往由客户端来发起关闭连接，如下图所示。<br><a href="https://i.loli.net/2018/05/16/5afb7dc3b7ef7.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/05/16/5afb7dc3b7ef7.png" alt="four-wave.png"></a></p><ol><li>第一步：客户端发送FIN包（包含了客户端的序列号M)，此外FIN包还包含了一个ACK段用于确认对方最后一次发送的数据。</li><li>第二步：服务器收到客户端发送的FIN包后，将M值+1作为响应的ACK值，表明它已经成功接收到来自客户端发送的FIN。此时，处于上层的应用程序会被告知连接的另一方发起了关闭连接的请求，这将导致应用程序发动自己的关闭操作。服务器从被动关闭者变为主动关闭者，向客户端发送FIN(包含了服务器的序列号N)。</li><li>第三步：为了完成连接的关闭，客户端发往服务器最后的报文段中包含了一个确认服务器发送的FIN的ACK字段。</li></ol><h5 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h5><p>四次挥手：<br>A —&gt; B, [A: ‘我想关闭连接’]<br>B —&gt; A, [B: ‘好的，我知道了，我不要收到你的东西了’]<br>B —&gt; A, [B: ‘我想关闭连接’]<br>A —&gt; B, [A: ‘好的，我知道了，我也不要收到你的东西了’]<br>主动方发送关闭请求，被动方接受并确认请求后，被动方就无法收到主动方发送的数据了。在前两次挥手后，服务器就无法收到客户端发送的数据了（服务器释放了关于客户端的资源），但是服务器可以给客户端发送数据，所以有了第三次、第四次挥手。</p><h2 id="页面周期概览"><a href="#页面周期概览" class="headerlink" title="页面周期概览"></a>页面周期概览</h2><h3 id="页面构建"><a href="#页面构建" class="headerlink" title="页面构建"></a>页面构建</h3><h4 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h4><h4 id="Style-Rules"><a href="#Style-Rules" class="headerlink" title="Style Rules"></a>Style Rules</h4><h4 id="Rendering-Tree"><a href="#Rendering-Tree" class="headerlink" title="Rendering Tree"></a>Rendering Tree</h4><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li><li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解TCP三次握手与四次分手</a></li><li><a href="https://item.jd.com/11056556.html" target="_blank" rel="noopener">《HTTP权威指南》</a></li><li><a href="https://item.jd.com/12306772.html" target="_blank" rel="noopener">《JavaScript忍者秘籍》</a></li><li><a href="https://item.jd.com/11556873.html" target="_blank" rel="noopener">《计算机网络（自顶向下方法）》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web缓存 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停止书写回调函数并爱上ES8</title>
      <link href="/2018/04/14/async-await/"/>
      <url>/2018/04/14/async-await/</url>
      
        <content type="html"><![CDATA[<h2 id="停止书写回调函数并爱上ES8"><a href="#停止书写回调函数并爱上ES8" class="headerlink" title="停止书写回调函数并爱上ES8"></a>停止书写回调函数并爱上ES8</h2><p>以前，JavaScript项目会逐渐‘失去控制’，其中主要一个原因就是采用传统的回调函数处理异步任务时，一旦业务逻辑比较复杂，我们就难免书写一些冗长、复杂、嵌套的代码块（<em>回调地狱</em>），这会严重降低代码的可读性与可维护性。现在，JavaScript提供了一种新的语法糖来取代回调函数，使我们能够编写简明、可读性高的异步代码。<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>先来回顾一下历史。在20世纪90年代后期，Ajax是异步JavaScript的第一个重大突破。这一技术允许网站在加载HTML后获取并显示最新的数据，这是一个革命性的想法。在这之前，大多数网站会再次下载整个页面来显示更新的内容。这一技术(在jQuery中以ajax的名称流行)主导了2000-2010的web开发并且Ajax是目前网站用来获取数据的主要技术，但是XML在很大程度上取代了JSON。</p><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><p>当NodeJS在2009年首次发布时，服务器端环境的主要焦点是允许程序优雅地处理并发性。大多数服务器端语言通过阻塞代码来处理I/O操作，直到操作完成为止。相反，NodeJS使用的是事件循环机制，这样开发人员可以在非阻塞异步操作完成后，调用回调函数来处理逻辑（类似于Ajax的工作方式）。</p><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>几年后，NodeJS和浏览器环境中出现了一种新的标准，称为”Promise”，Promise提供了一种强大的、标准化的方式来组成异步操作。Promise仍然使用基于回调的格式，但为链式和组合异步操作提供了一致的语法。在2015年，由流行的开源库所倡导的Promise最终被添加为JavaScript的原生特性。<br>Promise是一个不错的改进，但它们仍然常常是一些冗长而难以阅读的代码块的原因。<br>而现在有了一个解决方案。<br>Async/Await是一种新的语法(从.net和C#中借用)，它允许我们编写Promise，但它们看起来像是同步代码，没有回调，可以用来简化几乎任何现有的JS应用程序。Async/Await是JavaScript语言的新增的特性，在ES7中被正式添加为JavaScript的原生特性。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们将通过一些代码示例来展示Async/Await的魅力</p><p><em>*注</em>：运行下面的示例不需要任何库。Async/Await已经被最新版本的Chrome、FireFox、Safari、Edge完全支持，你可以在你的浏览器控制台里运行例子。Async/Await需要运行在NodeJS 7.6版本及以上，同时也被Babel、TypeScript转译器支持。所以Async/Await可以被用于实际开发之中。*</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>我们会使用一个虚拟的API类，你也可以在你的电脑上运行。这个类通过返回promise来模拟异步请求。正常情况下，promise被调用后，200ms后会对数据进行处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.user = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'test'</span> &#125;</span><br><span class="line">    <span class="keyword">this</span>.friends = [ <span class="keyword">this</span>.user, <span class="keyword">this</span>.user, <span class="keyword">this</span>.user ]</span><br><span class="line">    <span class="keyword">this</span>.photo = <span class="string">'not a real photo'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getUser () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="keyword">this</span>.user), <span class="number">200</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFriends (userId) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="keyword">this</span>.friends.slice()), <span class="number">200</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPhoto (userId) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="keyword">this</span>.photo), <span class="number">200</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  throwError () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Intentional Error'</span>)), <span class="number">200</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个示例依次执行如下三个操作： 获取一个用户的信息，获取该用户的朋友， 获取该用户的照片。在最后，我们会在控制台中打印这些结果。</p><h4 id="方法一-—-Nested-Promise-Callback-Functions"><a href="#方法一-—-Nested-Promise-Callback-Functions" class="headerlink" title="方法一 — Nested Promise Callback Functions"></a>方法一 — Nested Promise Callback Functions</h4><p>使用嵌套的promise回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackHell</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">let</span> user, friends</span><br><span class="line">  api.getUser().then(<span class="function"><span class="keyword">function</span> (<span class="params">returnedUser</span>) </span>&#123;</span><br><span class="line">    user = returnedUser</span><br><span class="line">    api.getFriends(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">returnedFriends</span>) </span>&#123;</span><br><span class="line">      friends = returnedFriends</span><br><span class="line">      api.getPhoto(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">photo</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'callbackHell'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于任何一个从事过JavaScript项目开发的人来说，这个代码块非常熟悉。非常简单的业务逻辑，但是代码却是冗长、深嵌套，并且以这个结尾…..<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在真实的业务场景中，每个回调函数可能更复杂，代码块会以一堆充满层次感的<code>})</code>为结尾。“回调函数里面嵌套着回调函数嵌套着回调函数”，这就是被传说中的“回调地狱”（“回调地狱”的诞生不只是因为代码块的混乱，也源于信任问题。）。<br>更糟糕的是，我们为了简化，还没有做错误处理机制，如果加上了reject……细思极恐</p><h4 id="方法二-—-Promise-Chain"><a href="#方法二-—-Promise-Chain" class="headerlink" title="方法二 — Promise Chain"></a>方法二 — Promise Chain</h4><p>让我们优雅起来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseChain</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">let</span> user, friends</span><br><span class="line">  api.getUser()</span><br><span class="line">    .then(<span class="function">(<span class="params">returnedUser</span>) =&gt;</span> &#123;</span><br><span class="line">      user = returnedUser</span><br><span class="line">      <span class="keyword">return</span> api.getFriends(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">returnedFriends</span>) =&gt;</span> &#123;</span><br><span class="line">      friends = returnedFriends</span><br><span class="line">      <span class="keyword">return</span> api.getPhoto(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">photo</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promiseChain'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Promise有一个很棒的特性：Promise.prototype.then()和Promise.prototype.catch()返回Promise对象，这就使得我们可以将这些promise连接成一个promise链。通过这种方法，我们可以将这些回调函数放在一个缩进层次里。与此同时，我们使用了箭头函数简化了回调函数声明。<br>对比之前的回调地狱，使用promise链使得代码的可读性大大提高并且拥有着更好的序列感，但是看起来还是非常冗长并且有一点复杂。</p><h4 id="方法三-—-Async-Await"><a href="#方法三-—-Async-Await" class="headerlink" title="方法三 — Async/Await"></a>方法三 — Async/Await</h4><p>我们可不可以不写回调函数？就写7行代码能解决吗？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitIsYourNewBestFriend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> api.getUser()</span><br><span class="line">  <span class="keyword">const</span> friends = <span class="keyword">await</span> api.getFriends(user.id)</span><br><span class="line">  <span class="keyword">const</span> photo = <span class="keyword">await</span> api.getPhoto(user.id)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'asyncAwaitIsYourNewBestFriend'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优雅多了，调用await之前我们会一直等待，直到promise被决议并将值赋值给左边的变量。通过async/await，我们可以对异步操作流程进行控制，就好像它是同步代码。</p><p><strong>注：await必须搭配async一起使用，注意上面的函数，我们将关键字async放在了函数的声明前，这是必需的。稍后，我们会深入讨论这个问题</strong></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Async/Await可以让以前很多复杂的代码变得简明。举个例子，如果我们要按序检索每个用户的朋友的朋友列表。</p><h4 id="方法一-—-Recursive-Promise-Loop"><a href="#方法一-—-Recursive-Promise-Loop" class="headerlink" title="方法一 — Recursive Promise Loop"></a>方法一 — Recursive Promise Loop</h4><p>下面是使用传统的promise来按序获取每个朋友的朋友列表<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseLoops</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  api.getUser()</span><br><span class="line">    .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> api.getFriends(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">returnedFriends</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> getFriendsOfFriends = <span class="function">(<span class="params">friends</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (friends.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> friend = friends.pop()</span><br><span class="line">          <span class="keyword">return</span> api.getFriends(friend.id)</span><br><span class="line">            .then(<span class="function">(<span class="params">moreFriends</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'promiseLoops'</span>, moreFriends)</span><br><span class="line">              <span class="keyword">return</span> getFriendsOfFriends(friends)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> getFriendsOfFriends(returnedFriends)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们创建在promiseLoops中创建了一个函数用于递归地去获取朋友的朋友列表。这个函数体现了函数式编程，但是对于这个简单的任务而言，这依旧是一个比较复杂的解决方案。</p><h4 id="方法二-—-Async-Await-For-Loop"><a href="#方法二-—-Async-Await-For-Loop" class="headerlink" title="方法二 — Async/Await For-Loop"></a>方法二 — Async/Await For-Loop</h4><p>让我们尝试一下Async/Await<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitLoops</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> api.getUser()</span><br><span class="line">  <span class="keyword">const</span> friends = <span class="keyword">await</span> api.getFriends(user.id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> friend <span class="keyword">of</span> friends) &#123;</span><br><span class="line">    <span class="keyword">let</span> moreFriends = <span class="keyword">await</span> api.getFriends(friend.id)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'asyncAwaitLoops'</span>, moreFriends)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不需要写递归promise闭包，只需要使用一个for循环就能解决我们的问题。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>一个一个地去获取朋友的朋友的列表看起来有点慢，为什么不并行处理请求呢？我们可以用async/await来处理并行任务吗？<br>当然<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitLoopsParallel</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> api.getUser()</span><br><span class="line">  <span class="keyword">const</span> friends = <span class="keyword">await</span> api.getFriends(user.id)</span><br><span class="line">  <span class="keyword">const</span> friendPromises = friends.map(<span class="function"><span class="params">friend</span> =&gt;</span> api.getFriends(friend.id))</span><br><span class="line">  <span class="keyword">const</span> moreFriends = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(friendPromises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'asyncAwaitLoopsParallel'</span>, moreFriends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了并行请求，我们使用了一个promise数组并将它传递给方法Promise.all()，Promise.all()会返回一个promise，一旦所有的请求完成就会决议。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>然而，在异步编程中有一个主要的问题还没解决：错误处理。在异步操作中，我们必须为每个操作编写单独的错误处理回调，在调用栈的顶部去找出正确的报错位置可能很复杂，所以我们得在每个回调开始时就去检查是否抛出了错误。所以，引入错误处理后的回调函数会比之前复杂度成倍增加，如果没有主动定位到报错的位置，这些错误甚至会被“吞掉”。<br>现在，我们给之前的例子添上错误处理机制。为了测试错误处理机制，我们将在真正获取到用户图片之前使用抽象类里的<code>api.throwError()</code>方法。</p><h4 id="方法一-—-Promise-Error-Callbacks"><a href="#方法一-—-Promise-Error-Callbacks" class="headerlink" title="方法一 — Promise Error Callbacks"></a>方法一 — Promise Error Callbacks</h4><p>让我们看看最坏的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackErrorHell</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">let</span> user, friends</span><br><span class="line">  api.getUser().then(<span class="function"><span class="keyword">function</span> (<span class="params">returnedUser</span>) </span>&#123;</span><br><span class="line">    user = returnedUser</span><br><span class="line">    api.getFriends(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">returnedFriends</span>) </span>&#123;</span><br><span class="line">      friends = returnedFriends</span><br><span class="line">      api.throwError().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error was not thrown'</span>)</span><br><span class="line">        api.getPhoto(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">photo</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'callbackErrorHell'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.error(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码除了又长又丑陋以外，代码操作流也不直观，不像同步、可读性高的代码那样从上往下。</p><h4 id="方法二-—-Promise-Chain-“Catch”-Method"><a href="#方法二-—-Promise-Chain-“Catch”-Method" class="headerlink" title="方法二 — Promise Chain “Catch” Method"></a>方法二 — Promise Chain “Catch” Method</h4><p>我们可以给promise链添加<code>catch</code>方法来改善一些<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackErrorPromiseChain</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">let</span> user, friends</span><br><span class="line">  api.getUser()</span><br><span class="line">    .then(<span class="function">(<span class="params">returnedUser</span>) =&gt;</span> &#123;</span><br><span class="line">      user = returnedUser</span><br><span class="line">      <span class="keyword">return</span> api.getFriends(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">returnedFriends</span>) =&gt;</span> &#123;</span><br><span class="line">      friends = returnedFriends</span><br><span class="line">      <span class="keyword">return</span> api.throwError()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error was not thrown'</span>)</span><br><span class="line">      <span class="keyword">return</span> api.getPhoto(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">photo</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'callbackErrorPromiseChain'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来好多了，我们通过给promise添加一个错误处理取代了之前给每个回调函数添加错误处理。但是，这还是有一点复杂并且我们还是需要使用一个特殊的回调来处理异步错误而不是像对待正常的JavaScript错误那样处理它们。</p><h4 id="方法三-—-Normal-Try-Catch-Block"><a href="#方法三-—-Normal-Try-Catch-Block" class="headerlink" title="方法三 — Normal Try/Catch Block"></a>方法三 — Normal Try/Catch Block</h4><p>我们可以做得更好<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aysncAwaitTryCatch</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> api.getUser()</span><br><span class="line">    <span class="keyword">const</span> friends = <span class="keyword">await</span> api.getFriends(user.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> api.throwError()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error was not thrown'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> photo = <span class="keyword">await</span> api.getPhoto(user.id)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async/await'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将异步操作放进了处理同步代码的try/catch代码块。通过这种方法，我们完全可以像对待同步代码的一样处理异步代码的错误。代码看起来非常简明</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>我在前面提及了任何以<code>async</code>的函数可以返回一个promise。这使得我们可以真正轻松地组合异步控制流<br>举个例子，我们可以重新整理前面的例子，将获取数据和处理数据分开。这样我们就可以通过调用async函数获取数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Api()</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> api.getUser()</span><br><span class="line">  <span class="keyword">const</span> friends = <span class="keyword">await</span> api.getFriends(user.id)</span><br><span class="line">  <span class="keyword">const</span> photo = <span class="keyword">await</span> api.getPhoto(user.id)</span><br><span class="line">  <span class="keyword">return</span> &#123; user, friends, photo &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseUserInfo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getUserInfo().then(<span class="function">(<span class="params">&#123; user, friends, photo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promiseUserInfo'</span>, &#123; user, friends, photo &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更棒的是，我们可以在数据接受函数里使用async/await，这将使得整个异步模块更加明显。<br>如果我们要获取前面10个用户的数据呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getLotsOfUserData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> users = []</span><br><span class="line">  <span class="keyword">while</span> (users.length &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    users.push(<span class="keyword">await</span> getUserInfo())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'getLotsOfUserData'</span>, users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并发呢？并且加上错误处理呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getLotsOfUserDataFaster</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userPromises = <span class="built_in">Array</span>(<span class="number">10</span>).fill(getUserInfo())</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(userPromises)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getLotsOfUserDataFaster'</span>, users)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>随着SPA的兴起和NodeJS的广泛应用，对于JavaScript开发人员来说，优雅地处理并发性比以往任何时候都要重要。Async/Await缓解了许多因为bug引起且已经影响JavaScript很多年的控制流问题，并且使得代码更加优雅。如今，主流的浏览器和NodeJS都已经支持了这些语法糖，所以现在是使用Async/Await的最好时机。</p><p>原文链接：<a href="https://blog.patricktriest.com/what-is-async-await-why-should-you-care/" target="_blank" rel="noopener">https://blog.patricktriest.com/what-is-async-await-why-should-you-care/</a><br>掘金地址：<a href="https://juejin.im/post/5ad1cab8f265da238a30e137" target="_blank" rel="noopener">https://juejin.im/post/5ad1cab8f265da238a30e137</a></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Nginx反向代理跨域</title>
      <link href="/2018/04/08/Cross-Origin-using-Nginx/"/>
      <url>/2018/04/08/Cross-Origin-using-Nginx/</url>
      
        <content type="html"><![CDATA[<p>由于项目前后端分离且后端真实接口已出，所以我开发时首先考虑通过跨域获取真实接口数据配合前端开发。（赶工期啊：）<br>根据create-react-app官方提示，在package.json中添加字段<br><code>&quot;proxy&quot;: &quot;http://admin.xiaoyaoeden.top&quot;</code><br>emmm<br>🤭无效 😂<br>所以改为使用Nginx反向代理跨域😊<br>current origin：<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a><br>target origin：<a href="http://admin.xiaoyaoeden.top" target="_blank" rel="noopener">http://admin.xiaoyaoeden.top</a><br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install nginx</code></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>首先进入nginx的配置文件</p><p><code>vim /usr/local/etc/nginx/nginx.conf</code></p><p>增加如下一个server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       3001;</span><br><span class="line">       server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_pass http://localhost:3000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /api/ &#123;</span><br><span class="line">           add_header Access-Control-Allow-Origin *;</span><br><span class="line">           proxy_pass http://admin.xiaoyaoeden.top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="重启Nginx服务"><a href="#重启Nginx服务" class="headerlink" title="重启Nginx服务"></a>重启Nginx服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开localhost:3001，跨域问题解决了，现在可以开开心心的测试接口啦</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的类型（二）———— 强制类型转换</title>
      <link href="/2018/02/15/type-juggling/"/>
      <url>/2018/02/15/type-juggling/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>JavaScript中的强制类型转换经常让人诟病，但是也并非一无是处。<br>将<strong>值</strong>从一种类型转换成另一种类型称为类型转换，隐式转换称为<strong>强制类型转换</strong>；与此同时也有另外一种区分方式，类型转换发生在静态语言编译阶段而强制类型发生在动态语言的运行时。在JavaScript中，统称为强制类型转换，显隐之分多取决于编码者是否知道转换的效果和副作用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“工作室招新页面项目”实践中遇到的问题（一）———— React组件通信</title>
      <link href="/2018/02/13/React-Problem-1/"/>
      <url>/2018/02/13/React-Problem-1/</url>
      
        <content type="html"><![CDATA[<p>最近学了React基础知识，所以有打算做一个项目来踩坑，恰好适逢大二寒假并且工作室恰好需要在开学后招新，所以天时地利人和，我就用React作为这个项目的技术栈。于是项目开发中的第一个问题就诞生了————React组件通信<br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>material-ui中的组件AppBar和Drawer之间的通信，二者为兄弟组件。</p><p>AppBar组件<br><img src="http://chuantu.biz/t6/230/1518587193x-1404764720.png" alt=""></p><p>Drawer组件<br><img src="http://chuantu.biz/t6/230/1518587161x-1404764720.png" alt=""></p><h3 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h3><ol><li>我需要点击AppBar的左侧的icon调出Drawer。</li><li>点击Drawer中的MenuItem跳转到其他页面</li><li>调出Drawer后点击非Drawer组件后收起Drawer。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>通讯是单向的，数据必须是由一方传到另一方。</p><h4 id="父组件与子组件的通信"><a href="#父组件与子组件的通信" class="headerlink" title="父组件与子组件的通信"></a>父组件与子组件的通信</h4><p>在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      msg: <span class="string">'今天是情人节耶'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child msg=&#123;<span class="keyword">this</span>.state.msg&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;this.props.msg&lt;/</span>p&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="子组件与父组件的通信"><a href="#子组件与父组件的通信" class="headerlink" title="子组件与父组件的通信"></a>子组件与父组件的通信</h4><p>子组件向父组件通信，同样需要父组件向子组件传递props，不过这次是传递的是以父组件自身为作用域的函数，子组件负责调用，将要传递的信息传入函数中，作为参数，传递到父组件的作用域中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      msg: <span class="string">'今天是情人节耶'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.transferMsg = <span class="keyword">this</span>.transferMsg.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg: msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child transferMsg=&#123;<span class="keyword">this</span>.transferMsg&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.msg = '我也喜欢你';</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    this.props.transferMsg(this.msg);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;情人节啊&lt;/</span>p&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h4><p>因为AppBar和Drawer为兄弟组件，它们的共同点是拥有一个相同的父组件。<br>先看看组件结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Nav&gt;</span><br><span class="line">  &lt;AppBar /&gt;</span><br><span class="line">  &lt;Drawer /&gt;</span><br><span class="line">&lt;<span class="regexp">/Nav&gt;</span></span><br></pre></td></tr></table></figure></p><p>所以我们可以将父组件Nav作为中转站，AppBar传递信息给Nav，Nav再将信息传递给Drawer;Drawe传递信息给AppBar与此类似。解决方案如下，我们将Drawer的开关状态放在了Nav的state中，声明了更改open值的transferMsg函数，然后将这个函数分别传递个NavBar和Drawer，这样以来真正控制open的值就是NavBar和Drawer组件。具体实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      open: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.transferMsg = <span class="keyword">this</span>.transferMsg.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transferMsg() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      open: !<span class="keyword">this</span>.state.open</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;NavBar transferMsg=&#123;<span class="keyword">this</span>.transferMsg&#125;/&gt;</span><br><span class="line">        &lt;NavDrawer</span><br><span class="line">          msg=&#123;<span class="keyword">this</span>.state.open&#125;</span><br><span class="line">          transferMsg=&#123;<span class="keyword">this</span>.transferMsg&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class NavBar extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleMenuClick = this.handleMenuClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleMenuClick(event) &#123;</span></span><br><span class="line"><span class="regexp">    this.props.transferMsg();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;AppBar</span></span><br><span class="line"><span class="regexp">        title="CTG Club"</span></span><br><span class="line"><span class="regexp">        iconClassNameRight="mudiocs-icon-navigation-expand-more"</span></span><br><span class="line"><span class="regexp">        onLeftIconButtonClick=&#123;this.handleMenuClick&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavDrawer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleToggle= <span class="keyword">this</span>.handleToggle.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleClose = <span class="keyword">this</span>.handleClose.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.transferMsg();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClose() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.transferMsg();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Drawer</span><br><span class="line">          docked=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">          width=&#123;<span class="number">200</span>&#125;</span><br><span class="line">          open=&#123;<span class="keyword">this</span>.props.msg&#125;</span><br><span class="line">          onRequestChange=&#123;<span class="keyword">this</span>.handleToggle&#125;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;<span class="regexp">/Drawer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这个项目中的问题迎刃而解。这代码结构，仿佛还有一点东西。</p><h3 id="发布者-订阅者模式"><a href="#发布者-订阅者模式" class="headerlink" title="发布者-订阅者模式"></a>发布者-订阅者模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>发布—订阅模式又叫<strong>观察者模式</strong>，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用<strong>事件模型</strong>来替代传统的发布—订阅模式。</p><p>####运用<br>1.发布-订阅者模式可以广泛应用于异步编程，只是一种替代回调函数的方案。<br>2。发布-订阅者模式可以取代对象之间硬编码的通知机制，一个对象不再显式调用另一个对象的某个接口，让两个对象松耦合地联系在一起。（这一点就可以上述的解决方案的不足的地方）</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>最近一年重庆房价蹭蹭往上涨，小明迫于家里的压力，打算在解放碑买置一套总价200万的三居室。小明到了售楼处才发现心仪的房子已经被别人买了，不过后续还有一些尾房推出，但是开发商也不清楚什么时候推出这些尾房。<br>于是售楼MM记下了小明的电话，答应他尾房一旦推出就打电话给他。后续小码也留了号码，每天等着售楼MM的电话。<br>这就是一个典型的发布-订阅者模式的例子，逻辑代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把发布—订阅的功能提取出来，放在一个单独的对象内:</span></span><br><span class="line"><span class="keyword">const</span> event = &#123;</span><br><span class="line">  clientList: [],</span><br><span class="line">  listen(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.clientList[key]) &#123;  <span class="comment">//如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span></span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn);  <span class="comment">// 订阅的消息添加进消息缓存列表</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  trigger(...message) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Array</span>.prototype.shift.call(message),  <span class="comment">//取出消息类型</span></span><br><span class="line">      fns = <span class="keyword">this</span>.clientList[key]; <span class="comment">//取出该消息对应的回调函数集合</span></span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123; <span class="comment">//如果没有订阅该消息，则返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn = fns[i++]; ) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, message); <span class="comment">//message是发布消息时附送的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  remove(key, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.clientList[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fns) &#123; <span class="comment">// 如果 key 对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;  <span class="comment">//// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></span><br><span class="line">      fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">        <span class="keyword">let</span> _fn = fns[i];</span><br><span class="line">        <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">          fns.splice(i, <span class="number">1</span>); <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能:</span></span><br><span class="line"><span class="keyword">const</span> installEvent = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> event) &#123;</span><br><span class="line">    obj[i] = event[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> salesOffices = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line">salesOffices.listen(<span class="string">'squareMeter88'</span>, fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'价格= '</span> + price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen(<span class="string">'squareMeter88'</span>, fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'价格= '</span> + price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.remove(<span class="string">'squareMeter88'</span>, fn1); <span class="comment">// 删除小明的订阅</span></span><br><span class="line"><span class="comment">// 小明订阅消息</span></span><br><span class="line"><span class="comment">// 小红订阅消息</span></span><br><span class="line">salesOffices.trigger(<span class="string">'squareMeter88'</span>, <span class="number">2000000</span>); <span class="comment">// 输出:2000000</span></span><br></pre></td></tr></table></figure></p><p>对于此项目中问题的解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">on、one：on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</span></span><br><span class="line"><span class="comment">trigger：trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</span></span><br><span class="line"><span class="comment">off：用于解除所有订阅了某个事件的所有函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> eventProxy = &#123;</span><br><span class="line">  onObj: &#123;&#125;,</span><br><span class="line">  oneObj: &#123;&#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.onObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.onObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.oneObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.oneObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  off: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key = args[<span class="number">0</span>];</span><br><span class="line">    args = [].concat(<span class="built_in">Array</span>.prototype.slice.call(args, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.onObj[key] !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">this</span>.onObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.onObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.oneObj[key] !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">this</span>.oneObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.oneObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BranchItemDatas = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Web研发部'</span>,</span><br><span class="line">    imgUrl: <span class="literal">null</span>,</span><br><span class="line">    imgTitle: <span class="literal">null</span>,</span><br><span class="line">    intro: <span class="literal">null</span>,</span><br><span class="line">    key:<span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'移动开发部'</span>,</span><br><span class="line">    imgUrl: <span class="literal">null</span>,</span><br><span class="line">    imgTitle: <span class="literal">null</span>,</span><br><span class="line">    intro: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'视觉设计部'</span>,</span><br><span class="line">    imgUrl: <span class="literal">null</span>,</span><br><span class="line">    imgTitle: <span class="literal">null</span>,</span><br><span class="line">    intro: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'产品运营部'</span>,</span><br><span class="line">    imgUrl: <span class="literal">null</span>,</span><br><span class="line">    imgTitle: <span class="literal">null</span>,</span><br><span class="line">    intro: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'运维安全部'</span>,</span><br><span class="line">    imgUrl: <span class="literal">null</span>,</span><br><span class="line">    imgTitle: <span class="literal">null</span>,</span><br><span class="line">    intro: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;NavBar /&gt;</span><br><span class="line">        &lt;NavDrawer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class NavBar extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleMenuClick = this.handleMenuClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  handleMenuClick() &#123;</span></span><br><span class="line"><span class="regexp">    eventProxy.trigger('open', true);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;AppBar</span></span><br><span class="line"><span class="regexp">        title="CTG Club"</span></span><br><span class="line"><span class="regexp">        onLeftIconButtonClick=&#123;this.handleMenuClick&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavDrawer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleToggle = <span class="keyword">this</span>.handleToggle.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleClose = <span class="keyword">this</span>.handleClose.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      open: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      open: !<span class="keyword">this</span>.state.open</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClose() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      open: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    eventProxy.on(<span class="string">'open'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        open: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    eventProxy.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        open: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Drawer</span><br><span class="line">        docked=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">        width=&#123;<span class="number">200</span>&#125;</span><br><span class="line">        open=&#123;<span class="keyword">this</span>.state.open&#125;</span><br><span class="line">        onRequestChange=&#123;<span class="keyword">this</span>.handleToggle&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;MenuItems /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Drawer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MenuItems extends Component &#123;</span></span><br><span class="line"><span class="regexp">  handleMenuItemClick() &#123;</span></span><br><span class="line"><span class="regexp">    eventProxy.trigger('close', false);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;ul className='normal-list'&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;0&#125;&gt;首页&lt;/</span>MenuItem&gt;</span><br><span class="line">        &#123;BranchItemDatas.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;MenuItem onClick=&#123;<span class="keyword">this</span>.handleMenuItemClick&#125; key=&#123;item.key&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/MenuItem&gt;</span></span><br><span class="line"><span class="regexp">          );</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;6&#125;&gt;关于CTG&lt;/</span>MenuItem&gt;</span><br><span class="line">        &lt;MenuItem onClick=&#123;<span class="keyword">this</span>.handleMenuItemClick&#125; key=&#123;<span class="number">7</span>&#125;&gt;联系我们&lt;<span class="regexp">/MenuItem&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p><strong>参考书籍或博文：</strong><br><a href="http://www.ituring.com.cn/book/1632" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》</a><br><a href="http://taobaofed.org/blog/2016/11/17/react-components-communication/" target="_blank" rel="noopener">“React 组件间通讯”————淘宝前端团队</a></p><p><em>情人节快乐啊</em><br><em>情人节快乐啊</em><br><em>情人节快乐啊</em><br><em>情人节快乐啊</em></p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning PostCSS(一)</title>
      <link href="/2018/02/07/postCSS-1/"/>
      <url>/2018/02/07/postCSS-1/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>PostCSS是目前CSS处理器中最流行的一个处理器，没有之一。<br><img src="https://s1.ax1x.com/2018/02/07/91UDxK.jpg" alt=""><br><a id="more"></a><br>它不等同于Sass、Less等预处理器，也不等同于Compass（Compass已经死了）这样的后处理器，尽管它带有Post这个英文单词。<br>PostCSS的功能主要有两个：第一，把CSS解析成JavaScript可以操作的AST(Abstact Syntax tree,抽象语法树);第二，调用插件来处理AST并得到结果。PostCSS的强大之处在于其不断发展的插件生态。<br><img src="https://s1.ax1x.com/2018/02/07/91UhGt.jpg" alt=""></p><h2 id="创建变量和混合宏"><a href="#创建变量和混合宏" class="headerlink" title="创建变量和混合宏"></a>创建变量和混合宏</h2>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostCSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的类型（一）———— 类型</title>
      <link href="/2018/02/06/type-js/"/>
      <url>/2018/02/06/type-js/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>类型：对语言引擎和开发人员来说，<strong>类型</strong>是值的内部特征，它定义了值的行为，以使其区别于其他值。<br>JavaScript是一门弱类型（偏向容忍隐式类型转换）语言，同时也是一门动态类型（编译的时候就知道每个变量的类型）语言。<br><img src="http://chuantu.biz/t6/222/1517887204x-1404764355.jpg" alt=""><br>没有严格的类型的限制，使得JavaScript成为了一门特别灵活的语言，但是也带了一些麻烦，例如<strong>强制类型转换</strong>。<br><a id="more"></a></p><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>JavaScript中暂时有7种内置类型：</p><ul><li>空值（null）</li><li>未定义（undefined）</li><li>布尔值（boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>对象（object）</li><li>符号（symbol）<br>通常，我们可以通过typeof操作符来查看值的类型，它会返回类型的字符串值，但是并不是这七种类型和它们的字符串值并不是一一对应。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面六种类型均有同名的字符串值与之对应,'==='会返回true。</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> === <span class="string">'boolsean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3</span> === <span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'3'</span> === <span class="string">'string'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">number</span>: <span class="number">3</span>&#125; === <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于null类型，存在一个bug（从JavaScript诞生就一直存在，以后估计也会存在），对null进行typeof操作，返回的值居然是'object'；</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span>    <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'null'</span> <span class="comment">//false</span></span><br><span class="line"><span class="comment">//我们需要使用复合条件来检测null值的类型：</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//对于&amp;&amp;操作，如果运算符左边的值为真，则该表达式直接返回右边的值，例如 'true &amp;&amp; 3'表达式的结果为3。</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是’object’的一个子类型，函数是一个“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。但是，对函数进行typeof操作时，返回的值可不是’object’。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; === <span class="string">'object'</span>    <span class="comment">//false</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; === <span class="string">'function'</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>没错，就是’function’。看起来function就是另外一种内置类型，但是它不是。：）</p><h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p><strong>变量没有类型，值才有类型</strong><br>JavaScript中的变量是没有类型的，只有值才具有类型，变量可以随时持有任何类型的值。前面提到过，JavaScript是一门动态弱类型的语言。例如：变量a持有的值为42，那么这个值的类型为number，并且无法直接更改42的类型（number），但可以通过强制转换将这42转换为’42’，此时值拥有的类型就为字符串（string)。</p><h3 id="undefined-and-undeclared"><a href="#undefined-and-undeclared" class="headerlink" title="undefined and undeclared"></a>undefined and undeclared</h3><p>变量未持有值时为undefined，此时typeof返回’undefined’。<br><strong>已在作用域中声明但未赋值的比变量是undefined的，未在作用域声明过的变量是undeclared的。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a;  <span class="comment">//undefined</span></span><br><span class="line">b;  <span class="comment">//ReferenceError:b is not defined，报错</span></span><br></pre></td></tr></table></figure></p><p>每次看到“not defined”,总以为等价于”undefined”，真让人糟心，还有更糟心的：）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">typeof</span> a;   <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>一向被认为比较安全的操作符typeof也会这样闹着玩：）<br>注：推荐一本必看的书《JavaScript语言精粹》，作者是Douglas Crockford（大神）。</p><h3 id="安全防范机制"><a href="#安全防范机制" class="headerlink" title="安全防范机制"></a>安全防范机制</h3><p>并不是没有办法让开发人员解决’undeclared’问题，有时候通过typeof的安全防范机制（阻止报错）来检查undeclared变量不失为一个方法。<br>当一个窗口加载多个.js文件时，这些.js文件中的代码会共享一个全局作用域，如果有重名的变量名，那么就太可怕了……减少全局变量是编写可维护的代码的基础，所有东西都应该被封装到模块或者私有/独立的命名空间里。<br>例如：调试模式下，在debug.js声明了一个DEBUG的全局变量，把它作为调试模式的开关，在输出调试信息时我们会先判断DEBUG是否已经被声明。可是如何在程序中检查全局变量DEBUG且不会出现ReferenceError错误呢？typeof的安全防范机制就成了我们的帮手<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样做是要挨Error的</span></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调试开始啰"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样就比较安全了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> DEBUG !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调试开始啰"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不仅对于自定义的变量有用，对于内建的API也有帮助。甚至不一定要求作用域为全局，也可以用于检查我们的变量是否在宿主作用域声明过。</p><p>还有一个方法，就是检查所有全局变量是否是全局对象的属性，浏览器的全局对象是window，服务器端的全局对象为global。上述的例子我们可以这样操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.DEBUG) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问不存在的对象属性与undeclared变量不同，是不会报错的。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>参考文献：<br>《你不知道的JavaScript（中卷）》<br>《JavaScript语言精粹》</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的继承方式</title>
      <link href="/2018/02/03/inherit-in-js/"/>
      <url>/2018/02/03/inherit-in-js/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>继承是OOP的核心内容之一。JavaScript中常见继承方式为：类式继承、构造函数式继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。<br><a id="more"></a></p><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p><strong>类式继承，通过子类的原型prototype对父类的实例化实现。由于子类通过其原型prototype对父类实例化继承了父类，所以父类中的共有属性要是引用类型就会在子类中被所有实例共用。由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类时是无法向父类传递参数的，因而在实例化父类时无法对父类构造函数内的属性进行初始化。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.superValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为父类添加共有方法</span></span><br><span class="line">SuperClass.prototype.getsuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类（</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"><span class="comment">//为子类添加共有方法</span></span><br><span class="line">SubClass.prototype.getsubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构造函数式继承"><a href="#构造函数式继承" class="headerlink" title="构造函数式继承"></a>构造函数式继承</h2><p><strong>构造函数继承，通过在子类的构造函数作用环境中执行一次父类的构造函数来实现；由于没用涉及prototype，所以父类的原型方法不会被子类继承。要想被子类继承，就得把属性和函数放到父类的构造函数中，并且创建出来的（子类的）实例都会单独拥有一份，违背了 “代码复用”。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引用类型共有属性</span></span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>, <span class="string">'html'</span>, <span class="string">'css'</span>];</span><br><span class="line">  <span class="comment">//值类型共有属性</span></span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类声明原型方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//继承父类</span></span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, id); <span class="comment">//将子类的变量在父类中都执行一遍，父类中是给this绑定属性的，所以通过call就使得子类继承了父类的共有属性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p><strong>组合继承，将类式继承和构造函数式继承综合，构造函数继承时执行了一遍父类的构造函数，在实现子类原型的类式继承又调用一遍父类构造函数。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">"javascript"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数式基础父类name属性</span></span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="comment">//子类新增共有属性</span></span><br><span class="line">  <span class="keyword">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类式继承 子类原型继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"><span class="comment">//子类原型方法</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p><strong>原型式继承，借助原型prototype可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对类式继承的封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObejct</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line">  <span class="comment">//声明一个过渡函数对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的一个实例， 该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于这种在对象之间直接构建继承关系的理念，DC大神给出了上述的函数，这个inheritObject函数后来被ES5采纳，更名为Object.create()。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p><strong>寄生式继承,对原型继承的第二次封装，并且在此过程中对继承的对象进行了拓展。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明基对象</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  name: <span class="string">'js book'</span>,</span><br><span class="line">  alikeBook: [<span class="string">"css book"</span>, <span class="string">"html book"</span>,<span class="string">"html book"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//通过原型继承方式创建新对象</span></span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> inheritObejct(obj);</span><br><span class="line">  <span class="comment">//拓展新对象</span></span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回拓展后的新对象</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p><strong>这里的寄生继承处理的是类的原型</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inhreitPrototype</span>(<span class="params">SubClass, SuperClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//复制一份父类的原型副本保存在变量中</span></span><br><span class="line">  <span class="keyword">let</span> p = inheritObejct(SuperClass.prototype);</span><br><span class="line">  <span class="comment">//修正因为重写子类原型导致子类的constructor属性被修改</span></span><br><span class="line">  p.constructor = SubClass;</span><br><span class="line">  <span class="comment">//设置子类的原型</span></span><br><span class="line">  SubClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义父类的原型方法</span></span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数式继承</span></span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>,name);</span><br><span class="line">  <span class="comment">//子类新增属性</span></span><br><span class="line">  <span class="keyword">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*寄生式继承父类原型*/</span></span><br><span class="line">inhreitPrototype(SubClass, SuperClass);</span><br><span class="line"><span class="comment">/*子类新增原型方法*/</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="extend与deepCopy"><a href="#extend与deepCopy" class="headerlink" title="extend与deepCopy"></a>extend与deepCopy</h2><p><strong>在JavaScript中继承是依赖于原型prototype链实现的，只有一条原型链，理论上不能继承多个父类。但是由于JavaScript是一门很灵活的语言，所以我们可是自己动手实现一个继承多对象属性的函数。</strong></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>JavaScript中每个函数都有一个指向某一对象的prototype属性，该函数被new操作符调用时会创建并返回一个对象，返回的对象中有一个指向其原型对象的<strong>proto</strong>属性，引擎在背后通过运用<strong>proto</strong>可以使得新建的对象可以调用相关原型的对象的方法和属性。原型对象本身也是对象，所以本身也包含了指向其原型的<strong>proto</strong>,由此就形成了一条链，称之为原型链。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><img src="https://s1.ax1x.com/2018/02/07/91MwdK.jpg" alt=""><br>如图，有了原型链，如果某个属性在对象B中而不在对象A中，我们依然可以把这个属性当作A的属性来访问。这就是继承的作用，它可以使得每个对象都能访问其继承链上的任何属性。</p><h3 id="继承单对象属性的extend方法（针对值类型的属性）"><a href="#继承单对象属性的extend方法（针对值类型的属性）" class="headerlink" title="继承单对象属性的extend方法（针对值类型的属性）"></a>继承单对象属性的extend方法（针对值类型的属性）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    child[prop] = parent[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承多对象的属性"><a href="#继承多对象的属性" class="headerlink" title="继承多对象的属性"></a>继承多对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>,</span><br><span class="line">      len = <span class="built_in">arguments</span>.length,</span><br><span class="line">      child = <span class="built_in">arguments</span>[<span class="number">0</span>],</span><br><span class="line">      arg;</span><br><span class="line">  <span class="keyword">for</span>(; i &lt; len; i++) &#123;</span><br><span class="line">    arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> prop <span class="keyword">in</span> arg) &#123;</span><br><span class="line">      child[prop] = arg[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><strong>在JavaScript中复制一个对象的属性时，如果对象的属性为值类型则只需要简单的赋值语句即可，如果属性为引用类型，则需要依次复制该属性的属性，这里采用递归的思想解决这个问题。（如果不使用递归，则通过JSON解析解决）</strong></p><h4 id="为什么要这么做？"><a href="#为什么要这么做？" class="headerlink" title="为什么要这么做？"></a>为什么要这么做？</h4><p>当创建一个对象时，这个对象就被存储在内存中的某个物理位置，相关的变量和属性就会指向这些位置。<br><img src="https://s1.ax1x.com/2018/02/07/91lUUK.jpg" alt=""></p><ol><li>创建一个新对象，并让变量A指向该对象。</li><li>创建一个新变量B，并设置其与A相等，此时B和A指向了同一个对象，也就是内存中的同一个地址。</li><li>修改变量B所指的对象的color属性，将它设置为”white”,此时A.color 的值也为”white”。</li><li>再创建一个对象，然后让变量B指向这个新对象，A和B此时指向了内存中不同的位置，A、B从此再无关联。<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.hasOwnProperty(prop)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[prop] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                child[i] = <span class="built_in">Array</span>.isArray(parent[prop])? [] : &#123;&#125;;</span><br><span class="line">                deepCopy( parent[prop], child);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                child[prop] = parent[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s1.ax1x.com/2018/02/07/918qat.jpg" alt=""><br><img src="https://s1.ax1x.com/2018/02/07/918XPf.jpg" alt=""><br><img src="https://s1.ax1x.com/2018/02/07/918bVI.jpg" alt=""><br><img src="https://s1.ax1x.com/2018/02/07/918LIP.jpg" alt=""></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>参考文献：<br>《JavaScript面向对象编程指南》<br>《JavaScript设计模式》<br>《你不知道的JavaScript（上卷）》</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/03/hello-world/"/>
      <url>/2018/02/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简析Redis哨兵实现原理]]></title>
    <url>%2F2018%2F11%2F23%2Fredis-sentinel%2F</url>
    <content type="text"><![CDATA[Redis Sentinel 是一个分布式架构(Sentinel节点、Redis数据节点、Redis客户端分布在不同的物理节点上)，其中包括了若干个Sentinel节点和Redis数据节点，每个Sentinel节点对数据节点和其他Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。若该节点为主节点，它会和其他Sentinel节点共同协商，若大部分节点皆表示该主节点不可达，那么就会从Sentinel中选举出一个Sentinel节点来完成自动故障转移的工作，同时将这个变化实时通知给Redis应用方。 实现原理三个定时监控任务Redis通过三个定时监控任务完成对各个节点的发现和监控。_s_ 获取最新拓扑结构每隔10s，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。 作用： 通过向主节点执行info命令，获取从节点信息，所以Sentinel节点不需要显式配置监控从节点。 当有新的从节点加入时都可以立刻感知出来。 节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。 Sentinel节点发布和订阅sentinel:hello频道每隔2s，每个Sentinel节点会向Redis数据节点的__sentinel__:hello频道发送该sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道来了解其他Sentinel节点以及它们对主节点的判断。 作用： 发现新的Sentinel节点。 Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。 心跳检测每隔1s，每隔Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确定这些节点是否可达。 作用： 判断节点是否可达的重要依据。 主观下线和客观下线主观下线上面提到心跳检测，如果这些节点超过down-after-millionsections还没有进行有效回复，Sentinel节点就会对该节点做失败判断，这个行为叫做主观下线。Sentinel节点、从节点，主观下线后没有后续的故障转移操作。 客观下线当Sentinel节点主观下线的节点是主节点时，该Sentinel节点会通过sentinel is-master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过个数，Sentinel认为主节点的确出现问题，此时该Sentinel对主节点做出客观下线的决定。 领导者Sentinel节点选举当Sentinel节点对主节点完成了客观下线后，Sentinel节点之间还会选举出一个结点作为领导者进行故障转移工作；Redis使用了Raft算法实现领导者选举。 Raft算法大致思路 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线后，会向其他节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。 收到命令的Sentinel节点，如果没有同意过其他的Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，反之拒绝。 如果该Sentinel节点发现自己的票数已经大于或等于max(quorum, num(sentinels) / 2 + 1)，那么它就成为领导者。 如果此过程没有选举出领导者，将进入下一次选举。 基本上谁先完成客观下线，谁就是领导者。 故障转移领导者选举出的Sentinel将负责故障转移。 过程 从节点列表中选举出一个节点作为新的主节点。 过滤掉不主观下线、掉线、5秒内没有回复Sentinel ping响应等等的节点… 选择从节点优先级最高的节点，如果存在则返回，不存在则继续下一步。 选择复制偏移量最大的从节点，如果存在则返回，不存在则继续下一步。 选择runid最小的从节点。 对选举出的节点执行slave of no one，升级为主节点。 Sentinel领导者节点向其他节点发送命令，让它们成为新主节点的从节点。 Sentinel集合节点将原主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>哨兵</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简析Redis复制原理]]></title>
    <url>%2F2018%2F11%2F11%2FRedis-Replication%2F</url>
    <content type="text"><![CDATA[在分布式系统中为了解决单点问题，通常会把数据复制成多个副本部署到不同的机器上，以满足负载均衡和故障恢复等需求，Redis也是如此，Redis支持简单且易用的主从复制（master-slave replication）功能。 复制过程 slave执行slaveof命令，slave只保存master的地址信息后就返回。 slave通过内部每秒运行的定时任务维护复制相关的逻辑，当定时任务发现新的master信息时，开始尝试与master建立网络连接。如果无法建立连接，slave会一直无限次重连直到连接成功或者取消复制。 连接建立成功后slave会发送ping请求进行首次通信，检测主从之间网络套接字是否可用、检测msater当前是否可接受处理命令。 如果master设置了requirepass参数，则需要密码验证。 首次建立复制，主从节点会进行一次全量复制。 同步数据集成功后，master持续把后续的写命令发送给slave，保证主从一致性。 数据同步如何进行数据同步？复制偏移量（offset）参与主从复制的master和slave会保存各自的复制偏移量，slave的复制偏移量初始值为-1。master处理写入命令后，会对自己的复制偏移量进行累加；slave收到master发送的命令后，也会对自己的复制偏移量进行累加，并且slave每秒上报自身的复制偏移量给master，所以master也保存了slave的复制偏移量。倘若主从复制偏移量差距过大，则有可能是因为阻塞或网络延迟高造成的。 复制积压缓冲区复制积压缓冲区是保存在master上的一个固定长度的队列。当master处理写入命令后，不仅会把命令发送给slave，也会把命令写入复制积压缓冲区。复制积压缓冲区用于保存最近已复制数据，可用于部分复制或复制命令丢失的数据补救。 主节点运行ID（runId）每个Redis启动后会动态分配一个40位的十六进制的字符串作为运行ID，运行ID的主要作用是唯一识别Redis节点。如果master运行ID发生变化后，主从节点将进行全量复制。 psync命令slave使用psync命令完成部分复制和全量复制功能，命令格式：psync {runId} {offset}。slave发送psync命令给master，master根据psync的参数和自身数据决定响应结果（全量复制、部分复制、错误）。 全量复制全量复制是redis最早支持的复制方式，也是主从第一次建立后必须经历的阶段。 过程 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点运行ID，所以发送psync ? -1。 主节点根据psync解析当前为全量复制，回复+FULLRESYNC响应。 slave接收到master的响应数据，保存runId和offset。 master开始执行bgsave，保存RDB到本地。 master发送RDB文件给slave，slave接受到RDB文件后存储为自己的数据文件。（如果文件过大，存在超时全量复制失败的风险）。 从slave开始接受RDB到接受完成期间，master仍在处理读写命令。在这期间，master将写命令写入客户端缓冲区，当slave加载完RDB后，再把缓冲区内的数据发送给slave，保证主从之间数据一致性。 slave接受完master传送的数据后会清空自身旧数据。 slave清空数据后开始价值RDB文件，如果RDB文件过大，这个过程非常耗时。如果slave正处于全量复制阶段或者复制中断，那么slave响应读命令时可能拿到过期或错误的数据，数据出现不一致。（可以通过设置slave-serve-stable-data参数来关闭对读命令的响应） slave加载完RDB后，如果slave开启了AOF持久化，它会立即执行bgrewriteaof操作，保证全量复制后AOF持久化文件立刻可用。 时间开销 master bgsave时间 RDB文件网络传输时间 salve清空数据时间 slave加载RDB时间 可能的AOF重写时间 由此可见，全量复制的时间开销大，除此之外，全量复制过程中也会消耗大量的CPU、内存、网络资源。所以除了第一次复制采用全量复制，其余场景应该规避全量复制的发生。 部分复制部分复制主要是Redis针对全量复制过高开销作出的一种优化措施。当slave正在复制master时，如果出现网络闪断或者命令丢失等异常情况时，slave会向master要求补发丢失的命令数据，如果master的复制积压缓冲区内存在这部分数据则之间发给slave，这样可以确保主从节点复制的一致性。补发的这部分数据一般远远小于全量数据，所以开销很小。 过程 主从节点之间网络出现中断时，如果超过repl-timeout时间，master会认为slave故障并中断复制连接。 主从连接中断期间master依然响应客户端的命令，但复制连接中断命令无法发送给slave，不过master内部存在复制积压缓冲区，可以保存最近一段时间的命令数据，默认最大缓存1MB。 主从节点网络恢复后，slave再次连上master。 主从连接恢复后，由于slave保存了自身已复制的偏移量和主节点的运行ID，此时将他们作为参数发送给master，要求进行部分复制。 master接到psync命令后进行核对，然后根据offset在自身复制积压缓冲区插座，如果数据存在于缓冲区，则对slave发送+CONTINUE响应，表示可以进行部分复制。 master根据offset把复制积压缓冲区里的数据发送给slave，保证主从复制进入正常状态。 异步复制（写命令同步）master不仅负责数据读写，还负责把写命令同步给slave。写命令的发送是异步完成，master自身处理完写命令后直接返回给客户端，并不等待slave复制完成。由于主从复制过程是异步的，就会造成salve数据相对master存在延迟。 心跳机制主从节点建立复制后，它们之间维护着长连接并彼此发送心跳命令。 主从心跳判断机制 主从节点各自都有心跳检测机制，各自模拟成对方的客户端进行通信。 master默认每隔10s对slave发送ping命令，判断slave的存活性和连接状态。 slave每隔1s对master发送replconf ack {offset}命令，给master上报自身当前的复制偏移量。replconf命令常用于检测主从节点网络状态、上报自身复制偏移量，检测复制数据是否丢失，如果slave数据丢失，再从master的复制缓冲区拉取丢失数据。、实现保证slave的数量和延迟性功能。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解Redis中的持久化机制]]></title>
    <url>%2F2018%2F11%2F09%2FRedis-Rersistence%2F</url>
    <content type="text"><![CDATA[什么是持久化？为什么需要持久化？持久化就是将内存中的数据模型转换为存储模型，更通俗的说，就是将数据保存到系统硬盘中。 Redis所有的数据都是存在内存中，一旦程序崩溃或重启，内存中的数据就会丢失，所以我们需要持久化。 RDB（默认开启）介绍RDB持久化是把当前进程数据生成快照保存到硬盘的过程，适用于备份、全量复制等场景。 过程 执行bgsave命令，父进程判断当前是否有正在执行的子进程如AOF子进程，若有直接返回。 父进程执行fork操作创建子进程，fork操作会阻塞父进程。 fork完成后，父进程处理其他命令。 子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对旧文件进行原子替换。 子进程发送信号通知父进程表示完成，父进程更新统计消息。 优点 RDB是一个非常紧凑的二进制文件，保存着Redis在某个时间节点上的数据集，非常适合备份、全量复制等场景。 RDB非常适用于灾难恢复，因为它只有一个文件并且非常紧凑，可以加密后传送到其他数据中心。 父进程保存RDB文件时仅仅需要花费fork一个子进程的时间，无需执行任何磁盘I/O操作。 Redis加载RDB恢复数据远远快于AOF的方式。 缺点 因为RDB文件需要保存整个数据集的状态，花费数分钟的时间，所以一旦发生故障停机，可能会丢失数分钟的数据。 每次保存RDB时，Redis需要fork一个子进程，并由子进程进行数据持久化；如果数据集很庞大，fork()可能会非常耗时，造成服务器在短时间（毫秒级）内停止处理客户端；如果CPU比较紧张，fork过程可能长达整整一秒。 AOF介绍AOF持久化是以独立的日志记录每次写命令，Redis重启的时候执行AOF文件中的命令来恢复数据。 过程 所有写命令都会追加到AOF缓冲区。 AOF缓冲区根据对应的策略向硬盘做同步操作。 随着AOF文件越来越大，需要定期对AOF文件进行重写以达到压缩的目的。 AOF缓冲区同步文件策略可以配置Redis多久将数据同步到磁盘一次。 always: 每次有写命令追加到AOF缓冲区时就调用系统fsync操作同步到AOF文件。 everysec：命令写入AOF缓冲区后调用系统write操作，fsync同步文件操作由专门线程每秒调用一次。 no：命令写入AOF缓冲区后调用系统write操作，不对AOF文件做fsync操作，同步硬盘由系统负责，通常同步周期为30s。 AOF重写机制AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。（因为重写AOF文件时，Redis会合并多条写命令、丢弃超时的数据、删除无效命令，所以重写后的AOF文件要小于旧文件） 优点 使用AOF持久化使得Redis更加耐久，AOF缓冲区同步文件策略可以使得Redis就算发生故障停机，也最多丢失1s的数据（实际上最多为2s）。 AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，文件内容易懂且容易分析、导出。 缺点 AOF文件的体积通常大于RDB文件的体积。 AOF的速度可能慢于RDB。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>持久化 缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门之初级排序（选择、插入、希尔）]]></title>
    <url>%2F2018%2F10%2F03%2Fsort-1%2F</url>
    <content type="text"><![CDATA[下面是选择排序、插入排序、希尔排序等初级排序的简单介绍及实现。 选择排序步骤 首先找到数组中最小的元素，将其与第一个元素置换位置。 从剩余的元素中找到最小的元素，将其与第二个元素置换位置。 以此类推，直到数组完全有序。 选择排序所需的时间取决于元素的数量 实现123456789101112131415161718public class Selection&#123; public static void sort(Comparable[] a) &#123; int N = a.length; int temp = 0; for (int i = 0; i &lt; N; i++) &#123; int min = i; for (int j = i + 1; j &lt; N; j++) &#123; if (a[min] &gt; a[j]) &#123; min = j; &#125; &#125; temp = a[min]; a[min] = a[i]; a[i] = temp; &#125; &#125;&#125; 插入排序步骤 第二个元素与左侧的元素进行比较，将其插入到合适的位置。 第三个元素与左侧的元素进行比较，将其插入到合适的位置。 以此类推，直到数组完全有序。 实现12345678910111213141516public class Insertion&#123; public static void sort(Comparable[] a) &#123; int N = a.length; int temp = 0; for (int i = 1; i &lt; N; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (a[j] &lt; a[j-1]) &#123; temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; &#125; &#125;&#125; 插入排序所需的时间取决于元素的初始顺序 希尔排序希尔排序是基于插入排序的快速排序，思想是使数组中任意间隔为h的元素是有序的。 步骤（序列1/2(3^k - 1)） 增幅h为数组长度的某个倍数（最小值为1），然后计算出增长序列(1, 4, 13, …)。 h = h(max)，确保间隔为h的元素有序。 h = h / 3，确保间隔为h的元素有序。 重复第3步，直至数组完全有序。 实现1234567891011121314151617181920212223public class Shell&#123; public static void sort(Comparable[] a) &#123; int N = a.length; int h = 1; int temp = 0; System.out.print(h); while (h &lt; N / 3) h = h * 3 + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h; j -= h) &#123; if (a[j - h] &gt; a[j]) &#123; temp = a[j - h]; a[j - h] = a[j]; a[j] = temp; &#125; &#125; &#125; h /= 3; &#125; &#125;&#125; 名称 使用场景 时间复杂度 效率影响因素 选择排序 小型数组 O(N^2) 数组大小 插入排序 小型数组，数组部分有序 O(N^2) 元素初始顺序 希尔排序 中小型数组，数组部分有序 O(N^3/2), O(N^4/3), O(N^6/5)… 元素初始顺序，增长序列]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Diff]]></title>
    <url>%2F2018%2F09%2F23%2Freact-diff%2F</url>
    <content type="text"><![CDATA[计算一棵树形结构转换成另一棵树形结构，传统的diff算法算法复杂度达到O(n^3)。React通过制定策略，将O(n^3)复杂度的问题转换成O(n)复杂度。 Diff 策略 Web UI 中DOM节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一id进行区分。 Tree Diff对树进行分层比较，两棵树只会对同一层次的节点进行比较。 当节点跨层级移动时，并不会出现想象中的移动操作，而是进行create-delete操作（影响性能）。 Component Diff 如果是同类型的组件，按原策略继续比较Virtual DOM tree。 如果不是同类型的组件，则将组件判断为dirty component，从而替换整个组件下的所有子节点。 如果是同一类型的组件，并且Virtual DOM没有发生变化，那么将会省下大量的diff运算时间，因此React允许用户通过shouldComponentUpdate()来判断组件是否需要进行diff。 Element Diff当节点处于同一层级时，React Diff提供了三种节点操作，分别为：INSERT_MARKUP、MOVE_EXISTING、REMOVE_NODE INSERT_MARKUP: 原集合不包含新的component类型，新节点需执行插入操作 MOVE_EXISTING: 原集合包含新的component类型，且element时可更新的类型，generateComponentChildren已调用receiveComponet，这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。 REMOVE_NODE: 老compone类型，在新集合也有，但对应的element不同则不能直接复用和更新，需执行删除操作，或者老component不在新集合中，也需要执行删除操作。 允许开发者对同一层级的同组子节点添加唯一key作为标识。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JavaScript之Event Loop]]></title>
    <url>%2F2018%2F06%2F27%2Fevent-loop%2F</url>
    <content type="text"><![CDATA[前言最近阅读《高性能JavaScript》时，第六章谈到“通过定时器将JavaScript执行代码的控制权先让给浏览器用于更新UI状态，然后再将控制权交回给JavaScript代码，这样就可以使得页面更为流畅”，就联想到了之前理解的事件循环。 这篇文章就是为了解释为什么这么做可以提升页面的流畅度。 事件循环（Event Loop） 单线程的JavaScript总所周知，JavaScript语言的一大特点就是单线程，也就是说在一个时间段里，JavaScript只能做一件事情（浏览器是多线程）。多线程可以实现应用的并行处理，从而以更高的CPU利用率提高整个应用程序的性能和吞吐量。 但是JavaScript却以单线程进行，为什么呢？ JavaScript是浏览器脚本语言，用于与用户交互以及操作DOM。考虑如下情况，如果有两个并发的操作，对同一个DOM节点分别进行删除和修改样式，此时浏览器就无法决定到底采用哪个线程的操作。类似数据库，我们可以采用“锁”来处理并发，但是这会平添复杂度。所以，JavaScript语言没有支持多线程操作。那又考虑这种情况，既然JavaScript是单线程，在某一时刻内只能执行特定的一个任务，并且会阻塞其它任务执行。那么如果用户触发了一个非常耗时的I/O操作，那么按道理后续的所有操作都得等到I/O操作完成后方可进行。但是，事实上，后续的任务不必等待这个耗时的I/O操作完成，原因就是JavaScript与生俱来的异步和回调。 而这背后恰好就是本文的主题——————事件循环 定义事件循环包含了至少两个任务队列，宏任务队列和微任务队列。 宏任务宏任务包含创建文档对象、解析HTML、执行主线JavaScript代码、更改当前URL以及各种事件，例如页面加载、输入、网络事件和定时器等等。宏任务运行完成后，浏览器继续其他的任务调度，如重新渲染页面或者垃圾回收。 微任务微任务包括promise、回调函数、DOM发生变化等。微任务更新应用程序的状态，必须在浏览器任务继续执行其他任务（渲染UI视图或者进行下一个宏任务）之前执行。 两个基本原则 一次处理一个任务 一个任务开始直到运行完成，不会被其他任务中断 无论是宏任务队列还是微任务队列，二者在同一时刻都只执行一个任务，不过二者也有重要的区别：在一次循环中，最多处理一个宏任务，而微任务队列中所有的微任务都会被处理。 在微任务队列清空后，事件循环会检查当前是否需要重新渲染UI，如果需要则渲染UI视图。 补充 两个任务队列都是独立于事件循环的，这意味着任务队列的添加发生在事件循环外。 所有微任务都会在下一次渲染前完成，目的是在渲染前更新应用程序状态。 浏览器会尝试以每秒渲染60次页面，以达到每秒60帧的速度。所以，一次循环最理想的时间应该不超过16ms。 浏览器完成页面渲染后，进入下一轮事件循环迭代后，可能出现3种情况 如果事件循环执行到“is rendering needed”且浏览器处于另一个16ms结束之前（即浏览器尚未自动触发页面渲染时），浏览器可能不会选择在当前的时间循环中执行更新UI操作，因为更新UI是一个复杂且耗性能的操作。 如果事件循环执行到“is rendering needed”且浏览器刚好离上一次渲染16ms左右时（即浏览器即将自动触发页面渲染时），此时浏览器会进行UI更新。 执行下一个事件循环耗时超过16ms，浏览器将无法以目标帧率重新渲染页面，且UI无法被更新。如果延迟不大是很难察觉到，但是，如果有非常耗时的操作，这个时候用户会觉得网页十分卡顿，甚至浏览器会提示“无响应脚本”。 前情回顾现在，用事件循环和简单的例子来分析《高性能的JavaScript》中的那句话。需求：给包含1000个数字的数组中的每个元素取绝对值（假设对一个数字进行需求操作耗时1ms）。 情况1（不使用定时器）:由于JavaScript主线程代码属于宏任务的一种，所以一次事件循环需要处理1000个数字，所以1s事件循环才进行到UI更新阶段，但是由于耗时过长，UI状态不会被更新，页面出现卡顿甚至堵塞。 情况2（使用定时器）：将一次处理1000个数字的任务分割为20个每次处理50个数字的任务。由于定时器是宏任务的一种，所以一次事件循环只处理50个数字，由于此时微任务队列为空，所以50ms后事件循环进行到UI更新阶段，然后根据情况进行UI渲染，页面未出现卡顿或者堵塞。 当然，如果只是单纯的处理数据，我们可以考虑使用Web Workers。 总结 JavaScript是单线程的，同一时刻是只能执行一个任务。 事件循环包含一个宏任务队列和至少一个微任务队列。事件循环一次迭代，至多执行一个宏任务但是会执行完所有的微任务。 Web应用越复杂，积极主动管理UI线程就越重要，即使JavaScript代码很重要，也不能影响用户体验。 参考 《High Performance JavaScript》 《Secrets of the JavaScript Ninja》 《HTML 5.2》]]></content>
      <categories>
        <category>JavaScript核心</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次面试经历]]></title>
    <url>%2F2018%2F05%2F24%2Fmy-first-interview%2F</url>
    <content type="text"><![CDATA[第一次投简历面试…… 腾讯MIG事业群 云安全部（5.21）第一次技术面试，比较紧张，面试过程20多分钟，最后问了面试官鹅厂前端生态和部门技术栈，下面是面试内容： 介绍一下自己，最近在看什么书，如何学习前端的。 CSS如何实现垂直居中、水平居中 对CSS3了解程度，用过哪些特性 HTTP状态码、Web缓存 跨域 介绍一下XSS和CSRF，如何避免 JavaScript中的异步编程 MVVM的原理 说说你的项目，讲讲收获大的地方。 5.17就接到了腾讯面试官的电话，问了我一些基本情况，看了我的github和博客，后面也加了微信，给了我一些很好的建议，人非常nice。（严格来说，这是第一次面试） 百度前端技术部（5.23）这次面试也是一位小姐姐官，一开始比较紧张，后面就好多了，面试过程50分钟。在第一个问题中，面试官认为我的方法不可行（filter + indexOf），后来被认可了。因为没问我JavaScript我觉得重要的概念（原型、闭包、事件循环等）比较惊讶，然后面试官让我介绍（虽然答上了，但是下次再也不主动给自己加题了🤦️），最后我问了问她们部门的业务和生态。下面是面试内容： 数组去重 如何实现图片充满盒子 如何实现CSS垂直居中 CSS3的新特性 Flex布局 HTTP状态码 Web缓存 性能优化 事件流 用过的ES6特性 谈谈项目中比较难的地方 总结腾讯和百度两次面试都是很好的体验，因为才大二，所以没有做面试的准备，抱着试一试的心态投递了简历，面试过程中也发现自己的一些不足，大神们的建议会仔细听取的。最后也拿到了实习offer，Keep hungry, keep foolish.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Nginx二级域名并部署hexo博客]]></title>
    <url>%2F2018%2F05%2F09%2Fhow-to-deploy-a-static-website%2F</url>
    <content type="text"><![CDATA[因为有不同的项目需要部署，所以我打算为每个项目分配一个二级域名。下面是整个流程的复盘: 安装nginx和gityum -y install nginx git 获取资源文件 新建 /var/www/blog 目录：mkidr /var/www/blog 切换到blog目录下并获取文件： cd /var/www/blog &amp;&amp; git clone git@github.com:GeniusFunny/GeniusFunny.github.io.git, 此时blog目录下有一个GeniusFunny.github.io文件夹，这就是我的hexo资源文件夹，配置.conf文件时会用到。 DNS添加二级域名前往你购买的服务器商（我购买的是腾讯云的服务）为在域名解析中添加解析记录，如图所示：点击添加记录，在主机记录添加你要的域名（如blog），在记录值处填写服务器的ip地址。那么就有一个新的域名，如:blog.geniusfunny.xyz。添加完成后，我们就开始配置我们的nginx。 nginx配置二级域名并部署 进入nginx默认配置文件vim /etc/nginx/nginx.conf 在http模块中添加一行代码（引入sites-enabled文件夹）：include /etc/nginx/sites-enabled/*; 在当前目录下，新建一个sites-enabled文件夹：mkdir sites-enabled 进入sites-enabled文件夹，添加以二级域名（blog.geniusfunny.xyz）为名称的配置文件: vim blog.geniusfunny.xyz 配置二级域名配置文件如下： 123456server &#123; listen 80; server_name blog.geniusfunny.xyz; root /var/www/blog/GeniusFunny.github.io; //这是我们的资源文件目录 index index.html index.htm index.nginx-debian.html;&#125; 配置快捷linux命令 进入.bashrc文件，vim ~/.bashrc 添加快捷linux自定义命令，alias myBlog=&#39;cd /var/www/blog/GeniusFunny.github.io, 保存 使.bashrc文件生效，source ~/.bashrc 以后我们就可以在根目录下输入myBlog进入资源文件夹目录，然后git pull，获取最新的资源 常用的关于nginx的命令检查nginx配置：nginx -t nginx.conf开启nginx服务：nginx关闭nginx服务：nginx -s stop强制关闭nginx服务：pkill -9 nginx重启nginx服务：nginx -s reload]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一行url到一个页面我们经历了什么？(更新中)]]></title>
    <url>%2F2018%2F05%2F03%2Fweb-life-cycle%2F</url>
    <content type="text"><![CDATA[当我们在浏览器地址栏输入一行url，整个页面呈现，整个过程发生了什么？我大致把整个过程分为两个部分，即网络行为与页面周期。浏览器缓存 —&gt; DNS —&gt; TCP连接 –&gt; HTTP请求/响应 —&gt; 构建页面 —&gt; 事件处理 网络行为浏览器缓存机制浏览器和服务器是应答模式，即：浏览器发起HTTP请求 —&gt; 服务器返回响应。如果是第一次发起请求，浏览器会根据拿到的HTTP响应头的配置来决定是否缓存此次的响应结果。过程如下：1. 浏览器每次发起HTTP请求时，都会根据请求去浏览器缓存中匹配对应的请求结果和缓存标识。2. 浏览器每次成功获取到请求结果，都会将请求结果和缓存标识存入浏览器缓存。根据浏览器是否需要向服务器重新发起HTTP请求，将缓存过程分为了两部分：强制缓存与协商缓存 强制缓存概念强制缓存就是向浏览器缓存查找对应的请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。 场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求如果浏览器缓存中不存在对应的缓存结果和缓存标识，那么浏览器会重新向服务器发起HTTP请求。 场景二： 存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存如果浏览器缓存中存在对应的缓存结果和缓存标识，但缓存已经失效（过期），那么浏览器会采用协商缓存。 场景三： 存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果如果浏览器缓存中存在对应的缓存结果和缓存标识且缓存尚未失效，那么浏览器缓存直接返回缓存结果。 规则强制缓存与HTTP响应头中的字段Cache-Control和Expires有关，Cache-Control优先于Expires。Cache-Control: HTTP/1.1，主要取值如下： public: 响应可以被任何缓存区（客户端、代理服务器）缓存 private: 响应只可以被客户端缓存（Cache-Control默认值） no-cache: 可以存储在本地缓存中，但需要与服务器进行验证后方可使用 no-store: 禁止缓存对响应进行复制 max-age=xxx: 缓存将在xxx秒后过期Expires: HTTP/1.0, 附加一个Expires日期首部到响应中去,这个日期为绝对日期，例如：Expires: Fri, 05 Jul 2002, 05:00:00 GMT 协商缓存概念协商缓存就是在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 场景一： 协商缓存生效，返回304如果服务器提示资源尚未失效，则返回304，浏览器可继续使用浏览器缓存中该资源的缓存结果。 场景二： 协商缓存失效，返回200如果服务器提示资源尚已失效，则返回200，服务器重新返回最新的资源，浏览器将缓存结果和缓存标识存入浏览器缓存。 规则HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象的主体。—- 《HTTP权威指南》协商缓存与HTTP头中的字段Last-Modified / If-Modified-Since（请求头）和Etag / If-None-Match(请求头)有关，Etag / If-None-Match优先级比Last-Modified / If-Modified-Since高。Last-Modified / If-Modified-Since:If-Modified-Since:Date再验证请求通常被称为IMS请求，只有某个日期之后资源发生了改变，IMS请求才会指示服务器执行请求：1.如果自指定日期后，资源更新了，If-Modified-Since条件就为真，通常GET就会执行，携带新首部（除了其他信息还有一个新的过期日期）的新资源就会返回给缓存。2.如果自指定日期后，资源未更新，If-Modified-Since条件就为假，就会向客户端返回一个小的304 Not Modified 响应报文，为了提高有效性，报文中不会包含资源的主体。例：If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMTEtag / If-None-Match 实体标签再验证:有些情况（周期性地重写、资源修改无影响的部分、有些服务器无法准确判断其页面的最后修改时间等等）下仅根据修改日期进行再验证是不够的，HTTP允许用户对被称为实体标签（Etag）的“版本标识符”进行比较。当发布者对资源进行修改时，就可以修改资源的实体标签来说明这是一个新版本。1.如果实体标签仍匹配，If-None-Match再验证成功，返回304 Not Modified。2.如果服务器上的实体标签已经发生了变化，服务器会在一个200 OK 响应中返回新的内容及相应的新Etag。例：If-None-Match: “v2.6”If-None-Match: “v2.4”, “v2.5” 浏览器的缓存放在哪里？浏览器的缓存通常存放入硬盘（from disk cache）或内存（from memory cache）。 from disk cache硬盘缓存(from disk cache)则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 from memory cache内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。时效性：一旦该进程关闭，则该进程的内存则会清空。 规则在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 缓存有什么优点？ 减少了数据的冗余传输 缓解了网络的带宽瓶颈问题 减轻了服务器的负担 减轻了距离时延 缓存与cookie缓存那些与cookie事务有关的文档时要特别小心，cookie和缓存的规则没有很好地建立起来。下面是处理缓存时的一些指导性规则： 如果无法缓存文档，要将其表示出来。如对不可缓存的文档设置：Cache-Control:no-cache=”Set-Cookie”，对可缓存的文档设置： Cache-Control:public。 缓存Set-Cookie首部要小心。如果向多个用户发送了相同的Set-Cookie首部可能会破坏用户的定位；有些缓存会在将响应缓存起来之前删除Set-Cookie首部，那么请求缓存的时候客户端就拿不到cookie了。强制缓存与原始服务器重新验证每条请求，并将Set-Cookie首部合并到客户端的响应中去，就可以改善这种情况，原始服务器可向缓存副本添加这个首部来进行这种验证：Cache-Control: must-revalidate, max-age=0 小心处理带有cookie首部的请求带有cookie的请求结果到达时，就是提示我们，这个请求结果可能是私有内容，必须将私有内容标识为不可缓存。 DNS概览DNS（Domain Name System，域名解析系统）的作用是将主机名（hostname）解析为对应的IP地址。DNS是一个由分层的DNS服务器实现的分布式数据库，一个使得主机能够查询分布式数据库的应用层协议。DNS协议运行在UDP上，使用53号端口。 常规流程 浏览器从URL中抽出主机名，将其发送给运行中的DNS应用客户端。 DNS客户端向DNS服务器发送一个带有主机名的请求。 DNS客户端会收到来自DNS服务器的回答报文，其中包含了与主机名对应的IP地址。 浏览器获取到IP地址，向位于该地址的服务器进程的某个端口（HTTP为80端口，HTTPS为443端口）发起一个TCP连接。 分布式、层次数据库DNS服务器层次结构中的DNS服务器大致有三种，根DNS服务器、顶级域DNS服务器、权威DNS服务器。根DNS服务器—&gt;顶级域DNS服务器—&gt;权威DNS服务器（自顶向下）。如果要查询www.baidu.com对应的IP地址，查询过程大致如下（分级查询）： 首先跟根服务器之一联系，获得顶级域名com的TLD服务器的IP地址。 然后TLD服务器之一联系，获得baidu.com权威服务器的IP地址。 最后与baidu.com权威服务器之一联系，获得主机名www.baidu.com对应的IP地址。 除此之外，还有一类DNS服务器很重要，即：本地DNS服务器（尽管它不在DNS服务器层次结构中）。每个ISP都有一个本地DNS服务器，当主机与该ISP连接时，ISP会返回一个IP地址，该地址具有一台或多台的本地DNS服务器的IP地址。当主机发起DNS请求时，请求被发送到本地DNS服务器，它起着代理和将请求转发到DNS服务器层次结构中（类似HTTP的代理服务器）。从请求主机到本地DNS服务器的查询是递归查询（因为查询请求是以自己的名义，查询结果直接返回给请求主机），其余为迭代查询（查询请求是以本地DNS服务器为名义，返回的结果也是给本地DNS服务器） DNS缓存为了改善实验性能并减少在因特网上到处传播的DNS报文数量，DNS广泛使用了缓存技术。在一个请求链中，当某个DNS服务器接收到一个DNS回答时，它能将该信息缓存在本地存储器中（例如，共用一个ISP的小明、小红，如果小明查询了www.baidu.com的IP地址，那么这个IP地址就存在了本地DNS服务器中，在缓存失效前，小红可以直接在本地DNS服务器中获取到www.baidu.com的IP地址）。本地服务器能够缓存顶级域服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。 TCP连接一个TCP连接是由一对端点或套接字构成，其中通信的每一端都由一对（IP地址，端口号）所唯一标识。一个TCP连接通常分为三个阶段：启动（三次握手）、数据传输、退出（四次挥手）。 三次握手概览如图所示，客户端中的TCP会用一下方式与服务器中TCP建立一条TCP连接： 第一步，客户端的TCP首先向服务器的TCP发送一个特殊的TCP报文段，该报文段不包含应用层的数据，但是在报文段的首部中的一个标志位（即SYN比特）被置为1，因此这个特殊报文段被称为SYN报文段。客户端会随机选择一个初始序号（J）并将此序号放置于该起始的TCP SYN报文段的序号字段里，整个报文字段会封装在一个IP数据报中并发给服务器。此时，客户端进入SYN-SENT状态。 第二步，一旦包含TCP SYN报文段的IP数据报到达了服务器，服务器就会从数据报中提取出TCP SYN报文段，为该TCP连接分配缓存和变量，并向客户端发送允许连接的报文段（ACK(J + 1)），该报文段也不包含应用层数据。与此同时服务器也随机选择一个初始序号（K）并将此序号放置于TCP报文段首部的序号字段中，即（SYN(K)）,随确认字段ACK一并发送给客户端。此报文字段通常被称为SYNACK报文段，此时服务器进入SYN-RECEIVED状态。 第三步，客户端接收到SYNACK报文段，为该连接分配缓存和变量，此时客户端进入ESTABLISHED状态。客户端向服务器发送另外一个报文段，这个报文段是对服务器的允许连接的报文段的确认（ACK(K + 1)），与前两次不同，这次报文段中可携带应用层数据，由于连接已经建立，SYN比特被置为0。服务器收到这个报文段后，也进入ESTABISHED状态。完成这三个步骤后，客户端和服务器的每一个报文段中都可以携带应用层的数据，且SYN比特都将被置为0。建立TCP连接的三个步骤也被称为TCP三次握手。三次握手的目的不仅在于让通信双方了解一个连接正在建立， 还在于利用数据包的选项来承载特殊的信息，交换初始序列号。——-《TCP/IP 详解 卷一：协议》 为什么是三次握手？为什么不是两次握手？三次握手：A—-&gt;B: [A: I’m A.]B—-&gt;A: [B: Hello A, I’m B.]A—-&gt;B: [A: Hello B, nice to meet you.]然后愉快的py 二次握手：A—-&gt;B: [I’m A.]B—-&gt;A: [Hello A, I’m B.]如果A收到了“Hello A,I’m B”，愉快的py如果A没有收到“Hello A,I’m B”，那么while(true){ A—-&gt;B: [I’m A.] }, 疯狂握手三次握手的目的是确认A—&gt;B, B—&gt;A这两个信道都是可靠的；如果只有两次握手就无法确认B—&gt;A的信道是否可靠。如果只需要A—&gt;B信道可靠，那就类似于UDP的需求了。 四次挥手概览连接的任何一方都可以发起关闭连接，在传统情况下往往由客户端来发起关闭连接，如下图所示。 第一步：客户端发送FIN包（包含了客户端的序列号M)，此外FIN包还包含了一个ACK段用于确认对方最后一次发送的数据。 第二步：服务器收到客户端发送的FIN包后，将M值+1作为响应的ACK值，表明它已经成功接收到来自客户端发送的FIN。此时，处于上层的应用程序会被告知连接的另一方发起了关闭连接的请求，这将导致应用程序发动自己的关闭操作。服务器从被动关闭者变为主动关闭者，向客户端发送FIN(包含了服务器的序列号N)。 第三步：为了完成连接的关闭，客户端发往服务器最后的报文段中包含了一个确认服务器发送的FIN的ACK字段。 为什么是四次挥手？四次挥手：A —&gt; B, [A: ‘我想关闭连接’]B —&gt; A, [B: ‘好的，我知道了，我不要收到你的东西了’]B —&gt; A, [B: ‘我想关闭连接’]A —&gt; B, [A: ‘好的，我知道了，我也不要收到你的东西了’]主动方发送关闭请求，被动方接受并确认请求后，被动方就无法收到主动方发送的数据了。在前两次挥手后，服务器就无法收到客户端发送的数据了（服务器释放了关于客户端的资源），但是服务器可以给客户端发送数据，所以有了第三次、第四次挥手。 页面周期概览页面构建DOM TreeStyle RulesRendering Tree事件处理参考文献： 彻底理解浏览器的缓存机制 图解TCP三次握手与四次分手 《HTTP权威指南》 《JavaScript忍者秘籍》 《计算机网络（自顶向下方法）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web缓存</tag>
        <tag>网络</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止书写回调函数并爱上ES8]]></title>
    <url>%2F2018%2F04%2F14%2Fasync-await%2F</url>
    <content type="text"><![CDATA[停止书写回调函数并爱上ES8以前，JavaScript项目会逐渐‘失去控制’，其中主要一个原因就是采用传统的回调函数处理异步任务时，一旦业务逻辑比较复杂，我们就难免书写一些冗长、复杂、嵌套的代码块（回调地狱），这会严重降低代码的可读性与可维护性。现在，JavaScript提供了一种新的语法糖来取代回调函数，使我们能够编写简明、可读性高的异步代码。 背景AJAX先来回顾一下历史。在20世纪90年代后期，Ajax是异步JavaScript的第一个重大突破。这一技术允许网站在加载HTML后获取并显示最新的数据，这是一个革命性的想法。在这之前，大多数网站会再次下载整个页面来显示更新的内容。这一技术(在jQuery中以ajax的名称流行)主导了2000-2010的web开发并且Ajax是目前网站用来获取数据的主要技术，但是XML在很大程度上取代了JSON。 NodeJS当NodeJS在2009年首次发布时，服务器端环境的主要焦点是允许程序优雅地处理并发性。大多数服务器端语言通过阻塞代码来处理I/O操作，直到操作完成为止。相反，NodeJS使用的是事件循环机制，这样开发人员可以在非阻塞异步操作完成后，调用回调函数来处理逻辑（类似于Ajax的工作方式）。 Promises几年后，NodeJS和浏览器环境中出现了一种新的标准，称为”Promise”，Promise提供了一种强大的、标准化的方式来组成异步操作。Promise仍然使用基于回调的格式，但为链式和组合异步操作提供了一致的语法。在2015年，由流行的开源库所倡导的Promise最终被添加为JavaScript的原生特性。Promise是一个不错的改进，但它们仍然常常是一些冗长而难以阅读的代码块的原因。而现在有了一个解决方案。Async/Await是一种新的语法(从.net和C#中借用)，它允许我们编写Promise，但它们看起来像是同步代码，没有回调，可以用来简化几乎任何现有的JS应用程序。Async/Await是JavaScript语言的新增的特性，在ES7中被正式添加为JavaScript的原生特性。 示例我们将通过一些代码示例来展示Async/Await的魅力 *注：运行下面的示例不需要任何库。Async/Await已经被最新版本的Chrome、FireFox、Safari、Edge完全支持，你可以在你的浏览器控制台里运行例子。Async/Await需要运行在NodeJS 7.6版本及以上，同时也被Babel、TypeScript转译器支持。所以Async/Await可以被用于实际开发之中。* 准备我们会使用一个虚拟的API类，你也可以在你的电脑上运行。这个类通过返回promise来模拟异步请求。正常情况下，promise被调用后，200ms后会对数据进行处理。12345678910111213141516171819202122232425262728293031class Api &#123; constructor () &#123; this.user = &#123; id: 1, name: 'test' &#125; this.friends = [ this.user, this.user, this.user ] this.photo = 'not a real photo' &#125; getUser () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.user), 200) &#125;) &#125; getFriends (userId) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.friends.slice()), 200) &#125;) &#125; getPhoto (userId) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.photo), 200) &#125;) &#125; throwError () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('Intentional Error')), 200) &#125;) &#125;&#125; 每个示例依次执行如下三个操作： 获取一个用户的信息，获取该用户的朋友， 获取该用户的照片。在最后，我们会在控制台中打印这些结果。 方法一 — Nested Promise Callback Functions使用嵌套的promise回调函数12345678910111213function callbackHell () &#123; const api = new Api() let user, friends api.getUser().then(function (returnedUser) &#123; user = returnedUser api.getFriends(user.id).then(function (returnedFriends) &#123; friends = returnedFriends api.getPhoto(user.id).then(function (photo) &#123; console.log('callbackHell', &#123; user, friends, photo &#125;) &#125;) &#125;) &#125;)&#125; 对于任何一个从事过JavaScript项目开发的人来说，这个代码块非常熟悉。非常简单的业务逻辑，但是代码却是冗长、深嵌套，并且以这个结尾…..1234 &#125;) &#125;) &#125;)&#125; 在真实的业务场景中，每个回调函数可能更复杂，代码块会以一堆充满层次感的})为结尾。“回调函数里面嵌套着回调函数嵌套着回调函数”，这就是被传说中的“回调地狱”（“回调地狱”的诞生不只是因为代码块的混乱，也源于信任问题。）。更糟糕的是，我们为了简化，还没有做错误处理机制，如果加上了reject……细思极恐 方法二 — Promise Chain让我们优雅起来12345678910111213141516function promiseChain () &#123; const api = new Api() let user, friends api.getUser() .then((returnedUser) =&gt; &#123; user = returnedUser return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; friends = returnedFriends return api.getPhoto(user.id) &#125;) .then((photo) =&gt; &#123; console.log('promiseChain', &#123; user, friends, photo &#125;) &#125;)&#125; Promise有一个很棒的特性：Promise.prototype.then()和Promise.prototype.catch()返回Promise对象，这就使得我们可以将这些promise连接成一个promise链。通过这种方法，我们可以将这些回调函数放在一个缩进层次里。与此同时，我们使用了箭头函数简化了回调函数声明。对比之前的回调地狱，使用promise链使得代码的可读性大大提高并且拥有着更好的序列感，但是看起来还是非常冗长并且有一点复杂。 方法三 — Async/Await我们可不可以不写回调函数？就写7行代码能解决吗？1234567async function asyncAwaitIsYourNewBestFriend () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) console.log('asyncAwaitIsYourNewBestFriend', &#123; user, friends, photo &#125;)&#125; 优雅多了，调用await之前我们会一直等待，直到promise被决议并将值赋值给左边的变量。通过async/await，我们可以对异步操作流程进行控制，就好像它是同步代码。 注：await必须搭配async一起使用，注意上面的函数，我们将关键字async放在了函数的声明前，这是必需的。稍后，我们会深入讨论这个问题 循环Async/Await可以让以前很多复杂的代码变得简明。举个例子，如果我们要按序检索每个用户的朋友的朋友列表。 方法一 — Recursive Promise Loop下面是使用传统的promise来按序获取每个朋友的朋友列表1234567891011121314151617181920function promiseLoops () &#123; const api = new Api() api.getUser() .then((user) =&gt; &#123; return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; const getFriendsOfFriends = (friends) =&gt; &#123; if (friends.length &gt; 0) &#123; let friend = friends.pop() return api.getFriends(friend.id) .then((moreFriends) =&gt; &#123; console.log('promiseLoops', moreFriends) return getFriendsOfFriends(friends) &#125;) &#125; &#125; return getFriendsOfFriends(returnedFriends) &#125;)&#125; 我们创建在promiseLoops中创建了一个函数用于递归地去获取朋友的朋友列表。这个函数体现了函数式编程，但是对于这个简单的任务而言，这依旧是一个比较复杂的解决方案。 方法二 — Async/Await For-Loop让我们尝试一下Async/Await12345678910async function asyncAwaitLoops () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) for (let friend of friends) &#123; let moreFriends = await api.getFriends(friend.id) console.log('asyncAwaitLoops', moreFriends) &#125;&#125; 不需要写递归promise闭包，只需要使用一个for循环就能解决我们的问题。 并行一个一个地去获取朋友的朋友的列表看起来有点慢，为什么不并行处理请求呢？我们可以用async/await来处理并行任务吗？当然12345678async function asyncAwaitLoopsParallel () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const friendPromises = friends.map(friend =&gt; api.getFriends(friend.id)) const moreFriends = await Promise.all(friendPromises) console.log('asyncAwaitLoopsParallel', moreFriends)&#125; 为了并行请求，我们使用了一个promise数组并将它传递给方法Promise.all()，Promise.all()会返回一个promise，一旦所有的请求完成就会决议。 错误处理然而，在异步编程中有一个主要的问题还没解决：错误处理。在异步操作中，我们必须为每个操作编写单独的错误处理回调，在调用栈的顶部去找出正确的报错位置可能很复杂，所以我们得在每个回调开始时就去检查是否抛出了错误。所以，引入错误处理后的回调函数会比之前复杂度成倍增加，如果没有主动定位到报错的位置，这些错误甚至会被“吞掉”。现在，我们给之前的例子添上错误处理机制。为了测试错误处理机制，我们将在真正获取到用户图片之前使用抽象类里的api.throwError()方法。 方法一 — Promise Error Callbacks让我们看看最坏的情况123456789101112131415161718192021222324function callbackErrorHell () &#123; const api = new Api() let user, friends api.getUser().then(function (returnedUser) &#123; user = returnedUser api.getFriends(user.id).then(function (returnedFriends) &#123; friends = returnedFriends api.throwError().then(function () &#123; console.log('Error was not thrown') api.getPhoto(user.id).then(function (photo) &#123; console.log('callbackErrorHell', &#123; user, friends, photo &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;)&#125; 代码除了又长又丑陋以外，代码操作流也不直观，不像同步、可读性高的代码那样从上往下。 方法二 — Promise Chain “Catch” Method我们可以给promise链添加catch方法来改善一些1234567891011121314151617181920212223function callbackErrorPromiseChain () &#123; const api = new Api() let user, friends api.getUser() .then((returnedUser) =&gt; &#123; user = returnedUser return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; friends = returnedFriends return api.throwError() &#125;) .then(() =&gt; &#123; console.log('Error was not thrown') return api.getPhoto(user.id) &#125;) .then((photo) =&gt; &#123; console.log('callbackErrorPromiseChain', &#123; user, friends, photo &#125;) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)&#125; 看起来好多了，我们通过给promise添加一个错误处理取代了之前给每个回调函数添加错误处理。但是，这还是有一点复杂并且我们还是需要使用一个特殊的回调来处理异步错误而不是像对待正常的JavaScript错误那样处理它们。 方法三 — Normal Try/Catch Block我们可以做得更好123456789101112131415async function aysncAwaitTryCatch () &#123; try &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) await api.throwError() console.log('Error was not thrown') const photo = await api.getPhoto(user.id) console.log('async/await', &#123; user, friends, photo &#125;) &#125; catch (err) &#123; console.error(err) &#125;&#125; 我们将异步操作放进了处理同步代码的try/catch代码块。通过这种方法，我们完全可以像对待同步代码的一样处理异步代码的错误。代码看起来非常简明 组合我在前面提及了任何以async的函数可以返回一个promise。这使得我们可以真正轻松地组合异步控制流举个例子，我们可以重新整理前面的例子，将获取数据和处理数据分开。这样我们就可以通过调用async函数获取数据。12345678910111213async function getUserInfo () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) return &#123; user, friends, photo &#125;&#125;function promiseUserInfo () &#123; getUserInfo().then((&#123; user, friends, photo &#125;) =&gt; &#123; console.log('promiseUserInfo', &#123; user, friends, photo &#125;) &#125;)&#125; 更棒的是，我们可以在数据接受函数里使用async/await，这将使得整个异步模块更加明显。如果我们要获取前面10个用户的数据呢？1234567async function getLotsOfUserData () &#123; const users = [] while (users.length &lt; 10) &#123; users.push(await getUserInfo()) &#125; console.log('getLotsOfUserData', users)&#125; 并发呢？并且加上错误处理呢？123456789async function getLotsOfUserDataFaster () &#123; try &#123; const userPromises = Array(10).fill(getUserInfo()) const users = await Promise.all(userPromises) console.log('getLotsOfUserDataFaster', users) &#125; catch (err) &#123; console.error(err) &#125;&#125; 结论随着SPA的兴起和NodeJS的广泛应用，对于JavaScript开发人员来说，优雅地处理并发性比以往任何时候都要重要。Async/Await缓解了许多因为bug引起且已经影响JavaScript很多年的控制流问题，并且使得代码更加优雅。如今，主流的浏览器和NodeJS都已经支持了这些语法糖，所以现在是使用Async/Await的最好时机。 原文链接：https://blog.patricktriest.com/what-is-async-await-why-should-you-care/掘金地址：https://juejin.im/post/5ad1cab8f265da238a30e137]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Nginx反向代理跨域]]></title>
    <url>%2F2018%2F04%2F08%2FCross-Origin-using-Nginx%2F</url>
    <content type="text"><![CDATA[由于项目前后端分离且后端真实接口已出，所以我开发时首先考虑通过跨域获取真实接口数据配合前端开发。（赶工期啊：）根据create-react-app官方提示，在package.json中添加字段&quot;proxy&quot;: &quot;http://admin.xiaoyaoeden.top&quot;emmm🤭无效 😂所以改为使用Nginx反向代理跨域😊current origin：http://localhost:3000target origin：http://admin.xiaoyaoeden.top 安装brew install nginx 修改配置首先进入nginx的配置文件 vim /usr/local/etc/nginx/nginx.conf 增加如下一个server 12345678910111213server &#123; listen 3001; server_name localhost; location / &#123; proxy_pass http://localhost:3000; &#125; location /api/ &#123; add_header Access-Control-Allow-Origin *; proxy_pass http://admin.xiaoyaoeden.top; &#125; &#125; 重启Nginx服务1nginx -s reload 测试打开localhost:3001，跨域问题解决了，现在可以开开心心的测试接口啦]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的类型（二）———— 强制类型转换]]></title>
    <url>%2F2018%2F02%2F15%2Ftype-juggling%2F</url>
    <content type="text"><![CDATA[引入JavaScript中的强制类型转换经常让人诟病，但是也并非一无是处。将值从一种类型转换成另一种类型称为类型转换，隐式转换称为强制类型转换；与此同时也有另外一种区分方式，类型转换发生在静态语言编译阶段而强制类型发生在动态语言的运行时。在JavaScript中，统称为强制类型转换，显隐之分多取决于编码者是否知道转换的效果和副作用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“工作室招新页面项目”实践中遇到的问题（一）———— React组件通信]]></title>
    <url>%2F2018%2F02%2F13%2FReact-Problem-1%2F</url>
    <content type="text"><![CDATA[最近学了React基础知识，所以有打算做一个项目来踩坑，恰好适逢大二寒假并且工作室恰好需要在开学后招新，所以天时地利人和，我就用React作为这个项目的技术栈。于是项目开发中的第一个问题就诞生了————React组件通信 问题来源material-ui中的组件AppBar和Drawer之间的通信，二者为兄弟组件。 AppBar组件 Drawer组件 功能需求： 我需要点击AppBar的左侧的icon调出Drawer。 点击Drawer中的MenuItem跳转到其他页面 调出Drawer后点击非Drawer组件后收起Drawer。 解决方案通讯是单向的，数据必须是由一方传到另一方。 父组件与子组件的通信在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。1234567891011121314151617181920212223242526class Parent extends Component &#123; constructor() &#123; this.state = &#123; msg: '今天是情人节耶' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Child msg=&#123;this.state.msg&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;p&gt;this.props.msg&lt;/p&gt; ) &#125;&#125; 子组件与父组件的通信子组件向父组件通信，同样需要父组件向子组件传递props，不过这次是传递的是以父组件自身为作用域的函数，子组件负责调用，将要传递的信息传入函数中，作为参数，传递到父组件的作用域中。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Parent extends Component &#123; constructor() &#123; this.state = &#123; msg: '今天是情人节耶' &#125;; this.transferMsg = this.transferMsg.bind(this); &#125; componentDidMount() &#123; console.log(this.state.msg); &#125; componentDidUpdate() &#123; console.log(this.state.msg); &#125; transferMsg(msg) &#123; this.setState(&#123; msg: msg &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;Child transferMsg=&#123;this.transferMsg&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); this.msg = '我也喜欢你'; &#125; componentDidMount() &#123; this.props.transferMsg(this.msg); &#125; render() &#123; return ( &lt;p&gt;情人节啊&lt;/p&gt; ) &#125;&#125; 兄弟组件之间的通信因为AppBar和Drawer为兄弟组件，它们的共同点是拥有一个相同的父组件。先看看组件结构：1234&lt;Nav&gt; &lt;AppBar /&gt; &lt;Drawer /&gt;&lt;/Nav&gt; 所以我们可以将父组件Nav作为中转站，AppBar传递信息给Nav，Nav再将信息传递给Drawer;Drawe传递信息给AppBar与此类似。解决方案如下，我们将Drawer的开关状态放在了Nav的state中，声明了更改open值的transferMsg函数，然后将这个函数分别传递个NavBar和Drawer，这样以来真正控制open的值就是NavBar和Drawer组件。具体实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Nav extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; open: false &#125; this.transferMsg = this.transferMsg.bind(this); &#125; transferMsg() &#123; this.setState(&#123; open: !this.state.open &#125;); &#125; render() &#123; return ( &lt;nav&gt; &lt;NavBar transferMsg=&#123;this.transferMsg&#125;/&gt; &lt;NavDrawer msg=&#123;this.state.open&#125; transferMsg=&#123;this.transferMsg&#125; /&gt; &lt;/nav&gt; ); &#125;&#125;class NavBar extends Component &#123; constructor(props) &#123; super(props); this.handleMenuClick = this.handleMenuClick.bind(this); &#125; handleMenuClick(event) &#123; this.props.transferMsg(); &#125; render() &#123; return ( &lt;AppBar title="CTG Club" iconClassNameRight="mudiocs-icon-navigation-expand-more" onLeftIconButtonClick=&#123;this.handleMenuClick&#125; /&gt; ); &#125;&#125;class NavDrawer extends Component &#123; constructor(props) &#123; super(props); this.handleToggle= this.handleToggle.bind(this); this.handleClose = this.handleClose.bind(this); &#125; handleToggle() &#123; this.props.transferMsg(); &#125; handleClose() &#123; this.props.transferMsg(); &#125; render() &#123; return ( &lt;Drawer docked=&#123;false&#125; width=&#123;200&#125; open=&#123;this.props.msg&#125; onRequestChange=&#123;this.handleToggle&#125; &gt; &lt;/Drawer&gt; ) &#125;&#125; 这个项目中的问题迎刃而解。这代码结构，仿佛还有一点东西。 发布者-订阅者模式定义发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。 ####运用1.发布-订阅者模式可以广泛应用于异步编程，只是一种替代回调函数的方案。2。发布-订阅者模式可以取代对象之间硬编码的通知机制，一个对象不再显式调用另一个对象的某个接口，让两个对象松耦合地联系在一起。（这一点就可以上述的解决方案的不足的地方） 实例最近一年重庆房价蹭蹭往上涨，小明迫于家里的压力，打算在解放碑买置一套总价200万的三居室。小明到了售楼处才发现心仪的房子已经被别人买了，不过后续还有一些尾房推出，但是开发商也不清楚什么时候推出这些尾房。于是售楼MM记下了小明的电话，答应他尾房一旦推出就打电话给他。后续小码也留了号码，每天等着售楼MM的电话。这就是一个典型的发布-订阅者模式的例子，逻辑代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//把发布—订阅的功能提取出来，放在一个单独的对象内:const event = &#123; clientList: [], listen(key, fn) &#123; if (!this.clientList[key]) &#123; //如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表 &#125;, trigger(...message) &#123; let key = Array.prototype.shift.call(message), //取出消息类型 fns = this.clientList[key]; //取出该消息对应的回调函数集合 if (!fns || fns.length === 0) &#123; //如果没有订阅该消息，则返回 return false; &#125; for (let i = 0, fn = fns[i++]; ) &#123; fn.apply(this, message); //message是发布消息时附送的参数 &#125; &#125;, remove(key, fn) &#123; let fns = this.clientList[key]; if (!fns) &#123; // 如果 key 对应的消息没有被人订阅，则直接返回 return false; &#125; if (!fn) &#123; //// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (let i = fns.length - 1; i &gt;= 0; i--) &#123; // 反向遍历订阅的回调函数列表 let _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); // 删除订阅者的回调函数 &#125; &#125; &#125;; &#125;&#125;;//再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能:const installEvent = function (obj) &#123; for (let i in event) &#123; obj[i] = event[i]; &#125;&#125;;const salesOffices = &#123;&#125;;installEvent(salesOffices);salesOffices.listen('squareMeter88', fn1 = function (price) &#123; console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter88', fn2 = function (price) &#123; console.log('价格= ' + price);&#125;);salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅// 小明订阅消息// 小红订阅消息salesOffices.trigger('squareMeter88', 2000000); // 输出:2000000 对于此项目中问题的解决方案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/*on、one：on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。trigger：trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。off：用于解除所有订阅了某个事件的所有函数。*/const eventProxy = &#123; onObj: &#123;&#125;, oneObj: &#123;&#125;, on: function(key, fn) &#123; if (this.onObj[key] === undefined) &#123; this.onObj[key] = []; &#125; this.onObj[key].push(fn); &#125;, one: function(key, fn) &#123; if (this.oneObj[key] === undefined) &#123; this.oneObj[key] = []; &#125; this.oneObj[key].push(fn); &#125;, off: function(key) &#123; this.onObj[key] = []; this.oneObj[key] = []; &#125;, trigger: function(...args) &#123; let key; if (args.length === 0) &#123; return false; &#125; key = args[0]; args = [].concat(Array.prototype.slice.call(args, 1)); if (this.onObj[key] !== undefined &amp;&amp; this.onObj[key].length &gt; 0) &#123; for (let i in this.onObj[key]) &#123; this.onObj[key][i].apply(null, args); &#125; &#125; if (this.oneObj[key] !== undefined &amp;&amp; this.oneObj[key].length &gt; 0) &#123; for (let i in this.oneObj[key]) &#123; this.oneObj[key][i].apply(null, args); this.oneObj[key][i] = undefined; &#125; this.oneObj[key] = []; &#125; &#125;&#125;;const BranchItemDatas = [ &#123; name: 'Web研发部', imgUrl: null, imgTitle: null, intro: null, key:1 &#125;, &#123; name: '移动开发部', imgUrl: null, imgTitle: null, intro: null, key: 2 &#125;, &#123; name: '视觉设计部', imgUrl: null, imgTitle: null, intro: null, key: 3 &#125;, &#123; name: '产品运营部', imgUrl: null, imgTitle: null, intro: null, key: 4 &#125;, &#123; name: '运维安全部', imgUrl: null, imgTitle: null, intro: null, key: 5 &#125;];class Nav extends Component &#123; render() &#123; return ( &lt;nav&gt; &lt;NavBar /&gt; &lt;NavDrawer /&gt; &lt;/nav&gt; ); &#125;&#125;class NavBar extends Component &#123; constructor(props) &#123; super(props); this.handleMenuClick = this.handleMenuClick.bind(this); &#125; handleMenuClick() &#123; eventProxy.trigger('open', true); &#125; render() &#123; return ( &lt;AppBar title="CTG Club" onLeftIconButtonClick=&#123;this.handleMenuClick&#125; /&gt; ); &#125;&#125;class NavDrawer extends Component &#123; constructor(props) &#123; super(props); this.handleToggle = this.handleToggle.bind(this); this.handleClose = this.handleClose.bind(this); this.state = &#123; open: false &#125; &#125; handleToggle() &#123; this.setState(&#123; open: !this.state.open &#125;) &#125; handleClose() &#123; this.setState(&#123; open: false &#125;) &#125; componentDidMount() &#123; eventProxy.on('open', () =&gt; &#123; this.setState(&#123; open: true &#125;); &#125;); eventProxy.on('close', () =&gt; &#123; this.setState(&#123; open: false &#125;); &#125;); &#125; render() &#123; return ( &lt;Drawer docked=&#123;false&#125; width=&#123;200&#125; open=&#123;this.state.open&#125; onRequestChange=&#123;this.handleToggle&#125; &gt; &lt;MenuItems /&gt; &lt;/Drawer&gt; ) &#125;&#125;class MenuItems extends Component &#123; handleMenuItemClick() &#123; eventProxy.trigger('close', false); &#125; render() &#123; return ( &lt;ul className='normal-list'&gt; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;0&#125;&gt;首页&lt;/MenuItem&gt; &#123;BranchItemDatas.map((item) =&gt; &#123; return ( &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;item.key&#125;&gt;&#123;item.name&#125;&lt;/MenuItem&gt; ); &#125;)&#125; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;6&#125;&gt;关于CTG&lt;/MenuItem&gt; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;7&#125;&gt;联系我们&lt;/MenuItem&gt; &lt;/ul&gt; ) &#125;&#125; 关于参考书籍或博文：《JavaScript设计模式与开发实践》“React 组件间通讯”————淘宝前端团队 情人节快乐啊情人节快乐啊情人节快乐啊情人节快乐啊]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning PostCSS(一)]]></title>
    <url>%2F2018%2F02%2F07%2FpostCSS-1%2F</url>
    <content type="text"><![CDATA[引入PostCSS是目前CSS处理器中最流行的一个处理器，没有之一。它不等同于Sass、Less等预处理器，也不等同于Compass（Compass已经死了）这样的后处理器，尽管它带有Post这个英文单词。PostCSS的功能主要有两个：第一，把CSS解析成JavaScript可以操作的AST(Abstact Syntax tree,抽象语法树);第二，调用插件来处理AST并得到结果。PostCSS的强大之处在于其不断发展的插件生态。 创建变量和混合宏]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>PostCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的类型（一）———— 类型]]></title>
    <url>%2F2018%2F02%2F06%2Ftype-js%2F</url>
    <content type="text"><![CDATA[引入类型：对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。JavaScript是一门弱类型（偏向容忍隐式类型转换）语言，同时也是一门动态类型（编译的时候就知道每个变量的类型）语言。没有严格的类型的限制，使得JavaScript成为了一门特别灵活的语言，但是也带了一些麻烦，例如强制类型转换。 内置类型JavaScript中暂时有7种内置类型： 空值（null） 未定义（undefined） 布尔值（boolean） 数字（number） 字符串（string） 对象（object） 符号（symbol）通常，我们可以通过typeof操作符来查看值的类型，它会返回类型的字符串值，但是并不是这七种类型和它们的字符串值并不是一一对应。123456789101112131415//下面六种类型均有同名的字符串值与之对应,'==='会返回true。typeof undefined === 'undefined'typeof false === 'boolsean'typeof 3 === 'number'typeof '3' === 'string'typeof &#123;number: 3&#125; === 'object'typeof Symbol() === 'symbol'//对于null类型，存在一个bug（从JavaScript诞生就一直存在，以后估计也会存在），对null进行typeof操作，返回的值居然是'object'；typeof null === 'object' //truetypeof null === 'null' //false//我们需要使用复合条件来检测null值的类型：const a = null;//对于&amp;&amp;操作，如果运算符左边的值为真，则该表达式直接返回右边的值，例如 'true &amp;&amp; 3'表达式的结果为3。(!a &amp;&amp; typeof a === "object"); //true 函数函数是’object’的一个子类型，函数是一个“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。但是，对函数进行typeof操作时，返回的值可不是’object’。12typeof function()&#123;&#125; === 'object' //falsetypeof function()&#123;&#125; === 'function' //true 没错，就是’function’。看起来function就是另外一种内置类型，但是它不是。：） 值和类型变量没有类型，值才有类型JavaScript中的变量是没有类型的，只有值才具有类型，变量可以随时持有任何类型的值。前面提到过，JavaScript是一门动态弱类型的语言。例如：变量a持有的值为42，那么这个值的类型为number，并且无法直接更改42的类型（number），但可以通过强制转换将这42转换为’42’，此时值拥有的类型就为字符串（string)。 undefined and undeclared变量未持有值时为undefined，此时typeof返回’undefined’。已在作用域中声明但未赋值的比变量是undefined的，未在作用域声明过的变量是undeclared的。123let a;a; //undefinedb; //ReferenceError:b is not defined，报错 每次看到“not defined”,总以为等价于”undefined”，真让人糟心，还有更糟心的：）123let a;typeof a; //undefinedtypeof b; //undefined 一向被认为比较安全的操作符typeof也会这样闹着玩：）注：推荐一本必看的书《JavaScript语言精粹》，作者是Douglas Crockford（大神）。 安全防范机制并不是没有办法让开发人员解决’undeclared’问题，有时候通过typeof的安全防范机制（阻止报错）来检查undeclared变量不失为一个方法。当一个窗口加载多个.js文件时，这些.js文件中的代码会共享一个全局作用域，如果有重名的变量名，那么就太可怕了……减少全局变量是编写可维护的代码的基础，所有东西都应该被封装到模块或者私有/独立的命名空间里。例如：调试模式下，在debug.js声明了一个DEBUG的全局变量，把它作为调试模式的开关，在输出调试信息时我们会先判断DEBUG是否已经被声明。可是如何在程序中检查全局变量DEBUG且不会出现ReferenceError错误呢？typeof的安全防范机制就成了我们的帮手12345678//这样做是要挨Error的if (DEBUG) &#123; console.log("调试开始啰");&#125;//这样就比较安全了if (typeof DEBUG !== "undefined") &#123; console.log("调试开始啰")&#125; 不仅对于自定义的变量有用，对于内建的API也有帮助。甚至不一定要求作用域为全局，也可以用于检查我们的变量是否在宿主作用域声明过。 还有一个方法，就是检查所有全局变量是否是全局对象的属性，浏览器的全局对象是window，服务器端的全局对象为global。上述的例子我们可以这样操作：123if (window.DEBUG) &#123; //...&#125; 访问不存在的对象属性与undeclared变量不同，是不会报错的。 关于参考文献：《你不知道的JavaScript（中卷）》《JavaScript语言精粹》]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的继承方式]]></title>
    <url>%2F2018%2F02%2F03%2Finherit-in-js%2F</url>
    <content type="text"><![CDATA[引入继承是OOP的核心内容之一。JavaScript中常见继承方式为：类式继承、构造函数式继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。 类式继承类式继承，通过子类的原型prototype对父类的实例化实现。由于子类通过其原型prototype对父类实例化继承了父类，所以父类中的共有属性要是引用类型就会在子类中被所有实例共用。由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类时是无法向父类传递参数的，因而在实例化父类时无法对父类构造函数内的属性进行初始化。123456789101112131415161718//声明父类function SuperClass() &#123; this.superValue = true;&#125;//为父类添加共有方法SuperClass.prototype.getsuperValue = function() &#123; return this.superValue;&#125;//声明子类function SubClass() &#123; this.subValue = false;&#125;//继承父类（SubClass.prototype = new SuperClass();//为子类添加共有方法SubClass.prototype.getsubValue = function () &#123; return this.subValue;&#125; 构造函数式继承构造函数继承，通过在子类的构造函数作用环境中执行一次父类的构造函数来实现；由于没用涉及prototype，所以父类的原型方法不会被子类继承。要想被子类继承，就得把属性和函数放到父类的构造函数中，并且创建出来的（子类的）实例都会单独拥有一份，违背了 “代码复用”。12345678910111213141516//声明父类function SuperClass(id) &#123; //引用类型共有属性 this.books = ['JavaScript', 'html', 'css']; //值类型共有属性 this.id = id;&#125;//父类声明原型方法SuperClass.prototype.showBooks = function() &#123; console.log(this.books);&#125;//声明子类function SubClass(id) &#123; //继承父类 SuperClass.call(this, id); //将子类的变量在父类中都执行一遍，父类中是给this绑定属性的，所以通过call就使得子类继承了父类的共有属性。&#125; 组合继承组合继承，将类式继承和构造函数式继承综合，构造函数继承时执行了一遍父类的构造函数，在实现子类原型的类式继承又调用一遍父类构造函数。12345678910111213141516171819function SuperClass(name) &#123; this.name = name; this.books = ["javascript", "html", "css"];&#125;SuperClass.prototype.getName = function () &#123; return this.name;&#125;function SubClass(name, time) &#123; //构造函数式基础父类name属性 SuperClass.call(this, name); //子类新增共有属性 this.time = time;&#125;//类式继承 子类原型继承父类SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function () &#123; return this.time;&#125; 原型式继承原型式继承，借助原型prototype可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。123456789//对类式继承的封装function inheritObejct(o) &#123; //声明一个过渡函数对象 function F() &#123;&#125; //过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的一个实例， 该对象的原型继承了父对象 return new F();&#125; 基于这种在对象之间直接构建继承关系的理念，DC大神给出了上述的函数，这个inheritObject函数后来被ES5采纳，更名为Object.create()。 寄生式继承寄生式继承,对原型继承的第二次封装，并且在此过程中对继承的对象进行了拓展。123456789101112131415//声明基对象let book = &#123; name: 'js book', alikeBook: ["css book", "html book","html book"]&#125;;function createBook(obj) &#123; //通过原型继承方式创建新对象 let o = new inheritObejct(obj); //拓展新对象 o.getName = function() &#123; return name; &#125; //返回拓展后的新对象 return o;&#125; 寄生组合式继承这里的寄生继承处理的是类的原型12345678910111213141516171819202122232425262728293031function inhreitPrototype(SubClass, SuperClass) &#123; //复制一份父类的原型副本保存在变量中 let p = inheritObejct(SuperClass.prototype); //修正因为重写子类原型导致子类的constructor属性被修改 p.constructor = SubClass; //设置子类的原型 SubClass.prototype = p;&#125;//实例//定义父类function SuperClass(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;//定义父类的原型方法SuperClass.prototype.getName = function() &#123; return this.name;&#125;//定义子类function SubClass(name, time) &#123; //构造函数式继承 SuperClass.call(this,name); //子类新增属性 this.time = time;&#125;/*寄生式继承父类原型*/inhreitPrototype(SubClass, SuperClass);/*子类新增原型方法*/SubClass.prototype.getTime = function () &#123; return this.time;&#125; extend与deepCopy在JavaScript中继承是依赖于原型prototype链实现的，只有一条原型链，理论上不能继承多个父类。但是由于JavaScript是一门很灵活的语言，所以我们可是自己动手实现一个继承多对象属性的函数。 原型链定义JavaScript中每个函数都有一个指向某一对象的prototype属性，该函数被new操作符调用时会创建并返回一个对象，返回的对象中有一个指向其原型对象的proto属性，引擎在背后通过运用proto可以使得新建的对象可以调用相关原型的对象的方法和属性。原型对象本身也是对象，所以本身也包含了指向其原型的proto,由此就形成了一条链，称之为原型链。 作用如图，有了原型链，如果某个属性在对象B中而不在对象A中，我们依然可以把这个属性当作A的属性来访问。这就是继承的作用，它可以使得每个对象都能访问其继承链上的任何属性。 继承单对象属性的extend方法（针对值类型的属性）123456function extend(child, parent) &#123; for (let prop in parent) &#123; child[prop] = parent[prop]; &#125; return child;&#125; 继承多对象的属性12345678910111213function mix() &#123; let i = 1, len = arguments.length, child = arguments[0], arg; for(; i &lt; len; i++) &#123; arg = arguments[i]; for( let prop in arg) &#123; child[prop] = arg[prop]; &#125; &#125; return child;&#125; 深拷贝在JavaScript中复制一个对象的属性时，如果对象的属性为值类型则只需要简单的赋值语句即可，如果属性为引用类型，则需要依次复制该属性的属性，这里采用递归的思想解决这个问题。（如果不使用递归，则通过JSON解析解决） 为什么要这么做？当创建一个对象时，这个对象就被存储在内存中的某个物理位置，相关的变量和属性就会指向这些位置。 创建一个新对象，并让变量A指向该对象。 创建一个新变量B，并设置其与A相等，此时B和A指向了同一个对象，也就是内存中的同一个地址。 修改变量B所指的对象的color属性，将它设置为”white”,此时A.color 的值也为”white”。 再创建一个对象，然后让变量B指向这个新对象，A和B此时指向了内存中不同的位置，A、B从此再无关联。具体实现1234567891011121314function deepCopy(parent, child) &#123; child = child || &#123;&#125;; for (let prop in parent) &#123; if (parent.hasOwnProperty(prop)) &#123; if (typeof parent[prop] === 'object') &#123; child[i] = Array.isArray(parent[prop])? [] : &#123;&#125;; deepCopy( parent[prop], child); &#125; else &#123; child[prop] = parent[prop]; &#125; &#125; &#125; return child;&#125; 总结 关于参考文献：《JavaScript面向对象编程指南》《JavaScript设计模式》《你不知道的JavaScript（上卷）》]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web性能知识（一）]]></title>
    <url>%2F2020%2F02%2F04%2Fweb-performance-1%2F</url>
    <content type="text"><![CDATA[Web性能取决于：资源获取【网络I/O】 + 页面布局与渲染 【浏览器渲染原理】+ JavaScript执行【事件循环】 这是一篇讲解Web性能的文章，参考后续补上；内容都是自己的笔记 Web性能常识延迟与带宽延迟：分组从信息源发送到目的地所需的时间 带宽：逻辑或物理通信路径最大的吞吐量 延迟的构成传播延迟：消息从发送端到接收端需要的时间（传播距离/速度） 传输延迟：把消息中的比特转移到链路中所需的时间（消息长度/链路速率） 处理延迟、排队延迟 TCP构成TCP负责在不可靠的传输信道上提供可靠的抽象层 丢包重发、按序发送、拥塞控制、流量控制…. 可靠：采用TCP数据流可以确保发送的所有字节能够完整地被接收到，到达客户端的顺序也一样。 三次握手 创建一个TCP连接成本比较高，所以如何复用连接是一个性能提升点 流量控制、拥塞控制流量控制：接收端向发送端反馈自己的接受窗口大小（rwnd），避免发送端过多向接收端发送数据的机制 慢启动：以拥塞窗口大小（cwnd）来规定第一阶段向网络中发送数据的大小，避免一下子往网络中注入大量数据导致网络拥塞；cwnd的增长是以指数级增长。慢启动导致客户端和服务器之间经过几百ms才能接近最大速度，所以如何让客户端与服务器之间传输速度迅速达到最大 拥塞避免：当出现丢包时，cwnd减小1/2然后缓慢增长（倍减加增，AIMD；比例降速，PRR） min(cwnd,rwnd)的值就是发送端与接收端之间在途未确认的最大数据量 如果在途数据量超过了未确认的最大数据量，必须停下来等待对方ACK某些分组才能继续，时间取决于往返时间。 BDP（带宽延迟积）：数据链路的容量与其端到端延迟的乘积，这个结果就是任意时刻处于在途未确认状态的最大数据量 队首阻塞（HOL，Head Of Line）发送端按顺序发送数据包到接收端，接收端可以不按顺序接受数据包，但是在进行处理数据包时必须是按顺序处理，所以如果队首数据包仍未被接受端接收到 那么就会阻塞所有分组的处理。 针对TCP的优化建议优化 TCP 的最佳途径就是调整它感知当前网络状况的方式，根据它之上 或之下的抽象层的类型和需求来改变它的行为 见机行事？？？ TCP的影响 三次握手增加了整整一次RTT 慢启动被应用到每一个新连接 流量控制和拥塞控制影响所有连接吞吐量 吞吐量由当前拥塞窗口大小控制 解决方案 服务器配置调优 升级 增大TCP的初始拥塞窗口 适当考虑禁用慢启动 窗口缩放，增加最大接受窗口的大小 TCP快速打开 应用程序行为调优 减少不必要的数据 CDN，减少传输的距离 重用TCP连接 UDP的构成分组：可以用来指代任何格式化的数据块 数据报：只用来秒速那些通过不可靠的服务传输的分组，既不保证送达也不会发送失败通知（例如UDP、IP） WebRTC着眼于在浏览器中通过UDP实现原生的语音和视频实时通信，以及其他形式的P2P通信 UDP的无服务： 不保证消息交付 不保证交付顺序 不跟踪连接状态 不需要拥塞控制 UDP与网络地址转换器（NAT）NAT：解决IP重用，每个NAT设备负责维护一个包含本地IP和端口到全球唯一IP和端口的映射的表。 传输层安全SSL（Secure Sockets Layer，安全套接字层） SSL与TLS的关系：SSL3.0是网景公司专用的，IETF负责标准化SSL协议 由此诞生了TLS（Transport Layer Secure） 加密：混淆数据 身份验证：验证身份标识有效性 完整性：检测消息是否被篡改或伪造 TLS握手 TLS会话恢复在多个连接间共享协商后的安全密钥 无线网络性能搞清楚影响无线网络性能的基本原理，进而解决其他问题。 无线网络类型 个人局域网（PAN）：蓝牙、NFC、ZigBee 局域网（LAN）：IEEE 802.11（Wi-Fi） 城域网（MAN）：IEEE 802.15（WiMax） 广域网（WAN）：蜂窝（UMTS、LTE等） 无线网络性能基础信道容量即最大信息速率，与数据传输速度最直接相关的就是可用带宽与信号强度（信噪比） 香农定理：C=BW×log2 (1+S/N) C：信道容量，单位bit/s BW：可用带宽，单位Hz S：信号，单位W N：噪声，单位W Wi-Fi802.11是从以太网802.3拓展而来。 以太网处理冲突的方式 CSMA（载波侦听多路访问）：检测是否有人正在发送，如果信道忙等待，信道空闲立即发送数据 CSMA/CD（带有冲突检测的CSMA）：如果检测到冲突，双方立即停止发送数据并sleep一会随机的时间，保证发送冲突的发送到不会同步且不会同时重新发送数据。 Wi-Fi处理冲突的方式： CSMA/CA（带有冲突避免的CSMA）：每个发送方都会在自己信道空闲时发送数据以避免冲突，所以每个Wi-Fi数据帧必须明确得到接收方的确认，以确保不会发生冲突。【怎么明确得到接收方的确认？我猜先发送一个询问帧给接收方，接收方明确空闲 come on baby】 优化Wi-Fi性能在802.11n之前，只能有一个在传的数据帧且得到接收端ACK后方能传送下一个数据帧；在802.11n之后引入了新的“帧聚合”功能，支持同时发送和确认多个Wi-Fi数据帧。 优化手段： 适应可变带宽（对于音视频：自适应比特流） 适应可变的延迟时间（可以考虑切换传输方式，例如使用UDP传输的WebRTC） 移动网络 用户面单向延迟：一个分组在无线设备与无线发射塔之间单向传输的时间 无线电资源控制器（RRC）RRC：负责调度协调移动设备与无线电基站之间所有的通信连接；RRC直接影响延迟、吞吐量和设备电池的使用时间。 LTE出站数据流延迟 控制面延迟：由 RRC 协商和状态切换导致的固定的、一次性的延迟时间，从空闲到活动少于 100 ms，从休眠到活动少于 50 ms。 用户面延迟：应用的每个数据分组从设备到无线电信号塔之间都要花的固定的时间，少于 5 ms。 核心网络延迟：分组从无线电信号塔传输到分组网关的时间，因运营商而不同，一般为 30~ 100 ms。 互联网路由延迟：从运营商分组网关到公共互联网上的目标地址所花的时间，可变。 LTE入站数据流延迟 移动网络优化建议 消除周期性及无效的数据传输 轮询在移动网络中代价极高，少用 尽可能使用推送和通知 出站和入站请求应该合并和汇总 非关键性请求应该推迟到无线模块活动时进行 消除不必要的长连接 解耦用户交互与网络通信 爆发传输数据并转为空闲 把负载转移到Wi-Fi网络 优化应用的交付消除或减少不必要的网络延迟，将需要传输的数据压缩至最少 常规性能优化最佳实践 减少DNS查询 重用TCP连接 减少HTTP重定向 使用CDN 去掉不必要的资源 在客户端缓存资源 强制缓存 协商缓存 传输压缩过的资源 消除不必要的请求开销（例如HTTP cookie） 并行处理请求和响应 针对协议版本采取优化措施 参考资源]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>网络I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React新生命周期]]></title>
    <url>%2F2020%2F01%2F24%2Freact-lifecycle%2F</url>
    <content type="text"><![CDATA[新生命周期React在16.4推出了新的生命周期： 挂载调用顺序：constructor –&gt; static getDerivedStateFromProps –&gt; render –&gt; React更新DOM和refs —&gt; ComponentDidMount constructor(props)在constructor中设置state或绑定事件，如果两者都不需要则可忽略此函数。 一旦定义constructor则必须在函数内部调用super(props)。why? 通过执行super(props)语句调用Component构造函数来设置props【this.props = props】 设置state时，不能调用setState而是直接为this.state赋值。如果state中有属性依赖于props，见下面 1234567891011121314151617function Component(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125;class MyComponent extends Component &#123; constructor(props) &#123; super(props); /* 省略.... */ &#125;&#125; static getDerivedStateFromProps(props, state)此方法无权访问组件实例，只要父组件重新渲染就会触发 适用于state一直依赖于父组件传下来的props，派生state props：父组件传递下来的props state：组件的state 返回值：用来更新state的对象 避免派生状态的替代方案： 在ComponentDidUpdate中解决props变化的副作用 prop 更改时重新计算某些数据，memoization【占坑】 prop 更改时“重置”某些 state，完全受控/使用key使组件完全不受控【占坑】 你可能不需要使用派生状态 render 唯一一个必须实现的方法，纯函数 不应该在这里有交互逻辑 如果shouldComponentUpdate()返回false，则不会调用render() 返回值： React元素。 数组或fragments Portals：可以渲染组件到不同的DOM子树 字符串或数值类型，在DOM中被渲染为文本节点 布尔类型、null、undefiend，被忽略 React更新DOM和refs更新DOM就是React底层为我们做的，不用开发者去考虑，但是React更新DOM背后的算法很有趣【占坑，React Diff】 componentDidMount在组件挂载到DOM树中立即被调用 订阅、副作用切入点 调用setState会触发额外的渲染，但是渲染发生在浏览器更新屏幕前； 这就保证即使在一次事件中更新了两次state，用户也不会看见中间的状态，React在更新state时采用了批处理机制，先收集变化再批量更新。 但是，对于modals和tooltip，在渲染赖于其大小或位置的内容之前需要测量DOM节点时，将state的初始化放在compoentDidMount是必要的。 更新顺序：static getDerivedStateFromProps —&gt; shouldComponentUpdate —&gt; render —&gt; getSnapshotBeforeUpdate —&gt; React更新DOM和refs —&gt; componentDidUpdate 何时引起更新 父组件重新渲染 组件调用setState 组件调用forceUpdate shouldComponentUpdate(nextProps, nextState)性能优化点 首次渲染和forceUpdate不会调用此函数 根据下一状态的props和state来进行判断是否需要重新渲染，如果返回fasle则组件不会调用后续的方法，默认返回true。 默认情况下，当接受到newState或newProps，这个生命钩子将被调用；但是在Mounting阶段或者调用了forceUpdate时不会被调用 手写可以，PureComponent更优；PureComponent会对state、props进行浅比较 当然，手写也是阔以的，可以比较nextProps与this.props、nextState与this.state然后返回false来跳过这一次的更新。但是返回false并不会阻止子组件重新渲染（如果子组件的state变化） 不要不要不要在这里搞一些耗时的操作，例如JSON.stringify() 以后可能这个钩子返回false只是作为一个不渲染的参考而不是现在的决定 static getSnapshotBeforeUpdate(prevProps, prevState)在最近一次渲染之前调用，在更改DOM之前获取DOM的一些信息（例如滚动位置）。 返回snapshot的值（或null），返回值作为参数传递给componentDidUpdate() componentDidUpdate(prevProps, prevState, snapshot)componentDidUpdate(prevProps, prevState, snapshot)在更新发生后会立即调用。 可以在这里进行网络请求或者操作DOM。 调用setState时一定要将其包裹在一个条件判断中，如果state派生于props这会使得我们丢失当前对应的state snapshot当且仅当getSnapshotBeforeUpdate实现时存在 卸载componentWillUnmount在这个生命周期中做清理操作【清除定时器、取消订阅、取消网络请求】 Error Handling static getDerivedStateFromError static getDerivedStateFromError(error)在后代组件抛出错误时调用 在render过程中被调用，所以副作用不会被提交 componentDidCatch componentDidCatch(error, info)在后台组件抛出错误时调用 在commit阶段被调用，所以副作用会被提交； 用于错误日志之类的 其他setState异步、批量处理、state浅合并 setState(updater[,callback])，延迟合并后渲染 setState会导致重新渲染，除非shouldComponentUpdate返回false setState并不会保证state会立马改变，所以如果当前的state依赖于之前的state，可以通过回调或者componentDidUpdate（更推荐）来操作 updater: (state, props) =&gt; stateChange forceUpdate 如果render依赖于除props、state以外的数据，可以调用forceUpdate强制让组件重新渲染，这会跳过自身组件的shouldComponentUpdate（） 这个调用也会触发子组件正常更新的生命周期 一些属性类属性 defaultProps displayName 实例属性 props state 遗留的生命周期，不推荐使用 UNSAFE_componentWillMount() 在安装前调用； 这是唯一一个在SSR中被调用的生命周期 UNSAFE_componentWillReceiveProps(nextProps) 在一个已经安装后的组件接受到新的props是被调用 UNSAFE_componentWillUpdate(nextProps, nextState) 在更新前调用，should之后，did之前 setState的背后setState的机制是如何？源码层面是怎么实现的？初始化updater时，真正的updater在renderer中设置，构造函数中设置的this.updater = updater || ReactNoopUpdateQueue只是占位。 12345678910Component.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;; 可以看出，this.setState只是简单调用组件的updater的enqueueSetState方法，那么… 12345678910111213141516171819202122enqueueSetState(inst, payload, callback) &#123; const fiber = getInstance(inst); const currentTime = requestCurrentTimeForUpdate(); const suspenseConfig = requestCurrentSuspenseConfig(); const expirationTime = computeExpirationForFiber( currentTime, fiber, suspenseConfig, ); const update = createUpdate(expirationTime, suspenseConfig); update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) &#123; if (__DEV__) &#123; warnOnInvalidCallback(callback, 'setState'); &#125; update.callback = callback; &#125; enqueueUpdate(fiber, update); scheduleWork(fiber, expirationTime); &#125; 流程： 先获取组件的Fiber实例、当前时间、当前的suspense 计算得到更新组件的expirationTime 复杂，需先了解React-Fiber 根据expirationTime和suspenseConfig创建一个update 将这个update放进update队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123; // Update queues are created lazily. const alternate = fiber.alternate; let queue1; let queue2; if (alternate === null) &#123; // There's only one fiber. queue1 = fiber.updateQueue; queue2 = null; if (queue1 === null) &#123; queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); &#125; &#125; else &#123; // There are two owners. queue1 = fiber.updateQueue; queue2 = alternate.updateQueue; if (queue1 === null) &#123; if (queue2 === null) &#123; // Neither fiber has an update queue. Create new ones. queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); queue2 = alternate.updateQueue = createUpdateQueue( alternate.memoizedState, ); &#125; else &#123; // Only one fiber has an update queue. Clone to create a new one. queue1 = fiber.updateQueue = cloneUpdateQueue(queue2); &#125; &#125; else &#123; if (queue2 === null) &#123; // Only one fiber has an update queue. Clone to create a new one. queue2 = alternate.updateQueue = cloneUpdateQueue(queue1); &#125; else &#123; // Both owners have an update queue. &#125; &#125; &#125; if (queue2 === null || queue1 === queue2) &#123; // There's only a single queue. appendUpdateToQueue(queue1, update); &#125; else &#123; // There are two queues. We need to append the update to both queues, // while accounting for the persistent structure of the list — we don't // want the same update to be added multiple times. if (queue1.lastUpdate === null || queue2.lastUpdate === null) &#123; // One of the queues is not empty. We must add the update to both queues. appendUpdateToQueue(queue1, update); appendUpdateToQueue(queue2, update); &#125; else &#123; // Both queues are non-empty. The last update is the same in both lists, // because of structural sharing. So, only append to one of the lists. appendUpdateToQueue(queue1, update); // But we still need to update the `lastUpdate` pointer of queue2. queue2.lastUpdate = update; &#125; &#125; if (__DEV__) &#123; if ( fiber.tag === ClassComponent &amp;&amp; (currentlyProcessingQueue === queue1 || (queue2 !== null &amp;&amp; currentlyProcessingQueue === queue2)) &amp;&amp; !didWarnUpdateInsideUpdate ) &#123; warningWithoutStack( false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.', ); didWarnUpdateInsideUpdate = true; &#125; &#125;&#125; 根据expirationTime调度工作 了解完React-Fiber后再来填坑【占坑】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export function scheduleUpdateOnFiber( fiber: Fiber, expirationTime: ExpirationTime,) &#123; checkForNestedUpdates(); warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber); const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime); if (root === null) &#123; warnAboutUpdateOnUnmountedFiberInDEV(fiber); return; &#125; checkForInterruption(fiber, expirationTime); recordScheduleUpdate(); // TODO: computeExpirationForFiber also reads the priority. Pass the // priority as an argument to that function and this one. const priorityLevel = getCurrentPriorityLevel(); if (expirationTime === Sync) &#123; if ( // Check if we're inside unbatchedUpdates (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // Check if we're not already rendering (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) &#123; // Register pending interactions on the root to avoid losing traced interaction data. schedulePendingInteractions(root, expirationTime); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed // root inside of batchedUpdates should be synchronous, but layout updates // should be deferred until the end of the batch. performSyncWorkOnRoot(root); &#125; else &#123; ensureRootIsScheduled(root); schedulePendingInteractions(root, expirationTime); if (executionContext === NoContext) &#123; // Flush the synchronous work now, unless we're already working or inside // a batch. This is intentionally inside scheduleUpdateOnFiber instead of // scheduleCallbackForFiber to preserve the ability to schedule a callback // without immediately flushing it. We only do this for user-initiated // updates, to preserve historical behavior of legacy mode. flushSyncCallbackQueue(); &#125; &#125; &#125; else &#123; ensureRootIsScheduled(root); schedulePendingInteractions(root, expirationTime); &#125; if ( (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // Only updates at user-blocking priority or greater are considered // discrete, even inside a discrete event. (priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority) ) &#123; // This is the result of a discrete event. Track the lowest priority // discrete update per root so we can flush them early, if needed. if (rootsWithPendingDiscreteUpdates === null) &#123; rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]); &#125; else &#123; const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root); if (lastDiscreteTime === undefined || lastDiscreteTime &gt; expirationTime) &#123; rootsWithPendingDiscreteUpdates.set(root, expirationTime); &#125; &#125; &#125;&#125;export const scheduleWork = scheduleUpdateOnFiber; 为什么不是直接更新而是异步批量更新？异步批量更新的原因： 批处理更新是有益的，避免不必要的中间状态，减少不必要的DOM渲染次数有益于提高性能。 保持内部一致性，props只会在父组件重新渲染后·才会更新 增加并发update的可行性 与老生命周期的差异？为什么有新生命周期？它解决了什么问题？它存在什么问题？未来会如何发展？与老生命周期的差异 UNSAFE_componentWillReceiveProps只会在父组件重新渲染时触发，而static getDerviedStateFromProps在每次更新都会触发（父组件重新渲染、setState、forceUpdate） 还是涉及到React-Fiber 【占坑】 总结坑位有点多，后面会补上React-Fiber的原理…]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到1了解浏览器原理]]></title>
    <url>%2F2020%2F01%2F16%2Fexplore-browser%2F</url>
    <content type="text"><![CDATA[这是一篇讲解浏览器原理的文章，参考后续补上；内容都是自己的笔记 浏览器的多进程架构 chromeChrome顶层有1个Browser Process来协调其他的进程： Browser Process 负责地址栏、书签栏，前进后退等部分功能 负责浏览器底层的操作，例如读取文件/网络请求 Utility Process GPU Process 负责GPU相关 Plugin Process 负责控制一个网页用到的Plugin Render Process 负责一个Tab内关于网页呈现的所有事情【内核】 当打开的tab过多时，后续的tab会共用之前同站点的渲染进程 Site Isolation允许在同一个tab下的跨站iframe使用单独的渲染进程来处理【安全】 多进程优缺点优点： 稳定性：某一渲染进程出现问题不会影响整个浏览器 安全性&amp;sandbox：每个渲染进程拥有独立的内存空间，数据并不会共享（例如都包含一个v8） 缺点： 不同进程间的内存不共享，不同进程的内存通常需要包含相同的内容【浪费内存】 浏览器导航流程从浏览器主页前往某一网站 处理输入 输入query，浏览器利用搜索引擎进行Search Query 输入URL，浏览器导航到指定Site 开始导航： UI线程显示加载圈 network线程开始从服务器拉去数据（执行DNS查找、建立TLS等网络I/O） 读取响应 根据响应Content-Type和MIME来执行不同操作 若为text/html，将数据交给渲染进程进行渲染 若为其他媒体类型（如application/pdf），将数据交给Storage线程下载 … 为什么有了Content-Type，还需要MIME判断？因为Content-Type有可能丢失或错误，所以需要MIME检测 【安全点】，渲染进程会根据数据是否来自可信任的站点决定是否渲染 寻找渲染进程 当network线程下载数据后会通知UI线程已就绪，UI线程会寻找一个渲染进程来渲染数据 【优化点】，开始导航时就可以找到一个渲染进程以待渲染数据 完成导航 渲染进程和数据就绪后，渲染进程与浏览器进程IPC获取数据然后渲染页面 当所有onload事件执行完后，渲染进程会发送信号通知浏览器进程渲染完成，浏览器UI线程取消【加载中】 从某页面跳转到另一页面在开始上述流程时，前页面还会触发beforeunload事件 Service Worker 有些页面还拥有 Service Worker （服务工作线程），Service Worker 让开发者对本地缓存及判断何时从网络上获取信息有了更多的控制权，如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了。 值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。 当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。 如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。 参考资源浏览器内核的多线程架构浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。一个浏览器内核通常分为多个线程：GUI渲染线程、JavaScript引擎线程、定时器触发线程、事件触发线程、异步HTTP请求线程。 GUI渲染线程​ GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了。 JavaScript引擎线程​ JavaScript引擎也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。 为什么JavaScript是单线程的？答：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。 GUI 渲染线程 与 JavaScript引擎线程互斥？答：由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。 JS阻塞页面加载？答：由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 定时器触发线程​ 浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。 事件触发线程​ 当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。 异步HTTP请求线程​ 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。 深入了解JS Core原文地址：https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html JS代码被经词法分析、语法分析后生成一棵AST，ByteCodeGenerato根据AST生成字节码，js编译结束后并不会生成可执行文件存储在内存或硬盘，字节码被虚拟机JS Core逐行运行。 JSCore采用的是基于寄存器的指令集架构，有些JVM是基于栈的指令集架构； 基于寄存器的指令集架构执行效率高（操作数不用反复入栈出栈）、内存消耗大、不易于移植（虚拟寄存器需要去匹配到真实机器中CPU的寄存器） JS的GC： 参考资源浏览器渲染页面流程 渲染进程多线程架构： Main Thread：主线程，执行JavaScript代码 Worker Threads：worker线程，例如web worker、service worker等 Raster Thread：光栅线程 Compositor Thread：合成器线程 Timeout Thread：定时器线程 HTTP Thread：HTTP线程，用于异步请求 …. 渲染页面流程：Parse—&gt; Layout —&gt; Paint —&gt; Composite Parse Parse阶段将HTML转为DOM树、CSS转为Rule树 Parse分为两阶段： 词法分析【负责将输入内容分解成一个个有效标记】 语法分析【根据语言的语法规则分析文档结构，构建语法分析树】 浏览器首先解析HTML文档：解析文档就是将文档转化成为有意义的结果，可以让代码理解和使用的结构，这里解析得到的的结构通常是带变了文档结构的节点树，即DOM树。（具体的过程（编译原理）：词法分析将输入内容分解成一个个有效的标记；解析器负责根据语言的语法规则分析文档的结构，从而构建解析树；WebKit使用了创建词法分析器的Flex以及用于创建解析器的Bison。然而解析HTML并不能用常规的自上而下或自下而上的解析器进行解析，原因在于：语言的宽容本质；浏览器历来对一些常见的无效HTML用法采取包容态度；解析过程需要不断反复，源内容在解析过程中通常不会改变，但是在HTML中脚本标记如果包含了document.write就会添加额外的标记。） 解析HTML的算法：标记化、树构建。 标记化是词法分析过程，将输入内容解析成多个标记（起始标记、结束标记、属性名称、属性值），然后传递给树构造器然后接受下一个字符以识别下一个标记，直到整个输入的结束；输出HTML标记 树构建阶段的输入是来自标记化阶段的标记序列，每个标记都会被树构建器处理然后添加到DOM树和开放元素的堆栈中（用于纠正嵌套错误和未闭合的标签） CSS解析：CSS是上下文无关的语法，可以使用常规的各种解析器进行解释。 解析器将CSS文件解析成StyleSheet对象，而且每个对象都包含了CSS规则。 处理脚本和样式表的顺序： 脚本：在执行脚本时会阻塞DOM和CSS解析（因为脚本可能修改DOM和CSS），所以需将脚本置于底部或加上下述属性 defer：表示并行加载但最后执行脚本，只用于外部脚本 async：表示解析HTML其他元素时同时异步加载执行脚本，但是不知道脚本之间执行的顺序（加载完就可执行） 样式表：理论上来说，应用样式表不会更改DOM树，因此似乎没有必要等待样式表并停止文档解析。但是如果脚本在文档解析阶段会请求样式信息，如果当时还没有加载和解析样式表，脚本可能会获得一个错误的回复。 LayoutLayout阶段计算元素的尺寸、样式、位置等 在构建DOM树的同时还会构建Render树： Render树中都是可见元素（不包括dislay:none但包括visibility: hidden） 伪元素也被加入到Render树中，尽管其不在DOM树 与此同时，还需要计算每一个呈现对象的可视化属性 样式计算： 位置大小计算： 递归过程，从根元素开始，递归遍历部分或所有的结构并计算大小、位置等信息 Dirty位系统，将发生更改的render object标记为dirty，异步触发增量布局 布局的种类 全量布局：触发了整个render tree的重新布局，例如： 全局样式更改 屏幕大小调整 增量布局：对标志为dirty的render object进行重新布局 异步布局：增量布局是异步执行的 类似于任务队列，reflow命令只是被加入队列，具体的执行由调度程序控制 请求样式信息可同步触发增量布局 同步布局：全局布局往往时同步执行 Paint在绘制阶段，系统会遍历呈现树，并调用呈现元素的paint方法，将元素的内容显示到屏幕上 ，这里同样存在全局绘制和增量绘制。 Paint阶段决定按什么顺序paint元素 绘制顺序：背景颜色 -&gt; 背景图片 -&gt; 边框 -&gt; 子代 -&gt; 轮廓 Webkit矩形缓存在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。 Composite Node：DOM树中的节点 Layout Object： DOM树中的可视元素，包括伪元素 对象包含尺寸、位置样式等信息 Paint Layer： 在同一坐标空间下的Layout Objects属于同一Paint Layer Paint Layer最开始用于实现层叠上下文用于保证页面元素正确合成 Paint Layer类型： NormalPaintLayer（根元素、具有定位、透明、滤镜filter、mask属性、transform属性、） OverflowClipPaintLayer（overflow 不为 visible） NoPaintLayer（不需要paint的paint layer） 满足上面条件的拥有独立的Paint Layer，若不满足则与第一个拥有Paint Layer的元素共享Layer Graphic Layers： 某些特殊的Paint Layer会被认为是合成层，其拥有独立的GraphicsLayer； 无独立的GraphicsLayer的渲染层与第一个拥有GraphicsLayer的渲染层共享GraphicsLayer； 每个GraphicsLayer拥有一个GraphicsContext，Context负责输出该层的位图（存储在共享内存中，通过纹理上传至GPU，再由GPU将多个位图合并绘制到屏幕上） 渲染层提升为合成层 直接原因 硬件加速的 iframe 元素、硬件加速的插件 video 元素、覆盖在video 元素上的视频控制栏 3D 或者 硬件加速的 2D Canvas 元素 3D transform、backface-visibility 为 hidden 对opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等） 后代元素原因 overlap 重叠原因 优点： 合成层的位图由GPU合成，更快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，不会触发 layout 和 paint Composite技术是将页面划分成多个layer分别栅格化，然后通过composite线程合并layer进行展示，当屏幕scroll时只需要composite可视区域即可。 流程 当layout和paint顺序确定后，Main Thread将这些信息传递给Compositor Thread Compositor将每个layer划分多个tile，将其交给Raster Thread进行栅格化 Raster Thread栅格化tile并存储在GPU内存中 Compositor Thread收集栅格化完成的tile信息来创建合成帧（compositor iframe） 合成帧通过IPC传递给浏览器进程 合成帧再被传递给GPU进行绘制到屏幕上 优点由于合成不需要主线程的参与，因此合成器线程不需要等待样式计算或JS执行，所以给用户的体验更加平滑【广泛应用于动画】 响应输入流程： Browser Process最早发现用户输入，但仅知道事件类型、坐标 ；将这些事件类型和发生的坐标传递给Render Process Render Process通过事件类型和坐标找到对应的事件并触发对应事件监听器的回调 合成器相关合成器会将带有事件监听器的区域标为“Non-Fast Scrollable Region”。 一旦此区域发生输入，合成器会确保这些事件会传递给Main Thread。（合成器线程与主线程通信，花费时间/空间成本） 发生在此区域外的输入，合成器不等待主线程直接创建新的合成帧 事件冒泡机制可能导致合成器与主线程发生不必要的线程通信 合并优化连续的事件一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行。 而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发。 合成器发送输入事件给主线程当合成器线程发送输入事件给主线程时，主线程首先会进行命中测试（hit test）来查找对应的事件目标，命中测试会基于渲染过程中生成的绘制记录（ paint records ）查找事件发生坐标下存在的元素。 参考资源]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>渲染原理</tag>
        <tag>浏览器内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之树]]></title>
    <url>%2F2019%2F12%2F27%2FAlgorithms-4%2F</url>
    <content type="text"><![CDATA[算法题之树~~~~ 树的遍历题目完成二叉树的前序遍历、中序遍历、后序遍历、层序遍历 解决方案 前中后遍历可用递归解决 123456789101112131415161718function preOrder(root) &#123; if (!root) return; console.log(root.val) if (root.left) preOrder(root.left); if (root.right) preOrder(root.right);&#125;function inOrder(root) &#123; if (!root) return; if (root.left) inOrder(root.left); console.log(root.val) if (root.right) inOrder(root.right);&#125;function postOrder(root) &#123; if (!root) return; if (root.left) inOrder(root.left); if (root.right) inOrder(root.right); console.log(root.val)&#125; 后序遍历即BFS 12345678910function layerTravel(root) &#123; const queue = [] queue.push(root); while(queue.length) &#123; let node = queue.shift(); if (node.left) queue.push(node.left) if (node.right) queue.push(node.right) console.log(node.val) &#125;&#125; 重建二叉树题目给出二叉树的先序遍历和中序遍历，还原二叉树 解决方案 先序遍历序列的首节点即为树的root节点 通过root节点可以定位到根节点在中序遍历的位置，进而划分左右子树 计算出左子树的长度 若左子树长度 &gt; 0, 构建左子树 若先序序列长度 &gt; 左子树长度，构建右子树 递归计算 12345678910111213141516171819202122232425262728293031323334function buildBinaryTree(preOrder, inOrder) &#123; const length = preOrder.length; function buildBinaryTreeCore(preOrderStart, preOrderEnd, inOrderStart, inOrderEnd) &#123; const rootValue = preOrder[preOrderStart]; const root = new BinaryTree(rootValue) //只有一个节点 if (preOrderStart === preOrderEnd) &#123; if (inOrderStart === inOrderEnd &amp;&amp; preOrder[preOrderStart] === inOrder[inOrderStart]) return root; else &#123; console.log('fuck') return null; &#125; &#125; // 计算出root节点在中序遍历序列的位置 let rootPositionOfInOrder = inOrderStart; for(let i = inOrderStart; i &lt; inOrderEnd; i++) &#123; if (rootValue === inOrder[i]) &#123; rootPositionOfInOrder = i; &#125; &#125; let leftLength = rootPositionOfInOrder - inOrderStart; // 计算出左子树的长度 let leftPreOrderEnd = preOrderStart + leftLength; // 在先序序列里标记最后一个左子树节点 if (leftLength &gt; 0) &#123; root.left = buildBinaryTreeCore(preOrderStart+1, leftPreOrderEnd, inOrderStart, inOrderStart-1); &#125; if (leftLength &lt; preOrderEnd - preOrderStart) &#123; root.right = buildBinaryTreeCore(leftPreOrderEnd+1, preOrderEnd, rootPositionOfInOrder+1, inOrderEnd) &#125; return root; &#125; if (preOrder === null || inOrder === null) return null; return buildBinaryTreeCore(0, length-1, 0, length-1);&#125; 二叉搜索树的后序遍历序列二叉搜索树 若左子树非空，则左子树上的所有节点小于它的根节点值。 若右子树非空，则右子树上所有节点大于它的根节点值。 左右子树也是二叉搜索树 题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是，则返回true；若不是，返回false。 解决方案 后序遍历，末尾的数字为根节点，序列前半部分都小于根节点，序列后半部分大于根节点 只需要判断序列是否出现过 小-大-小这样的情形 出现则为非后序遍历 未出现则继续递归判断左右子树的后序遍历序列 1234567891011121314151617181920212223242526function postSequenceOfBST(seq) &#123; function postSequenceOfBSTCore(seq, start, end) &#123; if (end - start &lt;= 2) return true; let bigIndex = smallerIndex = -1; for(let i = start; i &lt; end; i++) &#123; // 如果当前节点小于根节点 if (seq[i] &lt; seq[end]) &#123; // 如果在之前节点出现过比根节点大的节点，则此树为非二叉搜索树 if (bigIndex !== -1) &#123; return false; &#125; else &#123; smallerIndex = i; &#125; &#125; else &#123; if (bigIndex === -1) bigIndex = i; &#125; &#125; debugger if (smallerIndex === -1 || bigIndex === -1) &#123; return postSequenceOfBSTCore(seq, start, end-1); &#125; else &#123; return postSequenceOfBSTCore(seq, start, bigIndex-1) &amp;&amp; postSequenceOfBSTCore(seq, bigIndex, end-1); &#125; &#125; return postSequenceOfBSTCore(seq, 0, seq.length-1);&#125; 二叉树的深度题目输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点形成树的一条路径，最长路径的长度即为树的深度 解决方案 要求二叉树的深度，即求max（左子树深度，右子树深度） + 1 递归解决 1234function deepOfTree(root) &#123; if (!root) return 0; return Math.max(deepOfTree(root.left)+1, deepOfTree(root.right)+1);&#125; 22、反转二叉树题目对一颗二叉树的每一个节点，交换它的左右子节点。 解决方案 递归调用交换左右节点即可，先交换子节点 最后交换父节点 12345678function reverse(root) &#123; if (!root) return null; if (root.left) reverse(root.left); if (root.right) reverse(root.right); let temp = root.left; root.left = root.right root.right = temp;&#125; 二叉树的下一节点题目给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点。树的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。 解决方案 若该节点有右子树，则下一节点时右子树中最左子节点 若该节点无右子树，并且此节点为父节点的左节点，则下一节点为父节点 若该节点无右子树且此节点为父节点的右节点，则下一节点为某主先节点的右子节点 12345678910111213141516171819202122function findNextTreeNode(root, node) &#123; if (!root || !node) return null; if (node.right) &#123; // 如果有右子树 let leftNode = node.right; while(true) &#123; if (leftNode.left) leftNode = leftNode.left else return leftNode; &#125; &#125; // 如果无右子树且是父节点的左节点 else if(!node.right &amp;&amp; node.parent.left === node) return node.parent; else &#123; // 无右子节点且为父节点的右节点 let parent = node.parent; while(true) &#123; if (!parent.parent) return null; if (parent === parent.parent.left) return parent.parent else parent = parent.parent &#125; &#125;&#125; 树的子结构题目输入法两棵二叉树A、B，判断B是不是A的子结构。 解决方案 首先在A中找出B的根节点所在的位置 判断B的子树是否在A中 12345678910111213141516171819function hasSubTree(treeA, treeB) &#123; if ( !treeA || !treeB) return false; let result = false; if (treeA.val === treeB.val) &#123; result = doesTreeAHasTreeB(treeA, treeB); &#125; if (!result) result = hasSubTree(treeA.left, treeB); if (!result) result = hasSubTree(treeA.right, treeB); return result;&#125;function doesTreeAHasTreeB(treeA, treeB) &#123; if (!treeB) return true; // 如果treeB为空，则直接返回true if (!treeA) return false; // 若treeA不存在，则直接返回false if (treeA.val !== treeB.val) return false; // 若首节点不同，直接返回fasle return doesTreeAHasTreeB(treeA.left, treeB.left) &amp;&amp; doesTreeAHasTreeB(treeA.right, treeB.right); // 当前节点相同，继续判断子节点&#125; 对称的二叉树题目请实现一个函数，用来判断一棵二叉树是不是对称的、如果一棵树和它的镜像相等，那么就是对此的。 解决方案 判断根节点是否为null，若是则返回true 判断左右子节点是否相等 相等则继续判断其左右子节点（递归） 都会空则返回true 不等则返回false 123456789101112function mirrorSymmetry(root) &#123; if (!root) return true; return mirrorSymmetryCore(root.left, root.right);&#125;function mirrorSymmetryCore(left, right) &#123; if (!left &amp;&amp; !right) return true; // null === null if (left &amp;&amp; right &amp;&amp; left.val === right.val) &#123; return mirrorSymmetryCore(left.left, right.right) &amp;&amp; mirrorSymmetryCore(left.right, right.left); &#125; else &#123; return false; &#125; &#125; 二叉树中和为某一值的路径题目输入一棵二叉树和一个整数，打印出二叉树中节点值和为输入整数的所有路径。从根节点开始往下一直到叶节点经过的节点形成一条路径。 解决方案 先序遍历 + dfs 如果走到叶子节点 此时经过的节点和不等于sum，则回溯到上一个节点；否则打印路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 打印所有路径function findPathEqualSum(root, sum) &#123; let current = 0; let path = []; function findPathEqualSumCore(node, sum) &#123; if (node === null) return; path.push(node.val); current += node.val; if (current === sum &amp;&amp; !node.left &amp;&amp; !node.right) &#123; console.log(path.join('-&gt;')); current = current - node.val path.pop(); &#125; if (node.left) findPathEqualSumCore(node.left, sum); if (node.right) findPathEqualSumCore(node.right, sum); path.pop(); current -= node.val; &#125; findPathEqualSumCore(root, sum)&#125;// 打印一条路径function findPathEqualSum(root, sum) &#123; let current = 0; let path = []; function findPathEqualSumCore(node, sum) &#123; let target = false; if (node === null) return false; path.push(node.val); current += node.val; if (current === sum &amp;&amp; !node.left &amp;&amp; !node.right) &#123; return true; &#125; if (node.left) target = findPathEqualSumCore(node.left, sum); if (target) return true; if (node.right) target = findPathEqualSumCore(node.right, sum); if (target) return true; path.pop(); current -= node.val; return false; &#125; findPathEqualSumCore(root, sum)&#125; 二叉搜索树的第k小节点题目给定一棵二叉搜索树，请找出其中第k大的节点。 解决方案二叉搜索树的中序遍历即为：从小到大的序列，所以根据这个特性来解决 实现一：将遍历存储在数组中 123456789101112131415function kthOfBST(root, k) &#123; let numbers = [] kthOfBSTCore(root, k) function kthOfBSTCore(root, k) &#123; if (!root) return; if (root.left) &#123; kthOfBSTCore(root.left, k--) &#125; numbers.push(root.val) if (root.right) &#123; kthOfBSTCore(root.right, k--) &#125; &#125; return numbers[k-1]&#125; 实现二：直接返回对应的数字 12345678910111213141516function kthOfBST2(root, k) &#123; if (!root || !k) return null; function kthOfBST2Core(root) &#123; let target = null; if (root.left) target = kthOfBST2Core(root.left, k); if (!target) &#123; if (k === 1) target = root; k-- &#125; if (target == null &amp;&amp; root.right) &#123; target = kthOfBST2Core(root.right, k) &#125; return target; &#125; return kthOfBST2Core(root, k);&#125; ###]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之线性数据结构]]></title>
    <url>%2F2019%2F12%2F14%2FAlgorithms-3%2F</url>
    <content type="text"><![CDATA[算法题之线性数据结构～～～ 从尾到头打印链表题目输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下： 123456class Node &#123; constructor(val) &#123; this.val = val this.next = null &#125;&#125; 解决方案 递归【栈】 12345678function listPrint(node) &#123; if (node.next) &#123; listPrint(node.next) console.log(node.val) &#125; else &#123; console.log(node.val) &#125;&#125; 用两个栈实现队列题目用两个栈实现一个队列；队列的声明如下，请实现它的两个函数appendTail、deleteHead，分别完成入队和出队操作。 12345678class Queue &#123; constructor() &#123; this.stack1 = [] this.stack2 = [] &#125; appendTail(node) &#123;&#125; deleteHead() &#123;&#125;&#125; 解决方案 两个栈，一个栈用作入队使用，一个栈用作出队使用 执行入队操作时，一律将元素push进A栈 执行出队操作时 若B栈非空，则B栈pop即可 若B栈为空，则将A栈所有元素依次出栈到B栈，此时B栈顶部元素即为需要出队的元素 12345678910111213141516171819class Queue &#123; constructor() &#123; this.stackA = [] this.stackB = [] &#125; appendTail(node) &#123; this.stackA.push(node); &#125; deleteHead() &#123; if (this.stackB.length) &#123; return this.stackB.pop(); &#125; else &#123; for(let i = 0, len = this.stackA.length; i &lt; len; i++) &#123; this.stackB.push(this.stackA.pop()) &#125; return this.stackB.pop(); &#125; &#125;&#125; 镜像题目用两个队列实现一个栈；栈的声明如下，请实现它的两个函数push、pop，分别完成入栈和出栈操作。 解决方案 非空队列作为入栈选择 【第一次入栈无要求】 当元素出栈时，将非空队列的元素（除队尾）依次入队到另一队列，队列中最后的元素即栈顶元素。 123456789101112131415161718192021222324class Stack &#123; constructor() &#123; this.queueA = [] this.queueB = [] this.flag = true // true表示往队列A入队，false表示往队列B入队，初始为true &#125; static popHelper(from, to) &#123; for (let i = 0, len = from.length; i &lt; len - 1; i++) &#123; to.push(from.shift()) &#125; return from.shift() &#125; push(node) &#123; if (this.flag) &#123; this.queueA.push(node) &#125; else &#123; this.queueB.push(node) &#125; &#125; pop() &#123; this.flag = !this.flag return this.flag ? Stack.popHelper(this.queueB, this.queueA) : Stack.popHelper(this.queueA, this.queueB) &#125;&#125; 链表中倒数第k个节点题目输入一个链表，输出链表中倒数第k个节点，链表节点定义如下： 123456class ListNode &#123; constructor(val) &#123; this.val = val this.next = null &#125;&#125; 解决方案 【遍历2次】链表长度 = 当前索引+ k值，可通过此公式求解 首先计算出链表长度n 【遍历1次】 开始新一轮链表遍历，判断k值是否等于n-索引 若k值 = n - 索引，则该节点即为所求节点 若k值 &gt; n - 索引，则无解 若k值 &lt; n - 索引，循环继续 123456789101112function kToLast(head, k) &#123; if (!head || k &lt; 1) return; let len = size(head) if (len - k &lt; 0) return; let index = 0; let current = head; while(index !== len - k) &#123; current = current.next index++ &#125; return current.val&#125; 【遍历1次】倒数第个节点与尾节点相隔k-1个节点，双指针 定义2个指针都在首节点（A、B指针） A指针先走K-1步，此时A、B指针同时前进 当A指针到达尾节点时，B指针所指指针即为倒数第k个节点 1234567891011121314151617function kToLast(head, k) &#123; if (k &lt; 1 || !head) return; let currentA = currentB = head let index = 1; while(index &lt; k &amp;&amp; currentA) &#123; currentA = currentA.next; index++; &#125; if (!currentA &amp;&amp; index &lt; k) return; while(currentA) &#123; if (currentA.next === null) &#123; return currentB.val &#125; currentA = currentA.next currentB = currentB.next &#125;&#125; 链表中环的入口节点题目如果一个链表中包含环，如何找出环的入口节点。 解决方案 指针P1、P2初始化时都指向头节点 求出链表中环中的节点数n 首先找出环中的节点，然后指针从环中任意节点前进，回到此节点时经历的节点数就是环中节点数 要找到环中的节点，需要2个指针一快一慢，二者相遇的节点就是环中的一节点 P1先走n步，然后二者同时出发，相遇的节点即为环的入口 123456789101112131415161718192021222324252627282930313233343536function getMeetingNode(head) &#123; if (!head) return null let slow = head; let fast = head.next; while(slow !== null &amp;&amp; fast !== null) &#123; if (slow === fast) return fast; slow = slow.next; fast = fast.next; if (fast) &#123; fast = fast.next &#125; &#125; return null&#125;function entryNodeOfLoop(head) &#123; let meetingNode = getMeetingNode(head); let nodesOfLoop = 0; if (head === null || meetingNode === null) return; let current = meetingNode; while(current !== null) &#123; current = current.next; nodesOfLoop++; if (current === meetingNode) break; &#125; let nodeA = head; for(let i = 0; i &lt; nodesOfLoop; i++) &#123; nodeA = nodeA.next &#125; let nodeB = head; while(nodeA !== nodeB) &#123; nodeA = nodeA.next nodeB = nodeB.next &#125; return nodeA;&#125; 反转链表题目定义一个函数，输入一个链表的头节点后，反转该链表并输出反转后的链表头节点。链表节点定义如下： 123456class ListNode &#123; constructor(val) &#123; this.val = val this.next = null &#125;&#125; 解决方案 中间节点进行处理时，首先要保留指向下一节点的引用 next：保存指向下一节点的引用 prev：指向上节点的引用 12345678910111213141516function reverseList(head) &#123; if (!head) return null; let reverseHead = null; let current = head; let prev = null; while(current) &#123; let next = current.next // 保留指向下一节点的引用 if (!current.next) reverseHead = current // 如果后面没有节点，则此节点就是尾节点 current.next = prev // 当前节点指向之前的节点，首节点指向null prev = current // 将之前的节点引用指向当前节点 current = next // 前进到下一节点 &#125; head.next = null; return reverseHead;&#125; 删除链表节点题目（一）在O(1)时间内删除链表节点给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。链表节点与函数的定义如下 1234567class ListNode &#123; constructor(val) &#123; this.val = val this.next = null &#125;&#125;function deleteNode(head, nodeToBeDeleted) &#123;&#125; 解决方案 如果参数存在null，返回 【O(1)】 链表中有多个节点，删除尾节点：需寻找到倒数第二节点然后进行删除操作 【O(n)】 如果删除的不是尾节点，直接将被删除节点的下一个节点赋值到本节点【O(1)】 链表只有一个节点，直接将头指针设置为null【O(1)】 综合起来：算法时间复杂度O(1) 123456789101112131415function deleteNode(head, nodeToBeDeleted) &#123; if (!nodeToBeDeleted || !head) return; // 如果删除的不是尾节点，当前节点直接改为下一节点，，O(1) if (nodeToBeDeleted.next) &#123; nodeToBeDeleted.val = nodeToBeDeleted.next.val nodeToBeDeleted.next = nodeToBeDeleted.next.next &#125; else &#123; // 如果被删除节点是尾节点, O(n) let current = head while(current.next !== nodeToBeDeleted) &#123; current = current.next &#125; current.next = null &#125;&#125; 题目（二）删除链表中重复的节点在一个排序的链表中，如何删除重复的节点？ 解决方案 判断当前节点与下一节点是否相同，若相同则删除下一节点，继续向前 若当前节点为尾节点，则删除完毕 1234567891011121314function deleteRepeatNode(head) &#123; if (head === null) return; let current = head; while(current !== null) &#123; if (current.next) &#123; if (current.val === current.next.val) &#123; current.next = current.next.next current = current.next &#125; else &#123; current = current.next &#125; &#125; &#125;&#125; 两个链表的第一个公共节点题目输入两个链表，找出他们的第一个公共节点 解决方案 蛮力法，不推荐 解决方法二：时间O(n+m)，空间O(m+n)【从尾比较】 开辟两个栈，分别存储两个链表的元素 将两个链表的元素分别入栈 栈顶即为两个链表末尾节点，依次出栈 当栈顶元素不等时，上一个节点即为第一个公共节点 解决方法二：时间O(n+m)，空间O(1) 计算出两个链表之间的长度差异n 长链表先走n步，然后二者同时走 相同的节点即为第一个公共节点 12345678910111213141516171819202122232425262728293031function findPublicNode(listA, listB) &#123; if (listA === null || listB === null) return null; let currentA = currentB = null; let lenA = lenB = 0; let diff = 0; while(currentA) &#123; lenA++; currentA = currentA.next; &#125; while(currentB) &#123; lenB++; currentB = currentB.next; &#125; let diff = lenA - lenB; currentA = listA; currentB = listB; if (diff &gt; 0) &#123; // list A更长 while(diff-- &gt; 0) currentA = currentA.next &#125; else if (diff === 0) &#123; diff = Math.abs(diff); while(diff-- &gt; 0) currentB = currentB.next &#125; else &#123; return listA; &#125; while(currentA &amp;&amp; currentB) &#123; if (currentA === currentB) return currentA; &#125; return null&#125; 合并两个排序的链表题目输入两个递增排序的链表，合并这两个链表并使得新链表中的节点仍然是递增排序的。 解决方案迭代 or 递归 时间复杂度O(n+m)，空间复杂度O(n+m) 两个链表首节点之间最小元素即为新链表的首节点。 循环遍历比较两个链表的节点，二者小的加入新链表。 当遍历完一个链表时，只需将另一链表剩余的节点一次添加进新链表即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function mergetList(listA, listB) &#123; if (!listA) return listB; if (!listB) return listA; if (!listA || !listB) return null; let currentA = listA; let currentB = listB; let listC = null; let currentC = listC; while(currentA &amp;&amp; currentB) &#123; if (currentA.val &lt;= currentB.val) &#123; if (!listC) &#123; listC = new ListNode(currentA.val); currentC = listC; &#125; else &#123; let node = new ListNode(currentA.val); currentC.next = node; currentC = currentC.next; &#125; currentA = currentA.next; &#125; else &#123; if (!listC) &#123; listC = new ListNode(currentB.val); currentC = listC; &#125; else &#123; let node = new ListNode(currentB.val); currentC.next = node; currentC = currentC.next; &#125; currentB = currentB.next; &#125; &#125; while(currentA) &#123; let node = new ListNode(currentA.val); currentC.next = node; currentC = currentC.next; currentA = currentA.next; &#125; while(currentB) &#123; let node = new ListNode(currentB.val); currentC.next = node; currentC = currentC.next; currentB = currentB.next; &#125; return listC;&#125; 包含min函数的栈题目定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push、pop的时间复杂度都是O(1) 解决方案 定义两个栈，一个数据栈用来储存元素，另一个栈为辅助栈（储存每次元素入栈时的最小元素） 入栈时，元素直接入数据栈，除此之外： 若元素大于min，将min压入辅助栈 若元素不大于min，则元素压入辅助栈 出栈时：弹出数据栈和辅助栈 栈顶元素 执行min操作时 直接返回辅助数组首元素 1234567891011121314151617181920212223242526272829303132class Stack &#123; constructor() &#123; this.top = null; this.length = 0; this.mins = [] &#125; push(val) &#123; let node = new Node(val); if (!this.top) &#123; this.top = node; this.mins.push(node) &#125; else &#123; if (this.mins[0].val &gt;= node.val) &#123; this.mins.unshift(node) &#125; else &#123; this.mins.push(this.mins[0]) &#125; node.next = this.top; this.top = node; &#125; &#125; pop() &#123; let top = this.top if (this.pop === null) return null this.mins.pop() this.top = this.top.next return top &#125; min() &#123; return this.mins[0] &#125;&#125; 栈的压入、弹出序列题目输入两个整数序列，第一个序列表示出栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相同，例如，序列「1，2，3，4，5」是某栈的压栈序列，序列「4，5，3，2，1」是该压栈序列对应的一个弹出序列，但「4，3，5，1，2」就不可能是该压栈序列的弹出序列。 解决方案 定义一个辅助栈 若弹出序列的首元素与辅助栈栈顶元素相同，则弹出序列索引后移同时辅助栈弹出栈顶 若不同，则将入栈序列首元素压入辅助栈中，直到辅助栈栈顶元素与弹出序列首元素相同； 若压入序列都已入栈，辅助栈栈顶元素与弹出序列元素仍不同，则该弹出序列不是该压栈序列的弹出序列 123456789101112131415161718function judgeStackSequence(pushSequence = [], popSequence = []) &#123; // 如果栈顶就是待出栈序列元素，则直接出栈 // 若栈顶不是待出栈序列元素，则将待入栈序列元素入栈，直到待出栈元素入栈 // 若入栈序列全部入栈，仍栈顶仍不是出栈序列待出栈序列，则判断出栈序列不是该入栈序列的弹出序列 let stack = []; if (!pushSequence.length || !popSequence) return false; while(popSequence.length) &#123; console.log(stack[stack.length-1], popSequence[0]) if (stack[stack.length-1] === popSequence[0]) &#123; popSequence.shift() stack.pop() &#125; else &#123; if (!pushSequence.length) break; stack.push(pushSequence.shift()) &#125; &#125; return popSequence.length ? false : true;&#125; 复杂链表的复制题目请实现函数clone，复制一个复杂链表。在复杂链表中，每个节点除了有一个next指针指向下一节点，还有一个bibling指针指向链表中的人一节点或null。节点的定义如下 1234567class ComplexListNode &#123; constructor(val = 0) &#123; this.val = val this.next = null this.sibling = null &#125;&#125; 解决方案 复制节点链接在原节点后，最后拆分链表【时间O(n)】 复制节点：遍历原节点，将复制节点作为原节点下一节点 调整sibling：遍历原节点，将原节点的sibling的下一节点设置为复制节点的sibling 拆分链表：奇数节点拼接起来就是原链表，偶数节点拼接起来就是新链表 123456789101112131415161718192021222324252627282930313233function cloneComplexList(head) &#123; if (!head) return null; let current = head; while(current) &#123; let node = new ComplexListNode(current.val); node.next = current.next current.next = node; current = current.next.next; &#125; current = head; while(current) &#123; if (current.sibling) &#123; current.next.sibling = current.sibling.next; &#125; current = current.next.next; &#125; current = head; let cloned = head.next; let clonedCurrent = cloned; while(current) &#123; clonedCurrent = current.next; current.next = current.next.next; if (!current) break; clonedCurrent.next = current.next; current = current.next; clonedCurrent = clonedCurrent.next; &#125; return cloned;&#125; 定一个哈希表，A作为key，A’作为val。【时间O(n)、空间O(n)】 复制节点，存储哈希表：遍历原链表一遍，建立一个复制后的链表，同时整个过程哈希表中存储【A-A’】的键值对。 调整sibling，读取哈希表：同时遍历2个链表，若A的sibling指向C，则A’的sibling则指向哈希表存储的C对应的C’。 123456789101112131415161718192021222324function cloneComplexList(head) &#123; if (!head) return null; const cloned = new ComplexListNode(head.val); const map = new Map(); let current = head.next; let clonedCurrent = cloned; while(current) &#123; let node = new ComplexListNode(current.val) clonedCurrent.next = node; map.set(current, node); clonedCurrent = clonedCurrent.next; current = current.next; &#125; current = head; clonedCurrent = cloned; while (current) &#123; if (current.sibling) &#123; clonedCurrent.sibling = map.get(current.sibling) &#125; current = current.next clonedCurrent = clonedCurrent.next &#125; return cloned;&#125; ###]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之字符串]]></title>
    <url>%2F2019%2F12%2F06%2FAlgorithms-2%2F</url>
    <content type="text"><![CDATA[算法题之字符串～～～ 最长公共子序列题目找出两个字符串中最长公共子序列（非最长连续子序列） 解决方案 动态规划：写出状态方程 当i=0，j=0时，c[i,j] = 0 当a[i] = b[j]时，c[i,j] = c[i-1, j-1] + 1 当a[i] 不等于 b[j]时，c[i,j] = max(c[i,j-1], c[i-1, j]) 123456789101112131415161718192021222324function LCS(strA, strB) &#123; let dp = &#123;&#125;; let lenA = strA.length; let lenB = strB.length; dp['-1,-1'] = 0 for(let i = 0; i &lt; lenA; i++) &#123; dp[`$&#123;i&#125;,-1`] = 0; &#125; for(let i = 0; i &lt; lenB; i++) &#123; dp[`-1,$&#123;i&#125;`] = 0; &#125; for(let i = 0; i &lt; lenA; i++) &#123; for(let j = 0; j &lt; lenB; j++) &#123; if(strA[i] === strB[j]) &#123; dp[`$&#123;i&#125;,$&#123;j&#125;`] = dp[`$&#123;i-1&#125;,$&#123;j-1&#125;`] + 1; &#125; else &#123; dp[`$&#123;i&#125;,$&#123;j&#125;`] = Math.max(dp[`$&#123;i&#125;,$&#123;j-1&#125;`], dp[`$&#123;i-1&#125;,$&#123;j&#125;`]); &#125; &#125; &#125; return dp[`$&#123;lenA-1&#125;,$&#123;lenB-1&#125;`];&#125; KMP题目判断字符串A是否是字符串B的子串 解决方案 指针a指向字符串A，指针b指向字符串b，next数组为部分匹配表（字符串A的前缀后缀最长公共序列长度） 若a尚未匹配到元素 a指向的内容若不等于b指向的内容，则b++ 若相等，二者同时++ 若a已有匹配元素 若a指向的内容若不等于b指向的内容 b += （a - next[a-1]) a = 0 若相等，二者同时++ 12345678910111213141516171819202122232425262728293031323334353637// 计算部分匹配表，即next数组function makeNext(str) &#123; const next = [] const len = str.length; next[0] = 0; for(let i = 1, k = 0; i &lt; len; i++) &#123; while(k &amp;&amp; str[i] !== str[k]) k = next[k-1] // 核心 if(str[k] === str[i]) k++; next[i] = k; &#125; return next;&#125;// 匹配function kmp(strA, strB) &#123; const next = makeNext(strA); const lenA = strA.length; const lenB = strB.length; let i = j = 0; while(i &lt; lenA &amp;&amp; j &lt; lenB) &#123; if (strA[i] === strB[j]) &#123; i++; j++; &#125; else&#123; if(i &gt; 0) &#123; j += (i - next[i-1]); // j往后移动已匹配字符数-部分匹配表对应的数目 i = 0; &#125; else &#123; j++; &#125; &#125; if (i === lenA) &#123; console.log('匹配成功', strA, strB.slice(j-lenB, j)); return true; &#125; &#125; console.log('匹配失败') return false;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置SSH证书远程登陆]]></title>
    <url>%2F2019%2F11%2F25%2Fssh%2F</url>
    <content type="text"><![CDATA[每次远程登录服务器时都要手动输入密码，其实我们可以通过SSH证书实现远程一键登陆服务器。 客户端：macOS 10.15.1 服务器: Centos7 客户端配置 生成ssh公钥、私钥： 1$ ssh-keygen 传送公钥到服务器上: 1$ scp ~/.ssh/id_rsa_server.pub root@12.34.567.89:~ 指定登陆服务器使用的私钥： 1$ vi ~/etc/ssh/ssh_config 添加下面的内容： 12HOST 12.34.567.89 IdentityFile ~/.ssh/id_rsa_server 服务器配置 将上一步接收到的公钥添加到authorized_keys中 1$ cat ~/id_rsa_server.pub &gt;&gt; ~/.ssh/authorized_keys 配置sshd_config，开启证书登陆 1vim ~/etc/ssh/sshd_config 修改内容为： 12RSAAuthentication yesPubkeyAuthentication yes 重启sshd使刚才的修改生效 1$ service restart sshd 一键登录接下来就不用输入密码直接登陆服务器： 1$ ssh root@12.34.567.89 其它ssh-keygenssh_config与sshd_config]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之数组相关]]></title>
    <url>%2F2019%2F11%2F20%2FAlgorithms-1%2F</url>
    <content type="text"><![CDATA[算法题之数组相关~~~~ 数组中重复的数字题目在一个长度为n的数组里的所有数字都在0～n-1的范围内，找出其中重复的数字。 解决方案 先排序后，与后一个元素进行比较 12345const result = new Set();for (let i = 0; i &lt; sortedNumbers.length - 1; i++) &#123; if (sortedNumbers[i] === sortedNumbers[i+1]) result.add(sortedNumbers[i++])&#125; 新建数组，索引为数组元素，值为数组元素出现的次数： 12345678// 数组：numberslet numberArray = [];const result = new Set();numbers.forEach(item =&gt; &#123; numberArray[item] = numberArray[item] ? numberArray[item]++ : 1; if (numberArray[item] &gt; 1) result.add(item);&#125;)console.log(result.values()) 使用一个哈希表，存储遍历的数字；遍历的时候判断哈希表中是否已有该数字 索引数值对应法 若索引与索引对应的值不一致，则判断与索引对应的值作为的索引指向的值是否相等，若相等则该数字重复，遍历索引+1；若不相等则交换2值，重复此过程直到发现第一个重复的数字 12345678910111213for (let i = 0; i &lt; numbers.length; ) &#123; if (numbers[i] === i) &#123; i++ continue; &#125; else if (numbers[i] === numbers[numbers[i]]) &#123; result.add(numbers[i]); i++; &#125; else &#123; let temp = numbers[i] numbers[i] = numbers[temp] numbers[temp] = temp; &#125;&#125; 镜像问题不修改数组找出重复的数字题目：一个长度为n+1的数组里，所有数字都在1-n范围内，找出数组中任意一个重复的数字，但不能修改输入的数组。 解决方案： 新建数组+判断数字出现的次数&gt;1 哈希表存储，判断数字是否已经存在于哈希表中 中间数字法 中间数字为m，统计1～m、m～n+1两个区间的数字出现的次数 多出现1次的区间再分为2部分，再次统计 循环上过程，直到找到一个重复的数字 1234567891011121314151617181920212223242526function find_repeat_number(numbers) &#123; let mid = Math.floor(numbers.length / 2); let low = 1; let high = numbers.length - 1; while (1) &#123; let left = 0 let right = 0 console.log(`low: $&#123;low&#125;, mid: $&#123;mid&#125;, high: $&#123;high&#125;`) for (let i = 0, len = numbers.length; i &lt; len; i++) &#123; if (numbers[i] &lt;= mid &amp;&amp; numbers[i] &gt;= low) left++; else if (numbers[i] &gt; mid &amp;&amp; numbers[i] &lt;= high) right++ &#125; if (left &gt; (mid - low + 1)) &#123; if (mid === low) return mid; high = mid; mid = Math.floor((low + high) / 2); &#125; else if (right &gt; (high - mid))&#123; if (mid + 1 === high) return high; low = mid; mid = Math.floor((low + high) / 2); &#125; console.log(`left: $&#123;left&#125;, right: $&#123;right&#125;`) left = right = 0 &#125;&#125; 数组去重 简单判断相等的方法对NaN无效，因为NaN === NaN为false ES6的语法：Set，new Set(...arr)；无法去除{} 新开数组+数组排序，相邻元素进行比较；相邻元素不同的扔进新数组 新开数组+includes：同上 原数组：Array.prototype.indexOf + Array.prototype.filter 对象属性法，数组元素的字符串化后的值作为key。【key：typeof 值+ 值】 Array.prototype.reduce + includes 1arr.reduce((acc, cur, idx, src) =&gt; acc.includes(cur) ? acc : acc.push(cur) &amp;&amp; acc, []) 双重for循环+Array.prototype.splice 1234567891011function unique(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1) j--; &#125; &#125; &#125; return arr;&#125; 递归去重 二维数组中的查找题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序；给一个数组和整数，判断此数是否在数组中。 解决方案 从数组的右上角（左下角也OK）出发： 若相等则返回true 若值大于整数，剔除数字所在列【行索引-1】 若值小于整数，剔除数字所在行【列索引+1】 1234567891011121314151617function findNumber(arr, num) &#123; const rows = arr.length; const cols = arr[0].length; let row = 0; let col = cols - 1; while(row &lt; rows &amp;&amp; row &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; col &gt;= 0) &#123; console.log(`比较$&#123;num&#125; 与 arr[$&#123;row&#125;][$&#123;col&#125;]: $&#123;arr[row][col]&#125;`) if (arr[row][col] &lt; num) &#123; row++; &#125; else if (arr[row][col] &gt; num) &#123; col--; &#125; else &#123; return true; &#125; &#125; return false;&#125; 旋转数组的最小数字题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 解决方案 使用二分查找的思维来解决此问题 上半区出现start &gt; mid，最小元素一定出现在此区域 下半区出现mid &gt; end，最小元素一定出现在此区域 mid = start, 说明此区域元素必定都相等，所以可以将start设置为mid mid = end，元素可能是先升后降，所以将end-1或mid+1 12345678910111213141516171819202122232425262728293031323334function spinArray(arr) &#123; if (!arr &amp;&amp; !arr.length) return undefined; const len = arr.length; if (arr[0] &lt; arr[len-1]) return arr[0]; if (arr[0] &gt;= arr[len-1]) &#123; let start = 0; let end = len-1; let mid = Math.floor((start + end)/2); while(end - start &gt; 0) &#123; if(arr[start] &gt; arr[mid] ) &#123; // 上半区出现start &gt; mid，最小元素一定出现在此区域 end = mid; mid = Math.floor((start + end) / 2); continue; &#125; if (arr[mid] &gt; arr[end]) &#123; // 下半区出现mid &gt; end，最小元素一定出现在此区域 start = mid+1; mid = Math.floor((start + end) / 2); continue; &#125; if (arr[start] === arr[mid]) &#123; // mid = start, 说明此区域元素必定都相等，所以可以将start设置为mid start = mid; &#125; if (arr[end] === arr[mid]) &#123; // mid = end，元素可能是先升后降，所以将end-1或mid+1 end -= 1; &#125; mid = Math.floor((start + end) / 2); &#125; return arr[start]; &#125;&#125; 数组中出现次数超过一半的数字题目数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字 解决方案 解决方案（一）：哈希表大法，时间O(n)、空间O(n) 新建一个哈希表存储数字出现的次数 添加数字出现次数时与数组长度一半进行比较，若已超过一半直接返回，否则继续遍历 123456789function find(arr) &#123; const len = arr.length; const times = new Map(); for(let i = 0; i &lt; len; i++) &#123; let currentNumberTimes = times.get(arr[i]) || 0; times.set(arr[i], currentNumberTimes++); if ((currentNumberTimes+1) * 2 &gt; len) return arr[i] &#125;&#125; 解决方案（二）：基于Partition函数的时间复杂度为O(n)的算法 中位数即是出现超过一半的数字 随机选择一个元素，然后调整数字的顺序，比它小的在左边，比它大的在右边 调整后，判断此数字下标 若小于n/2，则中位数在它右边 若大于n/2，则中位数在它左边 若等于n/2，则其就是中位数 统计数字出现的次数 遍历数组，统计数字出现的次数，若下一个数字与其不同 次数-1，相同+1 次数为0时，改为统计下一个数字的次数 遍历到最后，始终有一个数字的次数大于1，该数字就是所求数字 1234567891011121314151617function moreThanHalfNumber(arr) &#123; if (!arr.length) return; let count = 0; let currentNumber = arr[0]; const len = arr.length; for(let i = 0; i &lt; len; i++) &#123; if (arr[i] === currentNumber) count++ else &#123; count-- if (count === 0) &#123; currentNumber = arr[i]; count++; &#125; &#125; &#125; return currentNumber;&#125; 连续子数组的最大和题目输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n) 解决方案 解决方案一：数字累加判断法 遍历数组，不断累加数字，更新sum、maxSum 若加上当前数字后值为负值，则说明后面序列的数字不需要前面的数字序列，sum = 当前数字 若当前数字为负值，则sum = 下一个数字 每执行一次循环比较一次sum与maxSum的大小，作出更新 123456789101112function findGreatestSumOfSubArray(arr) &#123; const len = arr.length; let sum = 0; let maxSum = Number.MIN_SAFE_INTEGER; for(let i = 0; i &lt; len; i++) &#123; if(sum &lt;= 0) sum = arr[i]; else sum += arr[i] if (sum &gt; maxSum) maxSum = sum; &#125; return maxSum&#125; 解决方案二：DP f(i) : 以第i个数字结尾的子数组最大值 f(i) 的值应该为： 当i=0或者f(i-1) &lt;=0 : f(i) = data[i] 当i不等于0且f(i-1) &gt; 0: f(i) = data[i] + f(i-1) 1234567891011function findGreatestSumOfSubArrayDP(arr) &#123; const len = arr.length; let dp = []; dp[0] = arr[0] let max = Number.MIN_SAFE_INTEGER; for(let i = 1; i &lt; len; i++) &#123; dp[i] = Math.max(dp[i-1] + arr[i], arr[i]); max = Math.max(max, dp[i]); &#125; return max;&#125; 从数组中选出N个数使其和等于M题目从数组中选出N个数使其和等于M，一共有多少种选法 解决方案 二进制法 1234567891011121314151617181920212223242526272829function search(arr, count, sum) &#123; var len = arr.length, res = []; for (var i = 0; i &lt; Math.pow(2, len); i++) &#123; if (n(i) == count) &#123; var s = 0, temp = []; for (var j = 0; j &lt; len; j++) &#123; if (i &amp; 1 &lt;&lt; (j)) &#123; s += arr[j] temp.push(arr[j]) &#125; &#125; if (s == sum) &#123; res.push(temp) &#125; &#125; &#125; return res;&#125;function n(i) &#123; var count = 0; while (i) &#123; if (i &amp; 1) &#123; ++count; &#125; i &gt;&gt;= 1; &#125; return count;&#125; 递归法 1234567function search(arr, n, m) &#123; if(n === 0) return m === 0 ? [[]] : []; if(arr.length &lt; n) return []; return search(arr.slice(1), n-1, m - arr[0]) .map(so =&gt; [arr[0], ...so]) .concat(search(arr.slice(1), n, m)); &#125; 数组中的逆序对题目在数组中的两个数字，如果前一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出逆序对的总数。 解决方案 暴力法：O(n^2) 归并统计法 将数组分为2个子数组，分别统计子数组的逆序对，然后再统计两个子数组间的的逆序对。 12345678910111213141516171819202122232425262728293031323334function inversePairs(data) &#123; function mergeSort(arr, left, right, temp) &#123; if (left &lt; right) &#123; let mid = Math.floor((left + right) / 2); let r = mergeSort(arr, left, mid, temp); let l = mergeSort(arr, mid + 1, right, temp); let m = merge(arr, left, mid, right, temp); return r+m+l; &#125; else &#123; return 0; &#125; &#125; function merge(arr, left, mid, right, temp) &#123; let i = mid; let j = right; let tempIndex = right; let count = 0; while(i &gt;= left &amp;&amp; j &gt; mid) &#123; if(arr[i] &gt; arr[j]) &#123; count += (j-mid); temp[tempIndex--] = arr[i--] &#125; else &#123; temp[tempIndex--] = arr[j--] &#125; &#125; while(i &gt;= left) temp[tempIndex--] = arr[i--] while(j &gt; mid) temp[tempIndex--] = arr[j--] for(let i = left; i &lt;= right; i++) &#123; arr[i] = temp[i]; &#125; return count; &#125; return mergeSort(data, 0, data.length - 1, [])&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试（更新中）]]></title>
    <url>%2F2019%2F10%2F30%2Finterviews%2F</url>
    <content type="text"><![CDATA[记录自己还记得的面试，2016级本科生～ 第一次投简历面试【2018.5】腾讯腾讯 安全云部一面（2018.5.*， 忘了）腾讯 安全云部二面（2018.5.21）第一次技术面试，比较紧张，面试过程20多分钟，最后问了面试官鹅厂前端生态和部门技术栈，下面是面试内容： 介绍一下自己，最近在看什么书，如何学习前端的。 CSS如何实现垂直居中、水平居中 对CSS3了解程度，用过哪些特性 HTTP状态码、Web缓存 跨域 介绍一下XSS和CSRF，如何避免 JavaScript中的异步编程 MVVM的原理 说说你的项目，讲讲收获大的地方。 5.17就接到了腾讯面试官的电话，问了我一些基本情况，看了我的github和博客，后面也加了微信，给了我一些很好的建议，人非常nice。（严格来说，这是第一次面试） 百度前端技术部（2018.5.23）这次面试也是一位小姐姐官，一开始比较紧张，后面就好多了，面试过程50分钟。在第一个问题中，面试官认为我的方法不可行（filter + indexOf），后来被认可了。因为没问我JavaScript我觉得重要的概念（原型、闭包、事件循环等）比较惊讶，然后面试官让我介绍（虽然答上了，但是下次再也不主动给自己加题了🤦️），最后我问了问她们部门的业务和生态。下面是面试内容： 数组去重 如何实现图片充满盒子 如何实现CSS垂直居中 CSS3的新特性 Flex布局 HTTP状态码 Web缓存 性能优化 事件流 用过的ES6特性 谈谈项目中比较难的地方 字节跳动抖音（2018.6.*）因为大二，校招针对大三的学生，技术面完之后HRBP联系了我 ps：19年11月的时候，18年面我的面试官联系我了～ 结果最后去了腾讯实习～ 第二次面试投简历面试【2019.2】百度百度 多模搜索部1面 2.19 介绍一下自己、学习经历 简历面 拦截器是什么？为什么需要？ 可视区域渲染？why？怎么实现？ 你做了哪些组件，介绍一下通知组件的接口，怎么设计？ 看个人的github？ 实现一个轮播图？CSS动画？JS动画？ 还有一些其他CSS的问题，都是跟图片动画相关的。 有什么想问的？部门技术栈？处理的业务？ 百度多模搜索部2面 2.20 介绍一下自己、学习经历 简历上写着熟悉React，那你介绍一下React。React是什么？解决了哪些问题？社区的情况？与Vue的区别？Hooks的场景和解决现有哪些痛点？ React Diff，算法描述，为什么是O(n)？ 项目中遇到的问题？ 给一个场景：上万条数据的处理？分时渲染、懒渲染、可视区域渲染、事件绑定 可视区域渲染是怎么做的，从0设计一下可视区域渲染？ 如何优化可视区域渲染，比如做事件代理，节流、防抖、缓存、异步请求，函数的拆分&amp;&amp;模块的解耦 跨域？ 重排重绘？浏览器内核多线程架构，详细描述一下页面渲染过程？ 为什么从腾讯离职，不留下来？最早什么时候能来实习？ 我问了一下部门的业务 百度前端技术部1面 2.19 介绍一下自己 谈谈你的项目，可视区域渲染？why？有没有其他的方案？为什么选择这个方案？ 块级元素与行内元素的区别，如何让一个行内元素具有块级元素的特性（多种方案） Img是内联元素，但是为什么它可以设置宽高？ 多行文本截断？ 实现一个场景：有一些图片大小不一，如何让这些图片按同样的大小显示但不能影响宽高比？ 介绍background-size和background-position？ CSS的性能优化？（避免重排重绘、不使用import、绝对定位的妙用、GPU加速） 绝对定位与float的区别和应用 盒子模型，如何更改盒子？弹性盒子介绍一下？ JavaScript的基本类型（按引用/值）？ 0.1 + 0.2 不等于0.3，why？怎么解决？还有其他方案吗？ 字符串转数字、数字转字符串？ null、undefined的区别及用处？ 严格相等、非严格相等？类型转换 ES6熟悉吗？说说常用的，对比ES5，你觉得好处有哪些？ 变量提升讲一下（JavaScript的作用域标识符的注册机制），let、const的区别以及为什么“没有”变量提升？ Promise一个题，用Promise封装ajax？ 事件流介绍一下，冒泡和捕获的区别？怎么更改事件是捕获阶段还是冒泡阶段触发？冒泡有什么场景应用（事件代理）？ scroll事件，节流、防抖讲一下，写一下？ 我发现你JavaScript挺好的，看了哪些书？逛什么团队博客啊？喜欢看谁的博客啊？ 给你一个场景，一个需求到你手上，你怎么办？沟通、规划、抉择、开发、测试、上线 我看你Vue用的多，为什么写熟悉React了解Vue呢？ 你觉得Vue和React的区别？ 想问我什么呢？部门的技术栈、前端负责的职责、我来的话干什么 百度前端技术部2面 2.19 讲讲你的项目 可视区域渲染 PWA的原理？ github面，做了哪些项目，对开源有啥共享？有没有PR？ mpvue的原理？编译原理？ 如果一个页面加载很慢，不考虑代码层面，你来分析一下性能优化？ 网络部分：合并HTTP请求？增加域名和减少域名的权衡？ DNS如何减少解析的时间？有哪些方案？ 使用HTTP2.0也可以加速，那说一下HTTP2.0的性能提升点？ 既然HTTP2.0能多路复用，为什么我们还需要打包为一个文件？可不可以不打包？为什么？ 还可以利用浏览器缓存，那说一下百度这个页面哪些资源可以缓存？广告可以吗？图片可以吗？搜索结果可以吗？ 静态资源放CDN，CDN原理？ 图片过期怎么办？协商缓存/强缓存？ 可以将首页的非必须的资源分离出去，动态加载，那说说原理？ 代码层面就不考虑了，我们换个话题，你知道jquery的load事件吗？那你说说load和domcontentloaded的区别？浏览器渲染页面的流程？浏览器核多线程架构？ 现在你来制定一个性能测试的标准，你统计的数字有哪些？ 如何统计这些数字？如何统计一个页面从点击到load事件触发前花费的时间？ 你有什么想问我的吗。部门做小程序吗？你们是怎么在Hybird和NT做的抉择，是考虑开发效率和维护性吗 百度多模搜索部3面 2.25跟经理聊技术规划、实习相关事情～ 网易一面二面总结百度两个部门技术面都通过了，最后因为申请实习生hc的流程太慢，审批下来的时候已经在网易搬砖了… 第三次面试投简历面试【2019.3】蚂蚁金服一面（3.13） 自我介绍、项目经历 Guthub面、介绍上面的开源项目 项目中遇到的问题 Vue双向绑定 React生命周期 单向数据流 React组件通信，为什么不直接修改props而是要修改state？ React更新相关 有什么想问我的吗？ 二面（3.14） 自我介绍、学习经历 在网易实习做什么？ 在腾讯实习做了什么？ 可视区域渲染 LRU算法 小程序相关 Node做过的东西？有没有做线上运维？ 过来的话想做什么方向？ 想在哪个城市工作？ 交叉面（3.20） 自我介绍、学习经历 在网易实习负责什么？ 在腾讯实习做了什么？ 除了实习做的，其他项目有什么亮点？ 学习成绩怎么样？ 为什么选择前端？你对前端是怎么看的？ 有什么想问我的？ HR面（3.27） 自我介绍 实习经历 最有趣的事情 offer怎么选？ 前任公司同事的评价 优点、缺点 如果这次失败了，你怎么看待 有什么想问的 腾讯一面 (3.15) 自我介绍、学习经历 之前为什么从腾讯离职？ 在网易负责什么？ 操作系统分页置换算法？ 可视区域渲染 Virtual DOM提高性能？ React Diff Web性能优化 有什么想问我的？ 二面（3.18） 牛客网在线写题（5道，40分钟） 千分化数字 大数相乘 洗牌算法 延迟计算两题 总监面 (3.20） 自我介绍、学习经历 技术栈 学习成绩、课程 为什么选择前端？ 库函数与系统调用 32位系统的内存多大，内存空间是怎么分配的，写出堆和栈的地址 进程间通信 UDP和TCP的区别、应用场景 数据结构学了吧，描述一下哈希算法 描述一下编译型语言和解释型语言的特征、区别 对软件开发的看法 为什么平时没有花时间学习客户端？ 第一次写代码的时间？ 实习经历 有什么想问我？ HR面 （3.22） 介绍一下自己 实习经历 做过的最有意思的东西 查户口 读研吗 对工作地点有什么要求 什么时候来实习 还投了哪些公司 自己的缺点 职业规划 有什么想问的 HR面（3.27） 介绍一下自己 查户口 职业规划 有什么想问的 总结暑期实习就投了阿里和腾讯，也都拿了offer，去了阿里 第四次投简历面试【校招季】感悟要走的路还很长啊～加油啊]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何评价前端性能好坏？]]></title>
    <url>%2F2019%2F03%2F27%2Fperfomance%2F</url>
    <content type="text"><![CDATA[如何评价前端性能好坏？加载时间是我们用于评价前端性能好坏的一个参考数据，但是加载时间与用户使用的手机类型以及当前网络状况有关，除此之外，即使页面加载完成用户也可能无法操作，所以仅仅用一个加载时间是不能描述前端性能的好坏，我们需要一套完整的性能评价体系。 此前，我们有两个主要的事件来测量性能： DomContentLoaded：页面加载时触发，但脚本刚刚开始执行 load：在页面完全加载后触发，此时用户已经可以使用页面和应用 但是，如果在网络环境较差或者脚本执行时间太长的时候，我们从DCL到load会经历一段很长很长的时间，并且load事件触发太晚，就无法分析出页面的性能瓶颈，所以我们需要建立一个从页面开始加载到加载完成的评价体系，记录用户整个感知过程。 渐进式网页指标 首次绘制(FP)： 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点 首次内容绘制(FCP)：标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 &lt;canvas&gt; 元素。 首次有效绘制（FMP）/主角元素计时：标记的是页面主要内容绘制的时间点，例如视频应用的视频组件、天气应用的天气信息、新闻应用中的新闻条目。 可交互时间（TTI）：页面渲染完成，能可靠的响应用户的操作的时间点。（这个时间不仅取决于之前的加载时间，还取决于当前是否有长任务阻塞主线程） 浏览器页面加载流程先谈谈浏览器的页面大致的加载流程： 浏览器输入url，浏览器发送请求到服务器，服务器发送HTML给浏览器。 浏览器下载HTML然后从上往下解析 如果在解析HTML过程中遇到CSS、JS外链，会执行下列操作 Send Request：向这个外链对应的服务器发送请求 Receive Response：接受响应，表示可以开始从网络接受数据 Receive Data：开始接受数据 Finish Loding：表示完成数据的下载 Parse Stylesheet/Evaluate：解析CSS或执行JS 所有的CSS下载完成后进行parse，构建CSSOM DOM和CSSOM合成一个Render tree 根据Render tree的内容计算处各个节点在网页中的大小和位置（Layout） 根据Layout绘制内容在浏览器上（Paint） 如何统计上述的指标通过performance接口，我们可以获得当前页面与性能相关的信息；然后通过navogator.sendBeacon或Google Analytics向服务器发送与性能相关的信息。 那么，具体的性能指标如何统计呢？👇👇👇 首次绘制(First Paint，FP)这个指标表示页面绘制的时间点，也就是用户第一次看到“白屏”的时间，标志“It is happening?” 首次绘制包括了任何用户自定义的背景绘制，它是首先将像素绘制到屏幕的时刻。 什么时候触发FP事件呢？FP事件是在图层进行绘制的时候触发，而不是文本、图片、SVG等元素出现的时候（这个时候触发的是FCP事件） 怎么统计这个FP时间呢？ window.perfomance.getEntriesByType(‘paint’)，这会返回FP、FCP发生的时间点。具体参考https://developer.mozilla.org/zh-CN/docs/Web/API/Performance 通过使用 Google Analytics，可跟踪首次绘制时间 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;!-- Add the async Google Analytics snippet first. --&gt; &lt;script&gt; window.ga=window.ga||function()&#123;(ga.q=ga.q||[]).push(arguments)&#125;;ga.l=+new Date; ga('create', 'UA-XXXXX-Y', 'auto'); ga('send', 'pageview'); &lt;/script&gt; &lt;script async src='https://www.google-analytics.com/analytics.js'&gt;&lt;/script&gt; &lt;!-- Register the PerformanceObserver to track paint timing. --&gt; &lt;script&gt; const observer = new PerformanceObserver((list) =&gt; &#123; for (const entry of list.getEntries()) &#123; // `name` will be either 'first-paint' or 'first-contentful-paint'. const metricName = entry.name; const time = Math.round(entry.startTime + entry.duration); ga('send', 'event', &#123; eventCategory:'Performance Metrics', eventAction: metricName, eventValue: time, nonInteraction: true, &#125;); &#125; &#125;); observer.observe(&#123;entryTypes: ['paint']&#125;); &lt;/script&gt; &lt;!-- Include any stylesheets after creating the PerformanceObserver. --&gt; &lt;link rel="stylesheet" href="..."&gt;&lt;/head&gt; 首次内容绘制(First Content Paint，FCP)当用户首次看见一些元素（文本、图片、SVG等），非”白屏“的时刻就是FCP，这个标志“it is running?” 统计的方法与上述FP的统计方法类似，Google的Analysis监听的paint实际有两种类型，‘first paint’和‘first content pain’。 FCP在文本、图片、SVG等绘制的时候就触发了，所以跟FP可以相差几毫秒～几秒的时间。 首次有效绘制(First Meaningful Paint，FMP)FMP就是页面主要内容呈现的时刻，目前没有标准化的FMP定义，所以很以通用的方式确定“有效”对于所有页面意味着什么。 所以，我们怎么统计FMP呢？它的统计在页面发生了重大的布局变化之后；LayoutAnalyzer会统计所有的布局变化，当布局变化最大时，这个时刻就是FMP。 如果主要内容渲染太慢，我们可以在样式、字体、脚本、图片上去思考，因为这些元素有很大可能阻塞了FMP。 可交互时间（Time To Interactive，TTI）与 FMP 相同，很难规范化适用于所有网页的 TTI 指标定义，但我们也可以使用Google Analytics来跟踪应用TTI。 TTI发生在什么时候？FMP &amp;&amp; DOMContentLoader事件触发 &amp;&amp; 页面视觉加载85% TTI又可以分为两个指标，TTFI（首次交互时间）、TTCI（首次持续交互时间） TTFI: 在FMP发生后应该有3s的quiet window，这个时间足够说明页面对用户是可交互的，但是可能会有长任务在这个quiet window期间或之后开始执行，它们可以被忽略。 TTCI: 从追终线的尾部开始看，页面加载后有5s的quiet并且没有长任务需要执行，得到了一段quiet window。quiet window之后到第一个长任务之前的时间就是TTCI。 影响上面某些指标的因素FP/FCP：“白屏”，从文档的 &lt;head&gt; 中移除任何阻塞渲染的脚本或样式表，可以减少首次绘制和首次内容绘制前的等待时间。FCP：首次内容绘制耗时太长，直观上就是“白板时间太长”，影响因素就是网络连接存在性能问题、资源（例如index.html）太大传输耗时。 FMP/TTI：如果主要内容很久都没展示出来，那么很有可能是图片、样式、字体、JavaScript有较高的加载优先级，阻塞了FMP。确定页面上最关键的界面元素（主角元素）之后，您应确保初始脚本加载仅包含渲染这些元素并使其可交互所需的代码。 分析关键渲染路径优化关键渲染路径就是让刘篮球尽可能快地绘制网页，减少用户看到“白屏的时间”，从FP到FCP；所以整个时间就包括了获取资源（CSS、JS、HTML）以及浏览器处理对应的文件。 关键资源：可能阻止网页首次渲染的资源 关键路径长度：获取所有关键资源所需的往返次数或总时间 关键字节：实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。 HTML、Image对于HTML，浏览器下载HTML文件，当HTML内容可用时，浏览器就会解析HTML，生成token，进而构建DOM树，DOM树构建完成同时意味着DOMContentLoaded事件触发；获取图片并不会影响DOMContentLoaded事件的触发，所以图片不会影响到首次绘制。 关键资源（HTML），关键路径长度（最少1次），关键字节（5KB） HTML、CSS加载解析HTML，然后获取CSS文件，解析为CSSOM，生成渲染树，绘制页面。 关键资源（HTML、CSS），关键路径长度（最少2次），关键字节（9KB） CSS、JavaScript、HTML123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Critical Path: Measure Script&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body onload="measureCRP()"&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;script src="timing.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 除了获取HTML、解析为DOM树，我们还会去加载CSS文件构建CSSOM，然后通过DOM和CSSOM构建渲染树，按道理来说，DCL也应该在DOM树生成后就触发，但是浏览器在下载解析CSS文件之前会阻止DCL事件，这是因为JS可能会去查询CSSOM。即使将脚本更改为内联，也无济于事。 所以，只要浏览器遇到script标记就会阻止，并等到CSSOM构建完毕。 关键资源（HTML、CSS、JS），关键路径（最少2次，获取css、js时为并行），关键字节（11KB） async，异步脚本的用处 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Critical Path: Measure Script&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body onload="measureCRP()"&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;script src="timing.js" async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这种情况下，解析HTML之后不久就会触发DCL事件，浏览器知道不需要阻止JS，不必等到CSS文件加载解析后再执行JS。 关键资源（HTML、CSS），关键路径（最少2次），关键字节（9KB） 优化上面提到，有三种因素（关键资源、关键路径、关键字节）影响着首次渲染，所以优化也应该从这三点入手。 减少关键资源的数量：删除、延迟、标记异步等 优化关键字节数以缩短下载时间（压缩） 优化其余关键资源的加载顺序（尽早下载所有的关键资产，缩短关键路径长度） 业界一些常见的优化策略Google PageSpeed Insights Rules1. **消除阻塞渲染的JavaScript和CSS**(最大限度减少网页上关键资源的数量并尽可能消除这些资源，减少下载关键字节数，优化关键路径长度) 2. **优化JavaScript的使用**（JavaScript资源会阻塞解析器，所以将其标记为async或通过专门的JavaScript代码进行添加。**阻塞解析器的JavaScript强制浏览器等待CSSOM并暂停DOM的构建，继而大大延迟首次渲染的时间**） 3. **延迟解析JavaScript**（延迟加载对构建首次渲染的可见内容无关紧要的脚本） 4. **避免运行时间长的JavaScript** 5. **优化CSS的使用**（CSS置于文档head标签内、避免使用CSS import、内联阻塞渲染的CSS） Yahoo Best Practices for Speeding Up Your Web Site 减少http请求 使用CDN 利用浏览器缓存 压缩页面元素 样式表放在head JavaScript文件放在底部 避免CSS表达式 JS、CSS放在外部文件中 减少CDN查询 压缩JavaScript 避免重定向 现代前端应用的优化策略 前端资源文件离线化 页面组件化并按需加载 预渲染提升感官性能 RAIL 响应：在100ms以内响应在用户注意到滞后之前有100ms的时间可以响应用户输入。 动画：每10ms生成一帧尽管每秒生成60帧，一帧16.6ms，但是每帧只有10ms来执行代码，其余的时间用于将新帧绘制到屏幕上。 空闲：最大程度增加空闲时间利用空闲时间完成推迟的工作，换句话说，就是让主线程在UI线程和JS线程中切换。 加载：在1000ms以内呈现内容在 1 秒钟内加载您的网站。 总结 参考资料 Performance metrics. What’s this all about? Paint Timing 1 User-centric Performance Metrics User Timing and Custom Metrics 分析关键渲染路径性能 性能为何如此重要 使用RAIL模型评估性能]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>FP/FCP</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用进程池提高Node.js并行计算能力]]></title>
    <url>%2F2019%2F03%2F22%2Fnode-process-pool%2F</url>
    <content type="text"><![CDATA[使用进程池提高Node.js并行计算能力背景Node是单线程模型，当需要执行多个独立且耗时任务的时候，只能通过child_process来分发任务，提高处理速度；不像Java这种多线程语言，可以通过线程来解决并行问题，Node只能创建进程来进行处理；但是进程相对于线程来说，开销太大。一旦进程数较多时，CPU和内存消耗严重（影响我干其他的事情），所以做了一个简易版的进程池，用来解决并行任务的处理。 适用场景：相同且独立且耗时的任务，例如，拿到某网站1000个用户的账号密码，我现在想要他们的信息，爬他，node-process-pool非常适合。 思路主控进程+工作进程群 ProcessPool是我们管理进程的地方，我们通过传递配置参数（任务脚本、脚本需要的参数、最大并行进程数）生成一个ProcessPool实例，然后通过这个实例来管控进程池。 ProcessItem是我们进程池里的进程对象，ProcessItem对象除了process的信息，我们还增加了唯一标识和状态（忙碌、任务失败、任务完成、进程不可用）。 一批任务开始时，我们会一次性fork到最大并行进程数，然后开始监控是否有工作进程完成任务，如果有工作进程完成了任务，那我们就可以复用这个工作进程，让其执行新任务；如果任务执行失败，我们会将任务归还给进程池，等待下一次分发。 由于是相同且独立且耗时的任务，所以当某个工作进程完成任务时，我们很有必要去检测所有的工作进程是否已完成任务，而不只是复用这个工作进程，我们要一批一批的复用！！！ 因为差不多的时间开始执行相同的任务，当一个工作进程完成时，完全可以相信其他工作进程也完成了任务，所以检测一轮所有的工作进程，若空闲，给他们分配新任务。 既然是批量分配任务，就不会存在只有某个工作进程在辛苦的运行，其他工作进程袖手旁，哈哈哈哈哈，总得雨露均沾嘛。 由于主控进程即要负责IPC又要不断监听批任务完成的情况，目前我采用的方式是setInterval切割，让IPC和监控能交替进行（ps：应该有更好的方法 我们真的需要setInterval来去轮询任务状态吗，什么时候才需要轮询任务状态然后调度？工作进程状态发生改变的时候，才是我们需要去检测任务状态和调度的时机；所以，我们也可以利用IPC来通知主控进程进行检测任务状态和调度。ps：当然，还有更好的方法，嘿嘿 实现ProcessPool.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182const fs = require('fs')const ProcessItem = require('./ProcessItem')const isCorrectType = require('./util').isCorrectType/** * 进程池类 * @param maxParallelProcess，最大并行工作进程数 * @param timeToClose，任务最长耗时时间 * @param taskParams，所有任务脚本需要的参数 * @param dependency，任务脚本所需依赖 * @param taskName, 工作脚本名称 * @param script 脚本内容 * @param workDir 工作目录 */function ProcessPool(&#123; maxParallelProcess = 50, timeToClose = 60 * 1000, taskParams = [], dependency = '', workDir ='', taskName = Date.now(), script = '',&#125;) &#123; try &#123; isCorrectType('task', script, 'function') isCorrectType('maxParallelProcess', maxParallelProcess, 'number') isCorrectType('timeToClose', timeToClose, 'number') isCorrectType('dependency', dependency, 'string') isCorrectType('workDir', workDir, 'string') &#125; catch (e) &#123; throw new Error('参数不合法' + e) &#125; this.timeToClose = timeToClose this.processList = new Map() // 使用Map存储进程对象 this.currentProcessNum = 0 // 当前活动进程数 this.dependency = dependency // 任务脚本依赖 this.workDir = workDir // 主控函数工作目录 this.taskName = taskName // 任务脚本名称 this.task = `$&#123;this.workDir&#125;/$&#123;this.taskName&#125;.js`// 任务脚本路径 this.taskParamsTodo = taskParams // 待完成的任务参数数组，包含了n个小任务所需参数，所以是一个二维数组 this.maxParallelProcess = maxParallelProcess // 最大进程并行数 this.script = script // 任务脚本内容 this.ready = false // 任务脚本是否构建完成 try &#123; this.buildTaskScript() // 根据模版创建任务脚本 &#125; catch (e) &#123; throw new Error('创建任务脚本失败' + e) &#125;&#125;/** * 启动进程池 */ProcessPool.prototype.run = function() &#123; if (this.ready) &#123; let flag = this.hasWorkProcessRunning() // 判断是否有工作进程正在执行或是否是第一次处理任务 const taskTodoNum = this.taskParamsTodo.length if (flag === 1 &amp;&amp; taskTodoNum) &#123; // 初始阶段，fork min&#123;任务数，最大进程数&#125; 的进程 while (this.currentProcessNum &lt; this.maxParallelProcess &amp;&amp; this.currentProcessNum &lt; taskTodoNum) &#123; this.addProcess() &#125; &#125; else if (flag === 2 &amp;&amp; !taskTodoNum) &#123; // 有忙碌的工作进程，且任务已下发完 &#125; else if (flag === 2 &amp;&amp; taskTodoNum) &#123; // 有忙碌的工作进程，但还有任务需下发 const processList = this.processList.values() for (const p of processList) &#123; if (p.state !== 1 || p.state !== 4) &#123; this.reuseProcess(p.id) &#125; &#125; &#125; else if (flag === -1 &amp;&amp; taskTodoNum) &#123; // 所有工作进程空闲，但还有任务需下发 const processList = this.processList.values() for (const p of processList) &#123; if (p.state !== 1 || p.state !== 4) &#123; this.reuseProcess(p.id) &#125; &#125; &#125; else if (flag &lt; 0 &amp;&amp; !taskTodoNum) &#123; // 所有进程空闲，且任务已下发完 this.closeProcessPool() &#125; &#125;&#125;/** * 生成任务脚本 */ProcessPool.prototype.buildTaskScript = function() &#123; const taskDir = this.task const templateDir = `$&#123;__dirname&#125;/task.js` const dependency = `$&#123;this.dependency&#125;\n` const taskBody = this.script.toString() const templateReadStream = fs.createReadStream(templateDir) const taskWriteStream = fs.createWriteStream(taskDir) taskWriteStream.write(dependency) templateReadStream.pipe(taskWriteStream).write(taskBody) taskWriteStream.on('finish', () =&gt; &#123; this.ready = true this.run() &#125;)&#125;/** * 添加一个工作进程、指派任务且监听IPC */ProcessPool.prototype.addProcess = function() &#123; if (this.currentProcessNum &lt;= this.maxParallelProcess) &#123; let workParam = this.taskParamsTodo.shift() const newProcess = new ProcessItem(&#123;task: this.task, workParam&#125;) this.processList.set(newProcess.id, newProcess) this.currentProcessNum++ this.listenProcessState(newProcess, workParam) &#125;&#125;/** * 工作进程与主控进程IPC * @param workProcess * @param params */ProcessPool.prototype.listenProcessState = function(workProcess, params) &#123; workProcess.process.on('message', message =&gt; &#123; if (message === 'finish') &#123; workProcess.finishTask() &#125; else if (message === 'failed') &#123; this.taskParamsTodo.unshift(params) workProcess.unFinishTask() &#125; this.run() &#125;)&#125;/** * 监测当前是否有正在处理任务的工作进程 * @returns &#123;number&#125; */ProcessPool.prototype.hasWorkProcessRunning = function() &#123; if (!this.processList) return -1 if (this.processList &amp;&amp; !this.processList.size) return 1 // 进程池刚启动，尚无工作进程 const processList = this.processList.values() for (const p of processList) &#123; if (p.state === 1) return 2 // 有忙碌的进程 &#125; return -1&#125;/** * 复用空闲进程 * @param id，工作进程的pid */ProcessPool.prototype.reuseProcess = function(id) &#123; const workProcess = this.processList.get(id) if (this.taskParamsTodo.length &amp;&amp; workProcess &amp;&amp; workProcess.state !== 1) &#123; const taskParam = this.taskParamsTodo.shift() workProcess.state = 1 // 设置为忙碌 workProcess.process.send(taskParam) &#125;&#125;/** * 关闭工作进程 * @param id */ProcessPool.prototype.removeProcess = function(id) &#123; let workProcess = this.processList.get(id) if (workProcess) &#123; workProcess.terminate() this.currentProcessNum-- &#125;&#125;/** * 关闭所有工作进程 */ProcessPool.prototype.removeAllProcess = function() &#123; const processItems = this.processList.values() for (const processItem of processItems) &#123; processItem.terminate() &#125;&#125;/** * 关闭进程池 */ProcessPool.prototype.closeProcessPool = function() &#123; this.removeAllProcess() this.ready = false this.processList = null&#125;module.exports = ProcessPool ProcessItem.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const ChildProcess = require('child_process')/** * 工作进程类 */function ProcessItem(&#123; task = './task.js', workParam = [] &#125;) &#123; /** * state 状态码 * 1: 忙碌 * 2: 完成任务 * 3: 未完成任务 * 4： 不可用 */ if (!Array.isArray(workParam)) &#123; throw new Error('workParam must be a array') &#125; if (typeof task !== 'string') &#123; throw new Error('workParam must be a string') &#125; this.process = this.createProcess(task, workParam) this.state = 1 this.id = this.process.pid&#125;ProcessItem.prototype.finishTask = function() &#123; if (this.state === 1) &#123; this.state = 2 &#125;&#125;ProcessItem.prototype.unFinishTask = function() &#123; this.state = 3&#125;ProcessItem.prototype.terminate = function() &#123; try &#123; this.process.kill() this.state = 4 &#125; catch (e) &#123; throw new Error(`关闭进程$&#123;this.id&#125;失败`) &#125;&#125;ProcessItem.prototype.createProcess = function (task, workParam) &#123; let childProcess = ChildProcess.fork(task, workParam) if (childProcess) &#123; return childProcess &#125; else &#123; throw new Error('create process failed') &#125;&#125;module.exports = ProcessItem Task.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 当进程被子进程创建后，立刻执行工作任务 */async function firstTask() &#123; const workParam = process.argv.slice(2) await task(workParam)&#125;/** * 完成任务，提示进程池已完成，工作进程空闲 */async function finishTask() &#123; await process.send('finish')&#125;/** * 任务失败，提示进程池未完成，归还任务 */async function unFinishTask() &#123; await process.send('failed')&#125;/** * 监听进程池后续指派的任务 */process.on('message', async workParam =&gt; &#123; await task(workParam) try &#123; await finishTask() &#125; catch (e) &#123; await unFinishTask() &#125;&#125;)/** * 进程被创建时立即执行进程池指派的任务 * @returns &#123;Promise&lt;void&gt;&#125; */async function main() &#123; try &#123; await firstTask() await finishTask() &#125; catch (e) &#123; await unFinishTask() &#125;&#125;main()/** * @name 工作进程负责的任务 * @param workParam // 执行任务所需的参数数组 * 动态添加任务脚本到此文件尾部 */ Util.js12345678910111213function isCorrectType(name,value, type) &#123; if (type === 'array') &#123; if (!Array.isArray(value)) &#123; throw new Error(`$&#123;name&#125; must be a array`) &#125; &#125; else &#123; if (typeof value !== type) &#123; throw new Error(`$&#123;name&#125; must be a $&#123;type&#125;`) &#125; &#125;&#125;exports.isCorrectType = isCorrectType 使用方法安装1npm install node-process-pool 使用1234567891011121314151617181920// 进程池使用示例const ProcessPool = require('../src/ProcessPool')const taskParams = []for (let i = 0; i &lt; 100; i++) &#123; taskParams[i] = [i]&#125;// 创建进程池实例const processPool = new ProcessPool(&#123; maxParallelProcess: 50, // 支持最大进程并行数 timeToClose: 60 * 1000, // 单个任务被执行最大时长 dependency: `const path = require('path')`, // 任务脚本依赖 workDir: __dirname, // 当前目录 taskName: 'test', // 任务脚本名称 script: async function task(workParam) &#123; console.log(workParam) &#125;, // 任务脚本内容 taskParams // 需要执行的任务参数列表，二维数组&#125;)// 利用进程池进行处理大规模任务processPool.run() 其他github地址：https://github.com/GeniusFunny/ProcessPool]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>单线程</tag>
        <tag>进程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由的设计思想与实现 && React-Router v4]]></title>
    <url>%2F2019%2F02%2F25%2Freact-router%2F</url>
    <content type="text"><![CDATA[前端路由的实现前端路由分为两种实现方式： HashHistory，通过修改location.hash，然后监听hashchange事件来进行对应操作。 BroswerHistory，通过HTML5提供的History对象的pushState、replaceStateAPI，然后监听popstate事件来进行对应操作。 二者的优劣： 第一种方法兼容性更好，但是实现比较复杂，并且url比较丑陋（例如：http://www.test.com/#/xxx）。 第二种方法是浏览器提供的能力，所以实现比较简单，url与正常相同（例如：http://www.test.com/xxx），但是可能存在兼容性问题。 其实还有第三种，MemoryHistory，用于non-DOM环境下，例如React Native。 基于hash的前端路由实现_routes用来存储路由对应的回调函数，当hash变化时调用refresh函数（从_routes总找到对应的回调函数然后执行）；通过back函数进行回退，所以我们需要引入布尔值判定当前操作是否为回退。 1234567891011121314151617181920212223242526272829303132333435363738class HashRouter &#123; constructor() &#123; this._routes = new Map() this._history = [] this._currentUrl = '' this._backIndex = this._routes.length - 1 this._currentIndex = this._routes.length - 1 this._isBack = false this._bindEvent() &#125; _bindEvent = () =&gt; &#123; window.addEventListener('laod', this.refresh, false) // 加载后就触发更新 window.addEventListener('hashchange', this.refresh, false) //监听hash的变化，然后调用更新函数 &#125; route(path, cb = function() &#123;&#125;) &#123; this._routes.set(path, cb) &#125; refresh = () =&gt; &#123; this._currentUrl = location.hash.slice(1) || '/' //读取url中'#'后面的内容 this._history.push(this._currentUrl) this._currentIndex++ if (!this._isBack) &#123; this._backIndex = this._currentIndex &#125; let cb = this._routes.get(this._currentUrl) if (typeof cb === 'function') cb() // 执行路由对应的回调函数 this._isBack = false &#125; back = () =&gt; &#123; this._isBack = true if (this._backIndex &lt;= 0) &#123; this._backIndex = 0 &#125; else &#123; this._backIndex -= 1 &#125; location.hash = `#&#123;this._history[this._backIndex]&#125;` &#125;&#125; 基于History的前端路由实现依赖于HTML5提供的History对象，Router的实现简便很多；使用go来进行前往指定路由，用back回退。 1234567891011121314151617181920212223242526272829class BroswerRouter &#123; constructor() &#123; this._routes = new Map() this._bindEvent() &#125; _bindEvent = () =&gt; &#123; window.addEventListener('popstate', e =&gt; &#123; let path = e.state &amp;&amp; e.state.path let cb = this._routes.get(path) if (typeof cb = 'function') cb() &#125;) &#125; init(path) &#123; history.replaceState(&#123;path: path&#125;, '', path) let cb = this._routes.get(path) if (typeof cb = 'function') cb() &#125; route(path, cb = function() &#123;&#125;) &#123; this._routes.set(path, cb) &#125; go = (path) =&gt; &#123; history.pushState(&#123;path: path&#125;, '', path) let cb = this._routes.get(path) if (typeof cb === 'function') cb() &#125; back = () =&gt; &#123; history.back() &#125;&#125; React-Router v4👆👆👆只是简单的前度路由的模拟，但是涉及到React或者Vue的时候，我们需要另外处理渲染逻辑，所以会牵扯到生命周期和组件通信。 下面简单分析概述一下React-Router v4 模块结构React-Router分为4个package，分别为：react-router、react-router-dom、react-router-native、react-router-config。 react-router：负责通用的路由逻辑，被其他package所依赖，无需特别引入。 react-router-dom: 负责浏览器的路由管理。 react-router-native：负责react-native的路由管理。 react-router-config: 用于配置特别的react-router，比如SSR环境下。 下面介绍一下react-router中只要的模块👇👇👇 Router（react-router/Router、react-router/RouterContext、react-router-dom/BrowserRouter）BroswerRouter在内部创建一个全局对象history，然后通过props传递给Router组件，Router组件再将这个history属性作为context传递给子组件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 创建context，用于全局传递信息const createNamedContext = name =&gt; &#123; const context = React.createContext(); context.Provider.displayName = `$&#123;name&#125;.Provider`; context.Consumer.displayName = `$&#123;name&#125;.Consumer`; return context;&#125;const RouterContext = createNamedContext('Router')class Router extends Component &#123; static computeRootMatch(pathname) &#123; return &#123; path: "/", url: "/", params: &#123;&#125;, isExact: pathname === "/" &#125;; &#125; constructor(props) &#123; super(props); this.state = &#123; location: props.history.location &#125;; // This is a bit of a hack. We have to start listening for location // changes here in the constructor in case there are any &lt;Redirect&gt;s // on the initial render. If there are, they will replace/push when // they mount and since cDM fires in children before parents, we may // get a new location before the &lt;Router&gt; is mounted. this._isMounted = false; this._pendingLocation = null; if (!props.staticContext) &#123; // ！！！在这里进行监听，每次路由变化都会触发顶层Router的回调事件，然后Router进行setState，再向下传递context，最下面的Route根据context内容判断是否进行渲染！！！ this.unlisten = props.history.listen(location =&gt; &#123; if (this._isMounted) &#123; this.setState(&#123; location &#125;); &#125; else &#123; this._pendingLocation = location; &#125; &#125;); &#125; &#125; componentDidMount() &#123; this._isMounted = true; if (this._pendingLocation) &#123; this.setState(&#123; location: this._pendingLocation &#125;); &#125; &#125; componentWillUnmount() &#123; if (this.unlisten) this.unlisten(); &#125; render() &#123; return ( &lt;RouterContext.Provider children=&#123;this.props.children || null&#125; value=&#123;&#123; history: this.props.history, location: this.state.location, match: Router.computeRootMatch(this.state.location.pathname), staticContext: this.props.staticContext &#125;&#125; /&gt; ); &#125;&#125;class BrowserRouter extends React.Component &#123; history = createHistory(this.props); render() &#123; return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;; &#125;&#125; Route（react-router/Route）Router是借助context向Route传递内容的，Router作为Provider、Route作为Comsumer，所以Route必须包含在Router内部。 同时，Route借助context将history、location、match作为三个独立的属性传递给要渲染的组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Route extends Component &#123; render() &#123; return ( &lt;RouterContext.Consumer&gt; &#123;context =&gt; &#123; const location = this.props.location || context.location const match = this.props.computedMatch ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us : this.props.path ? matchPath(location.pathname, this.props) : context.match const props = &#123; ...context, location, match &#125; // 传递给要渲染的组件 let &#123; children, component, render &#125; = this.props // Preact uses an empty array as children by // default, so use null if that's the case. if (Array.isArray(children) &amp;&amp; children.length === 0) &#123; children = null; &#125; if (typeof children === "function") &#123; children = children(props); if (children === undefined) &#123; children = null; &#125; &#125; return ( // 提供了多种渲染的方式，children(子元素)、component（props）、render(props) &lt;RouterContext.Provider value=&#123;props&#125;&gt; &#123;children &amp;&amp; !isEmptyChildren(children) ? children : props.match ? component ? React.createElement(component, props) // 这里是通过React.creareElement创建组件的，所以React Diff认为每次都不一样，更新的时候会先卸载之前的组件再重新安装新的组件。 : render ? render(props) : null : null&#125; &lt;/RouterContext.Provider&gt; ); &#125;&#125; &lt;/RouterContext.Consumer&gt; ); &#125;&#125; Switch（react-router/Switch）Switch的作用是，当Switch中的第一个Route匹配后就不会渲染其他的Route，类似swich这个语法。源码如下： 1234567891011121314151617181920212223242526272829303132333435class Switch extends Component &#123; render() &#123; return ( &lt;RouterContext.Consumer&gt; &#123;context =&gt; &#123; const location = this.props.location || context.location; let element, match; // We use React.Children.forEach instead of React.Children.toArray().find() // here because toArray adds keys to all child elements and we do not want // to trigger an unmount/remount for two &lt;Route&gt;s that render the same // component at different URLs. React.Children.forEach(this.props.children, child =&gt; &#123; // 按children的顺序依次遍历子元素，成功就标记这个子元素和对应的location和comutedMatch，最后调用React.cloneElement渲染，否则返回null if (match == null &amp;&amp; React.isValidElement(child)) &#123; element = child; const path = child.props.path || child.props.from; // Switch通过matchPath来判断是否匹配成功 match = path ? matchPath(location.pathname, &#123; ...child.props, path &#125;) : context.match; &#125; &#125;); return match ? React.cloneElement(element, &#123; location, computedMatch: match &#125;) : null; &#125;&#125; &lt;/RouterContext.Consumer&gt; ); &#125;&#125; matchPath（react-router/matchPath）前面多次提到使用matchPath来判断是否匹配成功，那么到底是如何进行匹配的呢？下面是matchPath的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 缓存，不必每次都生成一个正则表达式用于判断const cache = &#123;&#125;;const cacheLimit = 10000;let cacheCount = 0;function compilePath(path, options) &#123; const cacheKey = `$&#123;options.end&#125;$&#123;options.strict&#125;$&#123;options.sensitive&#125;`; const pathCache = cache[cacheKey] || (cache[cacheKey] = &#123;&#125;); if (pathCache[path]) return pathCache[path]; const keys = []; const regexp = pathToRegexp(path, keys, options); const result = &#123; regexp, keys &#125;; if (cacheCount &lt; cacheLimit) &#123; pathCache[path] = result; cacheCount++; &#125; return result;&#125;/** * Public API for matching a URL pathname to a path. */function matchPath(pathname, options = &#123;&#125;) &#123; if (typeof options === "string") options = &#123; path: options &#125;; const &#123; path, exact = false, strict = false, sensitive = false &#125; = options; const paths = [].concat(path); return paths.reduce((matched, path) =&gt; &#123; if (matched) return matched; const &#123; regexp, keys &#125; = compilePath(path, &#123; end: exact, strict, sensitive &#125;); const match = regexp.exec(pathname); if (!match) return null; const [url, ...values] = match; const isExact = pathname === url; if (exact &amp;&amp; !isExact) return null; return &#123; path, // the path used to match url: path === "/" &amp;&amp; url === "" ? "/" : url, // the matched portion of the URL isExact, // whether or not we matched exactly params: keys.reduce((memo, key, index) =&gt; &#123; memo[key.name] = values[index]; return memo; &#125;, &#123;&#125;) &#125;; &#125;, null);&#125; Link（react-router-dom/Link）Link是react-router-dom中的，而不是通用模块里的元素；Link是一个用a标签包裹、用来实现跳转的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Link extends React.Component &#123; handleClick(event, history) &#123; if (this.props.onClick) this.props.onClick(event); if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore everything but left clicks (!this.props.target || this.props.target === "_self") &amp;&amp; // let browser handle "target=_blank" etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) &#123; event.preventDefault(); const method = this.props.replace ? history.replace : history.push; method(this.props.to); &#125; &#125; render() &#123; const &#123; innerRef, replace, to, ...rest &#125; = this.props; // eslint-disable-line no-unused-vars return ( &lt;RouterContext.Consumer&gt; &#123;context =&gt; &#123; const location = typeof to === "string" ? createLocation(to, null, null, context.location) : to; const href = location ? context.history.createHref(location) : ""; return ( &lt;a &#123;...rest&#125; onClick=&#123;event =&gt; this.handleClick(event, context.history)&#125; href=&#123;href&#125; ref=&#123;innerRef&#125; /&gt; ); &#125;&#125; &lt;/RouterContext.Consumer&gt; ); &#125;&#125; H5的history对象中通过pushState、replaceState只会改变路由而不会发生跳转，但是之前提的Router中的listen可以监听到路由的变化然后更新props和context，让下层的Route重新匹配，完成需要渲染部分的更新。如何监听的呢？这部分在history库中的createTransitionManager中（React-Router依赖于history）。 createTransitionManager（history/createTransitionManager）下面就是源码，观察者模式的一个应用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function createTransitionManager() &#123; let prompt = null; function setPrompt(nextPrompt) &#123; prompt = nextPrompt; return () =&gt; &#123; if (prompt === nextPrompt) prompt = null; &#125;; &#125; function confirmTransitionTo( location, action, getUserConfirmation, callback ) &#123; // TODO: If another transition starts while we're still confirming // the previous one, we may end up in a weird state. Figure out the // best way to handle this. if (prompt != null) &#123; const result = typeof prompt === 'function' ? prompt(location, action) : prompt; if (typeof result === 'string') &#123; if (typeof getUserConfirmation === 'function') &#123; getUserConfirmation(result, callback); &#125; else &#123; callback(true); &#125; &#125; else &#123; // Return false from a transition hook to cancel the transition. callback(result !== false); &#125; &#125; else &#123; callback(true); &#125; &#125; let listeners = []; function appendListener(fn) &#123; let isActive = true; function listener(...args) &#123; if (isActive) fn(...args); &#125; listeners.push(listener); return () =&gt; &#123; isActive = false; listeners = listeners.filter(item =&gt; item !== listener); &#125;; &#125; function notifyListeners(...args) &#123; listeners.forEach(listener =&gt; listener(...args)); &#125; return &#123; setPrompt, confirmTransitionTo, appendListener, notifyListeners &#125;;&#125; WithRouter（react-router/WithRouter）光从名字上看就知道，这是一个HOC，这个高阶组件的作用就是让我们在非Route中的组件也能获取到路由信息。 123456789101112131415161718192021function withRouter(Component) &#123; const C = props =&gt; &#123; const &#123; wrappedComponentRef, ...remainingProps &#125; = props; return ( &lt;Route children=&#123;routeComponentProps =&gt; ( &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125; /&gt; )&#125; /&gt; ); &#125;; C.displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)`; C.WrappedComponent = Component; return hoistStatics(C, Component);&#125; 总结现在我们来大致梳理一下，前端路由的过程。 当Router组件创建时，我们会在上面注册一个事件用于监听路由的变化，一旦路由变化就会触发setState。 点击Link其实就是点击a标签进行跳转，但是我们阻止了跳转；实际上我们在这里调用history的pushState方法，将当前path存储，并修改路由（此时并没有改变页面的渲染）。 每次路由的变化就会触发Router的setState，所以此时会成新context传递给下层。 下层的Route拿到新的context后根据matchPath判断path是否和location匹配，匹配就渲染，不匹配不渲染，此时页面的渲染改变。 所以说整个前端路由的思路（以React-Router为例）就是： 首先创建一个全局对象，通过context API向下传递histpry对象，从而控制具体的渲染；（渲染变化） 添加一个Event Emitter，用于响应路由变化/Hash变化，然后进行对应的逻辑处理；（路由变化） 路由变化/Hash变化导致context变化，context变化又导致渲染改变；（渲染变化） 那么，前端路由跟后端路由有什么区别呢？ 后端路由，数据渲染是由服务器解决，例如利用express构建的服务端应用，render(‘xxx.pug’)，服务器渲染好页面后返回给浏览器端，浏览器显示。表现形式就是，跳转页面会白屏，加载～ 前端路由，数据渲染是由浏览器端解决，例如上述的例子，但是路由变化和渲染变化是分隔开的，所以我们需要通过hashchange or popstate将路由变化和渲染变化连接起来。表现形式则是，跳转页面不会白屏～ 那是不是前端路由就可以完全取代后端路由了呢？不是的，前端路由也存在不足，SEO就是一个big problem。 那是不是前端路由和后端路由就是相互隔绝的呢？不是的，二者之间又衍生出许多新的hack手段，例如预渲染（服务端线构建出一部分静态HTML，用于直出浏览器，然后剩余使用前端渲染来实现）、SSR。 既然谈到了预渲染和SSR；那就先占个坑位，学习一下SSR和预渲染～ 参考资源 前端路由的两种实现原理 面试官：你了解前端路由吗 React-Router源码 history源码—Manage session history with JavaScript]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Processes and Threads]]></title>
    <url>%2F2018%2F12%2F09%2Fprocesses-and-threads%2F</url>
    <content type="text"><![CDATA[Process and Thread are most important concepts in Operating System. Processes and ThreadsProcessConceptIn process model, all the runnable software on the computer, sometimes include operating system, is organized into a number of sequential process. A process is just an instance of an executing program, including the current vlaues of program counter, registers, and variables. A CPU can really run only one process at a time. In traditional operating systems, each process has an address space and a single thread of control. In many situations , it is desirable to have multiple threads of control in the same address space running in quasi-parallel, as though they were (almost) separate processes(except for the shared address spaces). Process Creation System initialization. Execution of a process-creation system call by running process. A user request to create a new process. A initiation of a batch job. Daemons: Processes that stay in the background to handle some activity. Fork: this system call creates an exact clone of the calling process. After the fork, the two processes, the parent and the child, have the same memory image, the same environment strings, and the same open files. Process Termination Normal exit(voluntary). Error exit(voluntary). Fatal error(involuntary). Killed by aother process(involuntary). Process HierarchiesIn UNIX, a process and all of its children and further descendants together from a process group. Windows has no concept of a process hierarchy, all processes are equal. The only hint of a process hierarchy is that when a process is created, the parent is given a special token (called a handle) that it can use to control the child. Process States Running.（actually using the CPU at that instant） Ready. (runnable; temporatily stopped to let another process run) Blocked.(unable to run until some external event happens) Implementation of ProcessesProcess Table: contains per process, each entry contains important information about the process state, including its program counter, stack pointer, memory allocation, the status of its open files, its accounting and scheduling infomation, and everything else about the process that must be saved when the process is switched from running to ready or blocked state so that it can be restarted later as if it had never been stopped. Skeleton of what the lowest level of the operating system does when an interrupt occurs: Hardware stacks program counter, etc. Hardware loads new program counter from interrupt vector. Assembly-language procedure saves registers. Assembly-language procedure sets up new stack. C interrupt service runs (typically reads and buffers input). Scheduler decides which process is to run next. C procedure returns to the assembly code. Assembly-language procedure starts up new current process. A process may be interrputed thousands of times during its execution, but the key idea is that after each interrupt the interrupted process returns to precisely the same state it was in before the interrupt occurred. ThreadConceptA thread can be reguard as a miniprocess. Why would anyone want to have threads? Only now with threads we add a element: the ability for parallel entities to share an address space and all of its data, which is why having multiple processes (with their separate address spaces) will not work. Threads are lighter weight than processes, they are easier to create and destory than process. Threads yield no performance gain when all of then are CPU bound, but when where is substantial computing and also substantial I/O, having threads allows these activities to overlap, thus speeding up the application. The Classical Thread ModelThe process model is based on two independent concepts: resource grouping and execution. A process has a thread of execution, usually shortened to just thread. Processes are used to group resources together; threads are the entities scheduled for executing on the CPU. Implementing Threads in User SpaceAdvantage : When a thread is finished running for the moment, for example, when it calls thread yield, the code ofthread yield can save the thread’s information in the thread table itself. Furthermore, it can then call the thread scheduler to pick another thread to run. The procedure that saves the thread’s state and the scheduler are just local procedures, so invoking them is much more efficient than making a kernel call. Among other issues, no trap is needed, no context switch is needed, the memory cache need not be flushed, and so on. This makes thread scheduling very fast. They allow each process to have its own customized scheduling algorithm. Problem: How implement blocking system call? if a thread starts running, no other thread in that process will ever run unless the first thread voluntarily gives up the CPU. Implementing Threads in the Kernel All calls that might block a thread are implemented as system calls, at consid-erably greater cost than a call to a run-time system procedure. Kernel threads do not require any new, nonblocking system calls. While kernel threads solve some problems, they do not solve all problems. Hybird ImplementationsUsing kernel-level threads and then multiplex user-level threads onto some or all of them.With this approach, the kernel is aware of only the kernel-level threads and schedules those. Some of those threads may have multiple user-level threads multiplexed on top of them. Scheduler ActivationsThe goals of the scheduler activation work are to mimic the functionality of kernel threads, but with the better performance and greater flexibility usually associated with threads packages implemented in user space. When scheduler activations are used, the kernel assigns a certain number of virtual processors to each process and lets the (user-space) run-time system allocate threads to processors. The basic idea that makes this scheme work is that when the kernel knows that a thread has blocked (e.g., by its having executed a blocking system call or caused a page fault), the kernel notifies the process’ run-time system, passing as parameters on the stack the number of the thread in question and a description of the event that occurred. The notification happens by having the kernel activate the run-time system at a known starting address, roughly analogous to a signal in UNIX. This mechanism is called an upcall.]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到1打造一款没人用的前端框架]]></title>
    <url>%2F2018%2F12%2F07%2FX-react%2F</url>
    <content type="text"><![CDATA[如果可以，为什么我们不自己打造一款没人用的前端框架呢？ 首先介绍如何创建虚拟DOM节点以及将虚拟DOM节点转化为真实DOM节点，参照React/Preact 创建虚拟DOM节点我们在React会经常写出下列类似的代码 1const Example = &lt;span id='example'&gt;Hello, Example&lt;/span&gt; 这段代码不是合法的JavaScript代码，这段是JSX代码。JSX是JavaScript的语法拓展，用来声明React中的元素。看起来它就像一个模版语言，但是它并不是，它是完全是在JavaScript内部实现的。 那么我们写的JSX代码是如何被JavaScript解析的呢？ 这里就不得不提一下Babel，Babel是一个JavaScript编译器，将用ES6/ES7等ES最新的语法书写的代码转换为浏览器支持的ES版本（如ES5、ES3）。这就让我们开发者能够最快的用上ES的新语法糖 Awesome！！！🎉🎉🎉 Babel在这里用于将我们书写的JSX代码转换为标准javaScript代码，上面的例子就被转换为： 1var foo = h('span', &#123;id: 'example'&#125;, 'Hello, Example') 所以我们需要书写一个h函数用于被转译的代码调用，至于为什么叫h，因为它来源于hyperscript中的h函数。 接下来就是完成一个非常非常简单的h函数： 12345678910111213/*** 创建一个Virtual DOM 对象* @param nodeName 标签名称* @param attributes 属性* @param ...args 组件的孩子*/function h(nodeName, attributes, ...args) &#123; let children = args.length ? [].concat(...args) : null; return &#123; nodeName, attributes, children &#125;&#125; 通过这个函数，我们就能创建一个简单的Virtual Dom对象，比如上面的JSX例子，调用这个函数我们会得到： 1234567&#123; nodeName: "span", attributes: &#123; "id": "example" &#125;, children: ["Hello, Example"]&#125; 当然这个函数是远远不能满足实际生产中的要求，所以后面我们会慢慢完善它。 虚拟DOM转换为真实DOM接下来我们定义一个render函数，用于将Virtual DOM对象渲染为真实的DOM节点。 123456789101112function render(vnode) &#123; if (vnode.split) &#123; return document.createTextNode(vnode); &#125; let node = document.createElement(vnode.nodeName) let attributes = vnode.attributes || &#123;&#125; Object.keys(attributes).forEach(k =&gt; &#123; node.setAttribute(k, attributes[k]) &#125;) (vnode.children || []).forEach(c =&gt; node.appendChild(render(c))) return node&#125; 但是我们通常会将创建出来的真实DOM节点挂在现存的节点上，所以render函数需要改造一下： 1234function render(vnode, container) &#123; //... return container.appendChild(node)&#125;]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Preact</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简析Redis集群]]></title>
    <url>%2F2018%2F11%2F27%2Fredis-cluster%2F</url>
    <content type="text"><![CDATA[Redis Cluster是Redis的分布式解决方案，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster的架构来达到负载均衡的目的。 数据分布分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即将数据姐划分到多个节点上，每个节点只负责整体数据的一个子集。常见的分区规则有顺序分区和哈希分区两种，Redis采用的哈希分区规则。 下面是常见的几种哈希分区规则 节点取余分区使用特定的数据key，再根据节点的数量N使用公式：hash(key)%N计算出哈希值，用来决定数据 映射到哪个节点上。这样的方式比较简单，常用于数据库的分库分表规则，一般采用预分区的的方式，提前根据数据量规划好分区数。但是缺点也比较明显，扩容和收缩时，数据节点的映射关系需要重新计算，会导致数据的重写迁移。 一致性哈希分区系统为每个节点分配一个token，范围一般在0～2^32，这些token构成一个哈希环。数据读写执行时，先根据key计算hash值，然后顺时针找到第一个不小于该哈希值的token节点。相对于节点取余的方式，加入或删除节点只影响哈喜欢中相邻的节点，对其他节点无影响。但是，一致性哈希也存在一些问题：加减节点会造成哈希环中部分数据无法命中；当使用少量节点时，节点变化将大范围影响哈希环中数据映射；普通的一致性哈希分区在增减节点时需要增加一倍或删去一杯节点才能保证数据和负载的均衡。白话解析—一致性哈希算法 虚拟槽分区虚拟槽分区使用分散度良好的哈希函数把所有的数据映射到一个固定范围的整数集合中，整数定义为槽(slot)。Redis Cluster的槽范围为0～16383，远远大于实际中的数据节点数。slot是集群内数据管理和迁移的基本单位。 Redis数据分区Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383整数槽内。每一个结点复制维护一部分槽以及槽所映射的键值数据。这样做的好处是：解耦数据与节点之间的关系；节点自身维护槽的映射关系，不需要客户端或代理服务维护槽分区元数据；支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。 搭建集群搭建集群分为准备节点、节点握手、分配槽等三个步骤。（可以用redis-trib.rb搭建集群，也可以根据Redis手动建立一个集群） 准备节点略 节点握手节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。 分配槽只有把16384个槽全部分配给节点后，集群才进入在线状态。Redis Cluster会把所有数据映射到这16384个槽中，每个key会映射到一个固定的槽中，只有当节点分配了槽，才能响应和这些槽关联的键命令。 节点通信在分布式存储中需要提供维护节点元数据（节点负责哪些数据，是否出现故障等状态信息）信息的机制。Redis Cluster采用用于p2p的Gossip协议，Gossip协议的工作原理就是节点不断通信交换信息，一段时间后所有节点都会知道集群完整的信息，类似流行病传播。 通信过程 集群中每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。 每个节点在固定周期内通过特定规则选择几个节点发送ping消息。 接到ping消息的节点用pong消息作为响应。 Gossip消息Gossip协议的主要职责就是信息交换，信息交换的载体就是节点彼此发送的Gossip消息。常用的Gossip消息分为：ping消息、pong消息、meet消息、fail消息。所有的消息格式划分为消息头和消息体，消息头包含发送节点自身状态数据，接受节点根据消息头就可以获取到发送节点的相关数据。 meet消息：用于通知新节点加入。 ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态消息。 pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方 确认消息正常通信。pong消息内部风中了自身状态数据。 fail消息：当节点判断集群内另一个结点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。 节点选择Redis Cluster内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点选择过多虽然可以做到信息及时交换但成本过高，节点选择过少会降低集群内所有节点彼此信息交换频率，从而影响故障判断、新节点发现等需求的速度。 集群伸缩Redis Cluster提供了灵活的节点扩容和收缩方案，在不影响对外服务的同时，为集群添加节点进行扩容或下线部分节点进行缩容，其中原理可抽象为槽和对应数据在不同节点之间灵活移动。 扩容集群扩容集群的过程为准备新节点、新节点加入集群、迁移槽和数据等三个步骤。 迁移槽和数据槽在迁移过程中，集群可以正常提供读写服务。槽是Redis Cluster数据管理和迁移的最小单位，所以首先需要为新节点制定槽迁移计划。槽迁移计划需要确保每个节点分配的槽数量接近，从而保证各节点的数据均匀。 数据迁移过程是逐个槽进行的，大体流程为：（1）目标节点准备导入槽；（2）源节点准备导出槽；（3）获取槽下{count}个键；（4）批量迁移相关键的数据；（5）循环迁移键，重复第3、4步；（6）通知槽分配给目标节点。 收缩集群收缩集群以为需要下线部分节点，整个过程可分为下线迁移槽、忘记节点等两个步骤。 下线迁移槽与扩容集群中的迁移槽和数据相似～ 忘记节点由于集群内的节点不断通过Gossip消息彼此交换节点状态，所以需要让其他节点不再与要下线的节点进行Gossip消息交换。 请求路由为了追求性能最大化，Redis Cluster采用的是客户端直连节点的方式。 请求重定向在集群模式下，Redis接受任何key相关的命令时首先计算对应的槽，再根据槽找出对应的节点，如果节点是自身，则处理命令；否则返回MOVED重定向错误，通知客户端请求正确的节点。节点对于不属于它的键命令只回复重定向响应，并不负责转发。键命令执行步骤主要分为两步：计算槽、查找槽所对应的节点。 计算槽通过CRC16计算key的有效部分的hash值，再对16383取余，使每个键都能映射到0～16383槽范围内。 槽节点查询Redis计算得到key对应的槽后，需要查询对应的节点。集群内通过消息交换每个节点都会知道所有节点的槽信息，内部保存在clusterState结构中。 Smart客户端Smart客户端在内部维护者从slot-&gt;node的映射关系，本地就可以实现键到节点的查询，从而保证IO效率最大化，而MOVED重定向负责协助Smart客户端更新slot-&gt;node映射。 ASK重定向Redis集群支持在线迁移槽和数据来完成水平伸缩。ASK重定向说明集群正在进行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。但是MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存。 故障转移Redis Cluster实现了高可用，当集群内少量节点出现故障时通过自动故障转移保证集群可以正常的对外提供服务。 故障发现Redis集群内节点通过ping/pong消息实现节点通信，消息不但可以传播节点槽信息，还可以传播主从状态、节点故障等信息，所以故障发现也是通过消息传播机制实现的。 主观下线指某个节点认为另一个节点不可用，即下线状态。 客观下线指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。 故障恢复故障节点变为客观下线后，如果下线节点是持有槽的主节点，则需要从它的从节点中选出一个替换他，从而保证见的高可用。整个大致分为资格检查、准备选举时间、发起选举、选举投票、替换主节点。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简析Redis哨兵实现原理]]></title>
    <url>%2F2018%2F11%2F23%2Fredis-sentinel%2F</url>
    <content type="text"><![CDATA[Redis Sentinel 是一个分布式架构(Sentinel节点、Redis数据节点、Redis客户端分布在不同的物理节点上)，其中包括了若干个Sentinel节点和Redis数据节点，每个Sentinel节点对数据节点和其他Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。若该节点为主节点，它会和其他Sentinel节点共同协商，若大部分节点皆表示该主节点不可达，那么就会从Sentinel中选举出一个Sentinel节点来完成自动故障转移的工作，同时将这个变化实时通知给Redis应用方。 实现原理三个定时监控任务Redis通过三个定时监控任务完成对各个节点的发现和监控。_s_ 获取最新拓扑结构每隔10s，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。 作用： 通过向主节点执行info命令，获取从节点信息，所以Sentinel节点不需要显式配置监控从节点。 当有新的从节点加入时都可以立刻感知出来。 节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。 Sentinel节点发布和订阅sentinel:hello频道每隔2s，每个Sentinel节点会向Redis数据节点的__sentinel__:hello频道发送该sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道来了解其他Sentinel节点以及它们对主节点的判断。 作用： 发现新的Sentinel节点。 Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。 心跳检测每隔1s，每隔Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确定这些节点是否可达。 作用： 判断节点是否可达的重要依据。 主观下线和客观下线主观下线上面提到心跳检测，如果这些节点超过down-after-millionsections还没有进行有效回复，Sentinel节点就会对该节点做失败判断，这个行为叫做主观下线。Sentinel节点、从节点，主观下线后没有后续的故障转移操作。 客观下线当Sentinel节点主观下线的节点是主节点时，该Sentinel节点会通过sentinel is-master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过个数，Sentinel认为主节点的确出现问题，此时该Sentinel对主节点做出客观下线的决定。 领导者Sentinel节点选举当Sentinel节点对主节点完成了客观下线后，Sentinel节点之间还会选举出一个结点作为领导者进行故障转移工作；Redis使用了Raft算法实现领导者选举。 Raft算法大致思路 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线后，会向其他节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。 收到命令的Sentinel节点，如果没有同意过其他的Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，反之拒绝。 如果该Sentinel节点发现自己的票数已经大于或等于max(quorum, num(sentinels) / 2 + 1)，那么它就成为领导者。 如果此过程没有选举出领导者，将进入下一次选举。 基本上谁先完成客观下线，谁就是领导者。 故障转移领导者选举出的Sentinel将负责故障转移。 过程 从节点列表中选举出一个节点作为新的主节点。 过滤掉不主观下线、掉线、5秒内没有回复Sentinel ping响应等等的节点… 选择从节点优先级最高的节点，如果存在则返回，不存在则继续下一步。 选择复制偏移量最大的从节点，如果存在则返回，不存在则继续下一步。 选择runid最小的从节点。 对选举出的节点执行slave of no one，升级为主节点。 Sentinel领导者节点向其他节点发送命令，让它们成为新主节点的从节点。 Sentinel集合节点将原主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>哨兵</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简析Redis复制原理]]></title>
    <url>%2F2018%2F11%2F11%2FRedis-Replication%2F</url>
    <content type="text"><![CDATA[在分布式系统中为了解决单点问题，通常会把数据复制成多个副本部署到不同的机器上，以满足负载均衡和故障恢复等需求，Redis也是如此，Redis支持简单且易用的主从复制（master-slave replication）功能。 复制过程 slave执行slaveof命令，slave只保存master的地址信息后就返回。 slave通过内部每秒运行的定时任务维护复制相关的逻辑，当定时任务发现新的master信息时，开始尝试与master建立网络连接。如果无法建立连接，slave会一直无限次重连直到连接成功或者取消复制。 连接建立成功后slave会发送ping请求进行首次通信，检测主从之间网络套接字是否可用、检测msater当前是否可接受处理命令。 如果master设置了requirepass参数，则需要密码验证。 首次建立复制，主从节点会进行一次全量复制。 同步数据集成功后，master持续把后续的写命令发送给slave，保证主从一致性。 数据同步如何进行数据同步？复制偏移量（offset）参与主从复制的master和slave会保存各自的复制偏移量，slave的复制偏移量初始值为-1。master处理写入命令后，会对自己的复制偏移量进行累加；slave收到master发送的命令后，也会对自己的复制偏移量进行累加，并且slave每秒上报自身的复制偏移量给master，所以master也保存了slave的复制偏移量。倘若主从复制偏移量差距过大，则有可能是因为阻塞或网络延迟高造成的。 复制积压缓冲区复制积压缓冲区是保存在master上的一个固定长度的队列。当master处理写入命令后，不仅会把命令发送给slave，也会把命令写入复制积压缓冲区。复制积压缓冲区用于保存最近已复制数据，可用于部分复制或复制命令丢失的数据补救。 主节点运行ID（runId）每个Redis启动后会动态分配一个40位的十六进制的字符串作为运行ID，运行ID的主要作用是唯一识别Redis节点。如果master运行ID发生变化后，主从节点将进行全量复制。 psync命令slave使用psync命令完成部分复制和全量复制功能，命令格式：psync {runId} {offset}。slave发送psync命令给master，master根据psync的参数和自身数据决定响应结果（全量复制、部分复制、错误）。 全量复制全量复制是redis最早支持的复制方式，也是主从第一次建立后必须经历的阶段。 过程 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点运行ID，所以发送psync ? -1。 主节点根据psync解析当前为全量复制，回复+FULLRESYNC响应。 slave接收到master的响应数据，保存runId和offset。 master开始执行bgsave，保存RDB到本地。 master发送RDB文件给slave，slave接受到RDB文件后存储为自己的数据文件。（如果文件过大，存在超时全量复制失败的风险）。 从slave开始接受RDB到接受完成期间，master仍在处理读写命令。在这期间，master将写命令写入客户端缓冲区，当slave加载完RDB后，再把缓冲区内的数据发送给slave，保证主从之间数据一致性。 slave接受完master传送的数据后会清空自身旧数据。 slave清空数据后开始价值RDB文件，如果RDB文件过大，这个过程非常耗时。如果slave正处于全量复制阶段或者复制中断，那么slave响应读命令时可能拿到过期或错误的数据，数据出现不一致。（可以通过设置slave-serve-stable-data参数来关闭对读命令的响应） slave加载完RDB后，如果slave开启了AOF持久化，它会立即执行bgrewriteaof操作，保证全量复制后AOF持久化文件立刻可用。 时间开销 master bgsave时间 RDB文件网络传输时间 salve清空数据时间 slave加载RDB时间 可能的AOF重写时间 由此可见，全量复制的时间开销大，除此之外，全量复制过程中也会消耗大量的CPU、内存、网络资源。所以除了第一次复制采用全量复制，其余场景应该规避全量复制的发生。 部分复制部分复制主要是Redis针对全量复制过高开销作出的一种优化措施。当slave正在复制master时，如果出现网络闪断或者命令丢失等异常情况时，slave会向master要求补发丢失的命令数据，如果master的复制积压缓冲区内存在这部分数据则之间发给slave，这样可以确保主从节点复制的一致性。补发的这部分数据一般远远小于全量数据，所以开销很小。 过程 主从节点之间网络出现中断时，如果超过repl-timeout时间，master会认为slave故障并中断复制连接。 主从连接中断期间master依然响应客户端的命令，但复制连接中断命令无法发送给slave，不过master内部存在复制积压缓冲区，可以保存最近一段时间的命令数据，默认最大缓存1MB。 主从节点网络恢复后，slave再次连上master。 主从连接恢复后，由于slave保存了自身已复制的偏移量和主节点的运行ID，此时将他们作为参数发送给master，要求进行部分复制。 master接到psync命令后进行核对，然后根据offset在自身复制积压缓冲区插座，如果数据存在于缓冲区，则对slave发送+CONTINUE响应，表示可以进行部分复制。 master根据offset把复制积压缓冲区里的数据发送给slave，保证主从复制进入正常状态。 异步复制（写命令同步）master不仅负责数据读写，还负责把写命令同步给slave。写命令的发送是异步完成，master自身处理完写命令后直接返回给客户端，并不等待slave复制完成。由于主从复制过程是异步的，就会造成salve数据相对master存在延迟。 心跳机制主从节点建立复制后，它们之间维护着长连接并彼此发送心跳命令。 主从心跳判断机制 主从节点各自都有心跳检测机制，各自模拟成对方的客户端进行通信。 master默认每隔10s对slave发送ping命令，判断slave的存活性和连接状态。 slave每隔1s对master发送replconf ack {offset}命令，给master上报自身当前的复制偏移量。replconf命令常用于检测主从节点网络状态、上报自身复制偏移量，检测复制数据是否丢失，如果slave数据丢失，再从master的复制缓冲区拉取丢失数据。、实现保证slave的数量和延迟性功能。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解Redis中的持久化机制]]></title>
    <url>%2F2018%2F11%2F09%2FRedis-Rersistence%2F</url>
    <content type="text"><![CDATA[什么是持久化？为什么需要持久化？持久化就是将内存中的数据模型转换为存储模型，更通俗的说，就是将数据保存到系统硬盘中。 Redis所有的数据都是存在内存中，一旦程序崩溃或重启，内存中的数据就会丢失，所以我们需要持久化。 RDB（默认开启）介绍RDB持久化是把当前进程数据生成快照保存到硬盘的过程，适用于备份、全量复制等场景。 过程 执行bgsave命令，父进程判断当前是否有正在执行的子进程如AOF子进程，若有直接返回。 父进程执行fork操作创建子进程，fork操作会阻塞父进程。 fork完成后，父进程处理其他命令。 子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对旧文件进行原子替换。 子进程发送信号通知父进程表示完成，父进程更新统计消息。 优点 RDB是一个非常紧凑的二进制文件，保存着Redis在某个时间节点上的数据集，非常适合备份、全量复制等场景。 RDB非常适用于灾难恢复，因为它只有一个文件并且非常紧凑，可以加密后传送到其他数据中心。 父进程保存RDB文件时仅仅需要花费fork一个子进程的时间，无需执行任何磁盘I/O操作。 Redis加载RDB恢复数据远远快于AOF的方式。 缺点 因为RDB文件需要保存整个数据集的状态，花费数分钟的时间，所以一旦发生故障停机，可能会丢失数分钟的数据。 每次保存RDB时，Redis需要fork一个子进程，并由子进程进行数据持久化；如果数据集很庞大，fork()可能会非常耗时，造成服务器在短时间（毫秒级）内停止处理客户端；如果CPU比较紧张，fork过程可能长达整整一秒。 AOF介绍AOF持久化是以独立的日志记录每次写命令，Redis重启的时候执行AOF文件中的命令来恢复数据。 过程 所有写命令都会追加到AOF缓冲区。 AOF缓冲区根据对应的策略向硬盘做同步操作。 随着AOF文件越来越大，需要定期对AOF文件进行重写以达到压缩的目的。 AOF缓冲区同步文件策略可以配置Redis多久将数据同步到磁盘一次。 always: 每次有写命令追加到AOF缓冲区时就调用系统fsync操作同步到AOF文件。 everysec：命令写入AOF缓冲区后调用系统write操作，fsync同步文件操作由专门线程每秒调用一次。 no：命令写入AOF缓冲区后调用系统write操作，不对AOF文件做fsync操作，同步硬盘由系统负责，通常同步周期为30s。 AOF重写机制AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。（因为重写AOF文件时，Redis会合并多条写命令、丢弃超时的数据、删除无效命令，所以重写后的AOF文件要小于旧文件） 优点 使用AOF持久化使得Redis更加耐久，AOF缓冲区同步文件策略可以使得Redis就算发生故障停机，也最多丢失1s的数据（实际上最多为2s）。 AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，文件内容易懂且容易分析、导出。 缺点 AOF文件的体积通常大于RDB文件的体积。 AOF的速度可能慢于RDB。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>持久化 缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门之初级排序]]></title>
    <url>%2F2018%2F10%2F03%2Fsort-1%2F</url>
    <content type="text"><![CDATA[稳定性指排序前后两个相等的数相对位置不变，则算法稳定； 稳定排序：基数排序、冒泡排序、插入排序、归并排序 非稳定排序：堆排序、快速排序、希尔排序、选择排序 下面是常见排序的简单介绍及实现。 冒泡排序 稳定排序 小的元素往前调或者把大的元素往后调； 比较是相邻的两个元素比较，交换也发生在这两个元素之间； 实现： 12345678910111213141516function bubbleSort(arr) &#123; // 遍历数组，若当前元素大于右边的元素，则二者交换位置，较大的元素继续往后比较 // 若当前元素小于右边的元素，则以右边的元素开始继续往后方比较 // 表现：大元素逐渐冒泡到数组后方 const len = arr.length; for(let i = len; i &gt; 0; i--) &#123; for(let j = 1; j &lt; i; j++) &#123; if (arr[j] &lt; arr[j-1]) &#123; let temp = arr[j-1]; arr[j-1] = arr[j] arr[j] = temp; &#125; &#125; &#125; console.log(arr)&#125; 选择排序 不稳定排序 每个位置选择当前元素最小的； 在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了； 实现： 123456789101112function selectSort(arr) &#123; const len = arr.length; for(let i = len - 1; i &gt; 0; i--) &#123; for(let j = 0; j &lt; i; j++) &#123; if (arr[i] &lt; arr[j]) &#123; let temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125;&#125; 插入排序 已经有序的小序列的基础上，一次插入一个元素； 想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置； 如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面； 实现 123456789101112function insertSort(arr) &#123; const len = arr.length; for(let i = 1; i &lt; len; i++) &#123; for(let j = i; j &gt;= 0; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; let temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125;&#125; 希尔排序 按照不同步长对元素进行插入排序； 当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快； 当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高； 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱； 123456789101112131415function shellSort(arr, gapArr) &#123; const len = arr.length; for(let k = 0; k &lt; gapArr.length; k++) &#123; let gap = gapArr[k]; for(let i = gap; i &lt; len; i++) &#123; for(let j = i; j &gt;= 0; j -= gap) &#123; if (arr[j] &lt; arr[j-gap]) &#123; let temp = arr[j]; arr[j] = arr[j-gap]; arr[j-gap] = temp; &#125; &#125; &#125; &#125;&#125; 快速排序 首先，从数组中选择中间一项作为主元 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。 移动左指 针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们 重复这个过程，直到左指针超过了右指针；这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。 接着，算法对划分后的小数组(较主元小的值组成的子数组，以及较主元大的值组成的 子数组)重复之前的两个步骤，直至数组已完全排序。 不稳定发生在中枢元素和a[j] 交换的时刻； 12345678910111213141516171819202122232425function quickSort(arr) &#123; function partition(arr, left, right) &#123; let pivot = arr[Math.floor((left+right) / 2)]; let i = left, j = right; while(i &lt;= j) &#123; while(arr[i] &lt; pivot) i++ while(pivot &lt; arr[j]) j-- if (i &lt;= j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]; i++ j-- &#125; &#125; return i; &#125; function qSort(arr, left, right) &#123; let pivot if (left &lt; right) &#123; pivot = partition(arr, left, right); if (left &lt; pivot-1) qSort(arr, left, pivot-1) if (right &gt; pivot) qSort(arr, pivot, right) &#125; &#125; qSort(arr, 0, arr.length-1)&#125; 枢纽元的选择： 固定首位或末位 随机选择 三数中值法，首、尾、中间选择中间值 快排的优化： 当待排序序列的长度分割到一定大小后，使用插入排序。 在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割 在一次分割结束后，将与本次基准相等的元素聚集在一起，再分割时，不再对聚集过的元素进行分割。具体过程有两步 在划分过程中将与基准值相等的元素放入数组两端。 划分结束后，再将两端的元素移到基准值周围。 优化递归操作，尾递归优化 “优化不必要的交换” 归并排序 把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序； 合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性； 非原地归并 1234567891011121314151617181920212223242526function mergeSort(arr) &#123; function innerMergeSort(arr) &#123; const len = arr.length; if (len === 1) return arr; let mid = Math.floor(len / 2), left = arr.slice(0, mid), right = arr.slice(mid, len); return merge(innerMergeSort(left), innerMergeSort(right)); &#125; function merge(left, right) &#123; const result = []; let i = 0, j = 0; const leftLength = left.length; const rightLength = right.length; while(i &lt; leftLength &amp;&amp; j &lt; rightLength) &#123; if (left[i] &lt; right[j]) result.push(left[i++]) else result.push(right[j++]) &#125; while(i &lt; leftLength) &#123; result.push(left[i++]) &#125; while(j &lt; rightLength) &#123; result.push(right[j++]) &#125; return result; &#125; return innerMergeSort(arr)&#125; 原地归并 1234567891011121314151617181920212223242526function mergeSort(arr) &#123; let aux = [] // 辅助数组 function innerMergeSort(arr, left, right) &#123; if (right - left &gt; 1) &#123; let mid = Math.floor((right + left) / 2); console.log(left, mid, right) innerMergeSort(arr, left, mid); innerMergeSort(arr, mid+1, right); merge(arr, left, mid, right); &#125; else if(right - left === 1) &#123; if (arr[left] &gt; arr[right]) [arr[left], arr[right]] = [arr[right], arr[left]] &#125; &#125; function merge(arr, left, mid, right) &#123; let i = left, j = mid+1 for(let k = left; k &lt;= right; k++) aux[k] = arr[k] for(let k = left; k &lt;= right; k++) &#123; if (i &gt; mid) arr[k] = aux[j++] // 左半边用尽（取用右半边的元素） else if(j &gt; right) arr[k] = aux[i++] // 右半边用尽（取用左半边的元素） else if(aux[i] &lt; aux[j]) arr[k] = aux[i++] // 左半边当前元素小于右半边当前元素（取用左半边的元素） else arr[k] = aux[j++] // // 左半边当前元素大于右半边当前元素（取用右半边的元素） &#125; &#125; innerMergeSort(arr, 0, arr.length-1)&#125; 基数排序 按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位； 有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前； 用于整数； 需要较多的存储空间； 基于分别排序，分别收集； 堆排序 堆的性质 完全二叉树 每个节点的值大于或等于其右左孩子节点【大顶堆】；反之，小顶堆 节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点；小顶堆要求父节点小于等于其2个子节点 堆排序：选择排序的一种 将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。 将其与堆数组末尾元素交换，再将剩余的n-1个序列重新构成一个堆，这样就得到n个元素的次大值；反复执行，就能得到一个有序序列了。 实现 构造堆 输出堆顶元素后，调整剩余元素成为一个新的堆 12345678910111213141516171819202122232425262728function heapSort(arr) &#123; let heapSize = arr.length; buildHeap(arr); while(heapSize &gt; 1) &#123; heapSize--; [arr[0], arr[heapSize]] = [arr[heapSize], arr[0]] heapify(arr, heapSize, 0) &#125; function buildHeap(arr) &#123; // 处理有子节点的节点 for(let i = Math.floor(arr.length / 2); i &gt;= 0; i--) &#123; heapify(arr, heapSize, i) &#125; &#125; // 保证 arr[parent] &gt; arr[parent*2+1]与arr[parent*2+2] function heapify(arr, heapSize, i) &#123; let left = 2*i+1, right = 2*i+2; let largest = i; if (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) largest = left; if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) largest = right; if (largest !== i) &#123; [arr[i], arr[largest]] = [arr[largest], arr[i]]; // 交换根节点与最大节点的位置，根节点的值可能小于其子节点 需要再来一次heapify heapify(arr, heapSize, largest) &#125; &#125;&#125; ###]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Diff]]></title>
    <url>%2F2018%2F09%2F23%2Freact-diff%2F</url>
    <content type="text"><![CDATA[计算一棵树形结构转换成另一棵树形结构，传统的diff算法算法复杂度达到O(n^3)。React通过制定策略，将O(n^3)复杂度的问题转换成O(n)复杂度。 Diff 策略 Web UI 中DOM节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一id进行区分。 Tree Diff对树进行分层比较，两棵树只会对同一层次的节点进行比较。 当节点跨层级移动时，并不会出现想象中的移动操作，而是进行create-delete操作（影响性能）。 Component Diff 如果是同类型的组件，按原策略继续比较Virtual DOM tree。 如果不是同类型的组件，则将组件判断为dirty component，从而替换整个组件下的所有子节点。 如果是同一类型的组件，并且Virtual DOM没有发生变化，那么将会省下大量的diff运算时间，因此React允许用户通过shouldComponentUpdate()来判断组件是否需要进行diff。 Element Diff当节点处于同一层级时，React Diff提供了三种节点操作，分别为：INSERT_MARKUP、MOVE_EXISTING、REMOVE_NODE INSERT_MARKUP: 原集合不包含新的component类型，新节点需执行插入操作 MOVE_EXISTING: 原集合包含新的component类型，且element时可更新的类型，generateComponentChildren已调用receiveComponet，这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。 REMOVE_NODE: 老compone类型，在新集合也有，但对应的element不同则不能直接复用和更新，需执行删除操作，或者老component不在新集合中，也需要执行删除操作。 允许开发者对同一层级的同组子节点添加唯一key作为标识。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JavaScript之Event Loop]]></title>
    <url>%2F2018%2F06%2F27%2Fevent-loop%2F</url>
    <content type="text"><![CDATA[前言最近阅读《高性能JavaScript》时，第六章谈到“通过定时器将JavaScript执行代码的控制权先让给浏览器用于更新UI状态，然后再将控制权交回给JavaScript代码，这样就可以使得页面更为流畅”，就联想到了之前理解的事件循环。 这篇文章就是为了解释为什么这么做可以提升页面的流畅度。 事件循环（Event Loop） 单线程的JavaScript总所周知，JavaScript语言的一大特点就是单线程，也就是说在一个时间段里，JavaScript只能做一件事情（浏览器是多线程）。多线程可以实现应用的并行处理，从而以更高的CPU利用率提高整个应用程序的性能和吞吐量。 但是JavaScript却以单线程进行，为什么呢？ JavaScript是浏览器脚本语言，用于与用户交互以及操作DOM。考虑如下情况，如果有两个并发的操作，对同一个DOM节点分别进行删除和修改样式，此时浏览器就无法决定到底采用哪个线程的操作。类似数据库，我们可以采用“锁”来处理并发，但是这会平添复杂度。所以，JavaScript语言没有支持多线程操作。那又考虑这种情况，既然JavaScript是单线程，在某一时刻内只能执行特定的一个任务，并且会阻塞其它任务执行。那么如果用户触发了一个非常耗时的I/O操作，那么按道理后续的所有操作都得等到I/O操作完成后方可进行。但是，事实上，后续的任务不必等待这个耗时的I/O操作完成，原因就是JavaScript与生俱来的异步和回调。 而这背后恰好就是本文的主题——————事件循环 定义事件循环包含了至少两个任务队列，宏任务队列和微任务队列。 宏任务宏任务包含创建文档对象、解析HTML、执行主线JavaScript代码、更改当前URL以及各种事件，例如页面加载、输入、网络事件和定时器等等。宏任务运行完成后，浏览器继续其他的任务调度，如重新渲染页面或者垃圾回收。 微任务微任务包括promise、回调函数、DOM发生变化等。微任务更新应用程序的状态，必须在浏览器任务继续执行其他任务（渲染UI视图或者进行下一个宏任务）之前执行。 两个基本原则 一次处理一个任务 一个任务开始直到运行完成，不会被其他任务中断 无论是宏任务队列还是微任务队列，二者在同一时刻都只执行一个任务，不过二者也有重要的区别：在一次循环中，最多处理一个宏任务，而微任务队列中所有的微任务都会被处理。 在微任务队列清空后，事件循环会检查当前是否需要重新渲染UI，如果需要则渲染UI视图。 补充 两个任务队列都是独立于事件循环的，这意味着任务队列的添加发生在事件循环外。 所有微任务都会在下一次渲染前完成，目的是在渲染前更新应用程序状态。 浏览器会尝试以每秒渲染60次页面，以达到每秒60帧的速度。所以，一次循环最理想的时间应该不超过16ms。 浏览器完成页面渲染后，进入下一轮事件循环迭代后，可能出现3种情况 如果事件循环执行到“is rendering needed”且浏览器处于另一个16ms结束之前（即浏览器尚未自动触发页面渲染时），浏览器可能不会选择在当前的时间循环中执行更新UI操作，因为更新UI是一个复杂且耗性能的操作。 如果事件循环执行到“is rendering needed”且浏览器刚好离上一次渲染16ms左右时（即浏览器即将自动触发页面渲染时），此时浏览器会进行UI更新。 执行下一个事件循环耗时超过16ms，浏览器将无法以目标帧率重新渲染页面，且UI无法被更新。如果延迟不大是很难察觉到，但是，如果有非常耗时的操作，这个时候用户会觉得网页十分卡顿，甚至浏览器会提示“无响应脚本”。 前情回顾现在，用事件循环和简单的例子来分析《高性能的JavaScript》中的那句话。需求：给包含1000个数字的数组中的每个元素取绝对值（假设对一个数字进行需求操作耗时1ms）。 情况1（不使用定时器）:由于JavaScript主线程代码属于宏任务的一种，所以一次事件循环需要处理1000个数字，所以1s事件循环才进行到UI更新阶段，但是由于耗时过长，UI状态不会被更新，页面出现卡顿甚至堵塞。 情况2（使用定时器）：将一次处理1000个数字的任务分割为20个每次处理50个数字的任务。由于定时器是宏任务的一种，所以一次事件循环只处理50个数字，由于此时微任务队列为空，所以50ms后事件循环进行到UI更新阶段，然后根据情况进行UI渲染，页面未出现卡顿或者堵塞。 当然，如果只是单纯的处理数据，我们可以考虑使用Web Workers。 总结 JavaScript是单线程的，同一时刻是只能执行一个任务。 事件循环包含一个宏任务队列和至少一个微任务队列。事件循环一次迭代，至多执行一个宏任务但是会执行完所有的微任务。 Web应用越复杂，积极主动管理UI线程就越重要，即使JavaScript代码很重要，也不能影响用户体验。 参考 《High Performance JavaScript》 《Secrets of the JavaScript Ninja》 《HTML 5.2》]]></content>
      <categories>
        <category>JavaScript核心</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Nginx二级域名并部署hexo博客]]></title>
    <url>%2F2018%2F05%2F09%2Fhow-to-deploy-a-static-website%2F</url>
    <content type="text"><![CDATA[因为有不同的项目需要部署，所以我打算为每个项目分配一个二级域名。下面是整个流程的复盘: 安装nginx和gityum -y install nginx git 获取资源文件 新建 /var/www/blog 目录：mkidr /var/www/blog 切换到blog目录下并获取文件： cd /var/www/blog &amp;&amp; git clone git@github.com:GeniusFunny/GeniusFunny.github.io.git, 此时blog目录下有一个GeniusFunny.github.io文件夹，这就是我的hexo资源文件夹，配置.conf文件时会用到。 DNS添加二级域名前往你购买的服务器商（我购买的是腾讯云的服务）为在域名解析中添加解析记录，如图所示：点击添加记录，在主机记录添加你要的域名（如blog），在记录值处填写服务器的ip地址。那么就有一个新的域名，如:blog.geniusfunny.xyz。添加完成后，我们就开始配置我们的nginx。 nginx配置二级域名并部署 进入nginx默认配置文件vim /etc/nginx/nginx.conf 在http模块中添加一行代码（引入sites-enabled文件夹）：include /etc/nginx/sites-enabled/*; 在当前目录下，新建一个sites-enabled文件夹：mkdir sites-enabled 进入sites-enabled文件夹，添加以二级域名（blog.geniusfunny.xyz）为名称的配置文件: vim blog.geniusfunny.xyz 配置二级域名配置文件如下： 123456server &#123; listen 80; server_name blog.geniusfunny.xyz; root /var/www/blog/GeniusFunny.github.io; //这是我们的资源文件目录 index index.html index.htm index.nginx-debian.html;&#125; 配置快捷linux命令 进入.bashrc文件，vim ~/.bashrc 添加快捷linux自定义命令，alias myBlog=&#39;cd /var/www/blog/GeniusFunny.github.io, 保存 使.bashrc文件生效，source ~/.bashrc 以后我们就可以在根目录下输入myBlog进入资源文件夹目录，然后git pull，获取最新的资源 常用的关于nginx的命令检查nginx配置：nginx -t nginx.conf开启nginx服务：nginx关闭nginx服务：nginx -s stop强制关闭nginx服务：pkill -9 nginx重启nginx服务：nginx -s reload]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一行url到一个页面我们经历了什么？(更新中)]]></title>
    <url>%2F2018%2F05%2F03%2Fweb-life-cycle%2F</url>
    <content type="text"><![CDATA[当我们在浏览器地址栏输入一行url，整个页面呈现，整个过程发生了什么？我大致把整个过程分为两个部分，即网络行为与页面周期。浏览器缓存 —&gt; DNS —&gt; TCP连接 –&gt; HTTP请求/响应 —&gt; 构建页面 —&gt; 事件处理 网络行为浏览器缓存机制浏览器和服务器是应答模式，即：浏览器发起HTTP请求 —&gt; 服务器返回响应。如果是第一次发起请求，浏览器会根据拿到的HTTP响应头的配置来决定是否缓存此次的响应结果。过程如下：1. 浏览器每次发起HTTP请求时，都会根据请求去浏览器缓存中匹配对应的请求结果和缓存标识。2. 浏览器每次成功获取到请求结果，都会将请求结果和缓存标识存入浏览器缓存。根据浏览器是否需要向服务器重新发起HTTP请求，将缓存过程分为了两部分：强制缓存与协商缓存 强制缓存概念强制缓存就是向浏览器缓存查找对应的请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。 场景一：不存在该请求对应的缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求如果浏览器缓存中不存在对应的缓存结果和缓存标识，那么浏览器会重新向服务器发起HTTP请求。 场景二： 存在该请求对应的缓存结果和缓存标识但已失效，强制缓存失效，采用协商缓存如果浏览器缓存中存在对应的缓存结果和缓存标识，但缓存已经失效（过期），那么浏览器会采用协商缓存。 场景三： 存在该请求对应的缓存结果和缓存标识且尚未失效，强制缓存生效，直接返回该结果如果浏览器缓存中存在对应的缓存结果和缓存标识且缓存尚未失效，那么浏览器缓存直接返回缓存结果。 规则强制缓存与HTTP响应头中的字段Cache-Control和Expires有关，Cache-Control优先于Expires。Cache-Control: HTTP/1.1，主要取值如下： public: 响应可以被任何缓存区（客户端、代理服务器）缓存 private: 响应只可以被客户端缓存（Cache-Control默认值） no-cache: 可以存储在本地缓存中，但需要与服务器进行验证后方可使用 no-store: 禁止缓存对响应进行复制 max-age=xxx: 缓存将在xxx秒后过期Expires: HTTP/1.0, 附加一个Expires日期首部到响应中去,这个日期为绝对日期，例如：Expires: Fri, 05 Jul 2002, 05:00:00 GMT 协商缓存概念协商缓存就是在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 场景一： 协商缓存生效，返回304如果服务器提示资源尚未失效，则返回304，浏览器可继续使用浏览器缓存中该资源的缓存结果。 场景二： 协商缓存失效，返回200如果服务器提示资源尚已失效，则返回200，服务器重新返回最新的资源，浏览器将缓存结果和缓存标识存入浏览器缓存。 规则HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象的主体。—- 《HTTP权威指南》协商缓存与HTTP头中的字段Last-Modified / If-Modified-Since（请求头）和Etag / If-None-Match(请求头)有关，Etag / If-None-Match优先级比Last-Modified / If-Modified-Since高。Last-Modified / If-Modified-Since:If-Modified-Since:Date再验证请求通常被称为IMS请求，只有某个日期之后资源发生了改变，IMS请求才会指示服务器执行请求：1.如果自指定日期后，资源更新了，If-Modified-Since条件就为真，通常GET就会执行，携带新首部（除了其他信息还有一个新的过期日期）的新资源就会返回给缓存。2.如果自指定日期后，资源未更新，If-Modified-Since条件就为假，就会向客户端返回一个小的304 Not Modified 响应报文，为了提高有效性，报文中不会包含资源的主体。例：If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMTEtag / If-None-Match 实体标签再验证:有些情况（周期性地重写、资源修改无影响的部分、有些服务器无法准确判断其页面的最后修改时间等等）下仅根据修改日期进行再验证是不够的，HTTP允许用户对被称为实体标签（Etag）的“版本标识符”进行比较。当发布者对资源进行修改时，就可以修改资源的实体标签来说明这是一个新版本。1.如果实体标签仍匹配，If-None-Match再验证成功，返回304 Not Modified。2.如果服务器上的实体标签已经发生了变化，服务器会在一个200 OK 响应中返回新的内容及相应的新Etag。例：If-None-Match: “v2.6”If-None-Match: “v2.4”, “v2.5” 浏览器的缓存放在哪里？浏览器的缓存通常存放入硬盘（from disk cache）或内存（from memory cache）。 from disk cache硬盘缓存(from disk cache)则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 from memory cache内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。时效性：一旦该进程关闭，则该进程的内存则会清空。 规则在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 缓存有什么优点？ 减少了数据的冗余传输 缓解了网络的带宽瓶颈问题 减轻了服务器的负担 减轻了距离时延 缓存与cookie缓存那些与cookie事务有关的文档时要特别小心，cookie和缓存的规则没有很好地建立起来。下面是处理缓存时的一些指导性规则： 如果无法缓存文档，要将其表示出来。如对不可缓存的文档设置：Cache-Control:no-cache=”Set-Cookie”，对可缓存的文档设置： Cache-Control:public。 缓存Set-Cookie首部要小心。如果向多个用户发送了相同的Set-Cookie首部可能会破坏用户的定位；有些缓存会在将响应缓存起来之前删除Set-Cookie首部，那么请求缓存的时候客户端就拿不到cookie了。强制缓存与原始服务器重新验证每条请求，并将Set-Cookie首部合并到客户端的响应中去，就可以改善这种情况，原始服务器可向缓存副本添加这个首部来进行这种验证：Cache-Control: must-revalidate, max-age=0 小心处理带有cookie首部的请求带有cookie的请求结果到达时，就是提示我们，这个请求结果可能是私有内容，必须将私有内容标识为不可缓存。 DNS概览DNS（Domain Name System，域名解析系统）的作用是将主机名（hostname）解析为对应的IP地址。DNS是一个由分层的DNS服务器实现的分布式数据库，一个使得主机能够查询分布式数据库的应用层协议。DNS协议运行在UDP上，使用53号端口。 常规流程 浏览器从URL中抽出主机名，将其发送给运行中的DNS应用客户端。 DNS客户端向DNS服务器发送一个带有主机名的请求。 DNS客户端会收到来自DNS服务器的回答报文，其中包含了与主机名对应的IP地址。 浏览器获取到IP地址，向位于该地址的服务器进程的某个端口（HTTP为80端口，HTTPS为443端口）发起一个TCP连接。 分布式、层次数据库DNS服务器层次结构中的DNS服务器大致有三种，根DNS服务器、顶级域DNS服务器、权威DNS服务器。根DNS服务器—&gt;顶级域DNS服务器—&gt;权威DNS服务器（自顶向下）。如果要查询www.baidu.com对应的IP地址，查询过程大致如下（分级查询）： 首先跟根服务器之一联系，获得顶级域名com的TLD服务器的IP地址。 然后TLD服务器之一联系，获得baidu.com权威服务器的IP地址。 最后与baidu.com权威服务器之一联系，获得主机名www.baidu.com对应的IP地址。 除此之外，还有一类DNS服务器很重要，即：本地DNS服务器（尽管它不在DNS服务器层次结构中）。每个ISP都有一个本地DNS服务器，当主机与该ISP连接时，ISP会返回一个IP地址，该地址具有一台或多台的本地DNS服务器的IP地址。当主机发起DNS请求时，请求被发送到本地DNS服务器，它起着代理和将请求转发到DNS服务器层次结构中（类似HTTP的代理服务器）。从请求主机到本地DNS服务器的查询是递归查询（因为查询请求是以自己的名义，查询结果直接返回给请求主机），其余为迭代查询（查询请求是以本地DNS服务器为名义，返回的结果也是给本地DNS服务器） DNS缓存为了改善实验性能并减少在因特网上到处传播的DNS报文数量，DNS广泛使用了缓存技术。在一个请求链中，当某个DNS服务器接收到一个DNS回答时，它能将该信息缓存在本地存储器中（例如，共用一个ISP的小明、小红，如果小明查询了www.baidu.com的IP地址，那么这个IP地址就存在了本地DNS服务器中，在缓存失效前，小红可以直接在本地DNS服务器中获取到www.baidu.com的IP地址）。本地服务器能够缓存顶级域服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。 TCP连接一个TCP连接是由一对端点或套接字构成，其中通信的每一端都由一对（IP地址，端口号）所唯一标识。一个TCP连接通常分为三个阶段：启动（三次握手）、数据传输、退出（四次挥手）。 三次握手概览如图所示，客户端中的TCP会用一下方式与服务器中TCP建立一条TCP连接： 第一步，客户端的TCP首先向服务器的TCP发送一个特殊的TCP报文段，该报文段不包含应用层的数据，但是在报文段的首部中的一个标志位（即SYN比特）被置为1，因此这个特殊报文段被称为SYN报文段。客户端会随机选择一个初始序号（J）并将此序号放置于该起始的TCP SYN报文段的序号字段里，整个报文字段会封装在一个IP数据报中并发给服务器。此时，客户端进入SYN-SENT状态。 第二步，一旦包含TCP SYN报文段的IP数据报到达了服务器，服务器就会从数据报中提取出TCP SYN报文段，为该TCP连接分配缓存和变量，并向客户端发送允许连接的报文段（ACK(J + 1)），该报文段也不包含应用层数据。与此同时服务器也随机选择一个初始序号（K）并将此序号放置于TCP报文段首部的序号字段中，即（SYN(K)）,随确认字段ACK一并发送给客户端。此报文字段通常被称为SYNACK报文段，此时服务器进入SYN-RECEIVED状态。 第三步，客户端接收到SYNACK报文段，为该连接分配缓存和变量，此时客户端进入ESTABLISHED状态。客户端向服务器发送另外一个报文段，这个报文段是对服务器的允许连接的报文段的确认（ACK(K + 1)），与前两次不同，这次报文段中可携带应用层数据，由于连接已经建立，SYN比特被置为0。服务器收到这个报文段后，也进入ESTABISHED状态。完成这三个步骤后，客户端和服务器的每一个报文段中都可以携带应用层的数据，且SYN比特都将被置为0。建立TCP连接的三个步骤也被称为TCP三次握手。三次握手的目的不仅在于让通信双方了解一个连接正在建立， 还在于利用数据包的选项来承载特殊的信息，交换初始序列号。——-《TCP/IP 详解 卷一：协议》 为什么是三次握手？为什么不是两次握手？三次握手：A—-&gt;B: [A: I’m A.]B—-&gt;A: [B: Hello A, I’m B.]A—-&gt;B: [A: Hello B, nice to meet you.]然后愉快的py 二次握手：A—-&gt;B: [I’m A.]B—-&gt;A: [Hello A, I’m B.]如果A收到了“Hello A,I’m B”，愉快的py如果A没有收到“Hello A,I’m B”，那么while(true){ A—-&gt;B: [I’m A.] }, 疯狂握手三次握手的目的是确认A—&gt;B, B—&gt;A这两个信道都是可靠的；如果只有两次握手就无法确认B—&gt;A的信道是否可靠。如果只需要A—&gt;B信道可靠，那就类似于UDP的需求了。 四次挥手概览连接的任何一方都可以发起关闭连接，在传统情况下往往由客户端来发起关闭连接，如下图所示。 第一步：客户端发送FIN包（包含了客户端的序列号M)，此外FIN包还包含了一个ACK段用于确认对方最后一次发送的数据。 第二步：服务器收到客户端发送的FIN包后，将M值+1作为响应的ACK值，表明它已经成功接收到来自客户端发送的FIN。此时，处于上层的应用程序会被告知连接的另一方发起了关闭连接的请求，这将导致应用程序发动自己的关闭操作。服务器从被动关闭者变为主动关闭者，向客户端发送FIN(包含了服务器的序列号N)。 第三步：为了完成连接的关闭，客户端发往服务器最后的报文段中包含了一个确认服务器发送的FIN的ACK字段。 为什么是四次挥手？四次挥手：A —&gt; B, [A: ‘我想关闭连接’]B —&gt; A, [B: ‘好的，我知道了，我不要收到你的东西了’]B —&gt; A, [B: ‘我想关闭连接’]A —&gt; B, [A: ‘好的，我知道了，我也不要收到你的东西了’]主动方发送关闭请求，被动方接受并确认请求后，被动方就无法收到主动方发送的数据了。在前两次挥手后，服务器就无法收到客户端发送的数据了（服务器释放了关于客户端的资源），但是服务器可以给客户端发送数据，所以有了第三次、第四次挥手。 页面周期概览页面构建DOM TreeStyle RulesRendering Tree事件处理参考文献： 彻底理解浏览器的缓存机制 图解TCP三次握手与四次分手 《HTTP权威指南》 《JavaScript忍者秘籍》 《计算机网络（自顶向下方法）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web缓存</tag>
        <tag>网络</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止书写回调函数并爱上ES8]]></title>
    <url>%2F2018%2F04%2F14%2Fasync-await%2F</url>
    <content type="text"><![CDATA[停止书写回调函数并爱上ES8以前，JavaScript项目会逐渐‘失去控制’，其中主要一个原因就是采用传统的回调函数处理异步任务时，一旦业务逻辑比较复杂，我们就难免书写一些冗长、复杂、嵌套的代码块（回调地狱），这会严重降低代码的可读性与可维护性。现在，JavaScript提供了一种新的语法糖来取代回调函数，使我们能够编写简明、可读性高的异步代码。 背景AJAX先来回顾一下历史。在20世纪90年代后期，Ajax是异步JavaScript的第一个重大突破。这一技术允许网站在加载HTML后获取并显示最新的数据，这是一个革命性的想法。在这之前，大多数网站会再次下载整个页面来显示更新的内容。这一技术(在jQuery中以ajax的名称流行)主导了2000-2010的web开发并且Ajax是目前网站用来获取数据的主要技术，但是XML在很大程度上取代了JSON。 NodeJS当NodeJS在2009年首次发布时，服务器端环境的主要焦点是允许程序优雅地处理并发性。大多数服务器端语言通过阻塞代码来处理I/O操作，直到操作完成为止。相反，NodeJS使用的是事件循环机制，这样开发人员可以在非阻塞异步操作完成后，调用回调函数来处理逻辑（类似于Ajax的工作方式）。 Promises几年后，NodeJS和浏览器环境中出现了一种新的标准，称为”Promise”，Promise提供了一种强大的、标准化的方式来组成异步操作。Promise仍然使用基于回调的格式，但为链式和组合异步操作提供了一致的语法。在2015年，由流行的开源库所倡导的Promise最终被添加为JavaScript的原生特性。Promise是一个不错的改进，但它们仍然常常是一些冗长而难以阅读的代码块的原因。而现在有了一个解决方案。Async/Await是一种新的语法(从.net和C#中借用)，它允许我们编写Promise，但它们看起来像是同步代码，没有回调，可以用来简化几乎任何现有的JS应用程序。Async/Await是JavaScript语言的新增的特性，在ES7中被正式添加为JavaScript的原生特性。 示例我们将通过一些代码示例来展示Async/Await的魅力 *注：运行下面的示例不需要任何库。Async/Await已经被最新版本的Chrome、FireFox、Safari、Edge完全支持，你可以在你的浏览器控制台里运行例子。Async/Await需要运行在NodeJS 7.6版本及以上，同时也被Babel、TypeScript转译器支持。所以Async/Await可以被用于实际开发之中。* 准备我们会使用一个虚拟的API类，你也可以在你的电脑上运行。这个类通过返回promise来模拟异步请求。正常情况下，promise被调用后，200ms后会对数据进行处理。12345678910111213141516171819202122232425262728293031class Api &#123; constructor () &#123; this.user = &#123; id: 1, name: 'test' &#125; this.friends = [ this.user, this.user, this.user ] this.photo = 'not a real photo' &#125; getUser () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.user), 200) &#125;) &#125; getFriends (userId) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.friends.slice()), 200) &#125;) &#125; getPhoto (userId) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(this.photo), 200) &#125;) &#125; throwError () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('Intentional Error')), 200) &#125;) &#125;&#125; 每个示例依次执行如下三个操作： 获取一个用户的信息，获取该用户的朋友， 获取该用户的照片。在最后，我们会在控制台中打印这些结果。 方法一 — Nested Promise Callback Functions使用嵌套的promise回调函数12345678910111213function callbackHell () &#123; const api = new Api() let user, friends api.getUser().then(function (returnedUser) &#123; user = returnedUser api.getFriends(user.id).then(function (returnedFriends) &#123; friends = returnedFriends api.getPhoto(user.id).then(function (photo) &#123; console.log('callbackHell', &#123; user, friends, photo &#125;) &#125;) &#125;) &#125;)&#125; 对于任何一个从事过JavaScript项目开发的人来说，这个代码块非常熟悉。非常简单的业务逻辑，但是代码却是冗长、深嵌套，并且以这个结尾…..1234 &#125;) &#125;) &#125;)&#125; 在真实的业务场景中，每个回调函数可能更复杂，代码块会以一堆充满层次感的})为结尾。“回调函数里面嵌套着回调函数嵌套着回调函数”，这就是被传说中的“回调地狱”（“回调地狱”的诞生不只是因为代码块的混乱，也源于信任问题。）。更糟糕的是，我们为了简化，还没有做错误处理机制，如果加上了reject……细思极恐 方法二 — Promise Chain让我们优雅起来12345678910111213141516function promiseChain () &#123; const api = new Api() let user, friends api.getUser() .then((returnedUser) =&gt; &#123; user = returnedUser return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; friends = returnedFriends return api.getPhoto(user.id) &#125;) .then((photo) =&gt; &#123; console.log('promiseChain', &#123; user, friends, photo &#125;) &#125;)&#125; Promise有一个很棒的特性：Promise.prototype.then()和Promise.prototype.catch()返回Promise对象，这就使得我们可以将这些promise连接成一个promise链。通过这种方法，我们可以将这些回调函数放在一个缩进层次里。与此同时，我们使用了箭头函数简化了回调函数声明。对比之前的回调地狱，使用promise链使得代码的可读性大大提高并且拥有着更好的序列感，但是看起来还是非常冗长并且有一点复杂。 方法三 — Async/Await我们可不可以不写回调函数？就写7行代码能解决吗？1234567async function asyncAwaitIsYourNewBestFriend () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) console.log('asyncAwaitIsYourNewBestFriend', &#123; user, friends, photo &#125;)&#125; 优雅多了，调用await之前我们会一直等待，直到promise被决议并将值赋值给左边的变量。通过async/await，我们可以对异步操作流程进行控制，就好像它是同步代码。 注：await必须搭配async一起使用，注意上面的函数，我们将关键字async放在了函数的声明前，这是必需的。稍后，我们会深入讨论这个问题 循环Async/Await可以让以前很多复杂的代码变得简明。举个例子，如果我们要按序检索每个用户的朋友的朋友列表。 方法一 — Recursive Promise Loop下面是使用传统的promise来按序获取每个朋友的朋友列表1234567891011121314151617181920function promiseLoops () &#123; const api = new Api() api.getUser() .then((user) =&gt; &#123; return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; const getFriendsOfFriends = (friends) =&gt; &#123; if (friends.length &gt; 0) &#123; let friend = friends.pop() return api.getFriends(friend.id) .then((moreFriends) =&gt; &#123; console.log('promiseLoops', moreFriends) return getFriendsOfFriends(friends) &#125;) &#125; &#125; return getFriendsOfFriends(returnedFriends) &#125;)&#125; 我们创建在promiseLoops中创建了一个函数用于递归地去获取朋友的朋友列表。这个函数体现了函数式编程，但是对于这个简单的任务而言，这依旧是一个比较复杂的解决方案。 方法二 — Async/Await For-Loop让我们尝试一下Async/Await12345678910async function asyncAwaitLoops () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) for (let friend of friends) &#123; let moreFriends = await api.getFriends(friend.id) console.log('asyncAwaitLoops', moreFriends) &#125;&#125; 不需要写递归promise闭包，只需要使用一个for循环就能解决我们的问题。 并行一个一个地去获取朋友的朋友的列表看起来有点慢，为什么不并行处理请求呢？我们可以用async/await来处理并行任务吗？当然12345678async function asyncAwaitLoopsParallel () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const friendPromises = friends.map(friend =&gt; api.getFriends(friend.id)) const moreFriends = await Promise.all(friendPromises) console.log('asyncAwaitLoopsParallel', moreFriends)&#125; 为了并行请求，我们使用了一个promise数组并将它传递给方法Promise.all()，Promise.all()会返回一个promise，一旦所有的请求完成就会决议。 错误处理然而，在异步编程中有一个主要的问题还没解决：错误处理。在异步操作中，我们必须为每个操作编写单独的错误处理回调，在调用栈的顶部去找出正确的报错位置可能很复杂，所以我们得在每个回调开始时就去检查是否抛出了错误。所以，引入错误处理后的回调函数会比之前复杂度成倍增加，如果没有主动定位到报错的位置，这些错误甚至会被“吞掉”。现在，我们给之前的例子添上错误处理机制。为了测试错误处理机制，我们将在真正获取到用户图片之前使用抽象类里的api.throwError()方法。 方法一 — Promise Error Callbacks让我们看看最坏的情况123456789101112131415161718192021222324function callbackErrorHell () &#123; const api = new Api() let user, friends api.getUser().then(function (returnedUser) &#123; user = returnedUser api.getFriends(user.id).then(function (returnedFriends) &#123; friends = returnedFriends api.throwError().then(function () &#123; console.log('Error was not thrown') api.getPhoto(user.id).then(function (photo) &#123; console.log('callbackErrorHell', &#123; user, friends, photo &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;) &#125;, function (err) &#123; console.error(err) &#125;)&#125; 代码除了又长又丑陋以外，代码操作流也不直观，不像同步、可读性高的代码那样从上往下。 方法二 — Promise Chain “Catch” Method我们可以给promise链添加catch方法来改善一些1234567891011121314151617181920212223function callbackErrorPromiseChain () &#123; const api = new Api() let user, friends api.getUser() .then((returnedUser) =&gt; &#123; user = returnedUser return api.getFriends(user.id) &#125;) .then((returnedFriends) =&gt; &#123; friends = returnedFriends return api.throwError() &#125;) .then(() =&gt; &#123; console.log('Error was not thrown') return api.getPhoto(user.id) &#125;) .then((photo) =&gt; &#123; console.log('callbackErrorPromiseChain', &#123; user, friends, photo &#125;) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)&#125; 看起来好多了，我们通过给promise添加一个错误处理取代了之前给每个回调函数添加错误处理。但是，这还是有一点复杂并且我们还是需要使用一个特殊的回调来处理异步错误而不是像对待正常的JavaScript错误那样处理它们。 方法三 — Normal Try/Catch Block我们可以做得更好123456789101112131415async function aysncAwaitTryCatch () &#123; try &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) await api.throwError() console.log('Error was not thrown') const photo = await api.getPhoto(user.id) console.log('async/await', &#123; user, friends, photo &#125;) &#125; catch (err) &#123; console.error(err) &#125;&#125; 我们将异步操作放进了处理同步代码的try/catch代码块。通过这种方法，我们完全可以像对待同步代码的一样处理异步代码的错误。代码看起来非常简明 组合我在前面提及了任何以async的函数可以返回一个promise。这使得我们可以真正轻松地组合异步控制流举个例子，我们可以重新整理前面的例子，将获取数据和处理数据分开。这样我们就可以通过调用async函数获取数据。12345678910111213async function getUserInfo () &#123; const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) return &#123; user, friends, photo &#125;&#125;function promiseUserInfo () &#123; getUserInfo().then((&#123; user, friends, photo &#125;) =&gt; &#123; console.log('promiseUserInfo', &#123; user, friends, photo &#125;) &#125;)&#125; 更棒的是，我们可以在数据接受函数里使用async/await，这将使得整个异步模块更加明显。如果我们要获取前面10个用户的数据呢？1234567async function getLotsOfUserData () &#123; const users = [] while (users.length &lt; 10) &#123; users.push(await getUserInfo()) &#125; console.log('getLotsOfUserData', users)&#125; 并发呢？并且加上错误处理呢？123456789async function getLotsOfUserDataFaster () &#123; try &#123; const userPromises = Array(10).fill(getUserInfo()) const users = await Promise.all(userPromises) console.log('getLotsOfUserDataFaster', users) &#125; catch (err) &#123; console.error(err) &#125;&#125; 结论随着SPA的兴起和NodeJS的广泛应用，对于JavaScript开发人员来说，优雅地处理并发性比以往任何时候都要重要。Async/Await缓解了许多因为bug引起且已经影响JavaScript很多年的控制流问题，并且使得代码更加优雅。如今，主流的浏览器和NodeJS都已经支持了这些语法糖，所以现在是使用Async/Await的最好时机。 原文链接：https://blog.patricktriest.com/what-is-async-await-why-should-you-care/掘金地址：https://juejin.im/post/5ad1cab8f265da238a30e137]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Nginx反向代理跨域]]></title>
    <url>%2F2018%2F04%2F08%2FCross-Origin-using-Nginx%2F</url>
    <content type="text"><![CDATA[由于项目前后端分离且后端真实接口已出，所以我开发时首先考虑通过跨域获取真实接口数据配合前端开发。（赶工期啊：）根据create-react-app官方提示，在package.json中添加字段&quot;proxy&quot;: &quot;http://admin.xiaoyaoeden.top&quot;emmm🤭无效 😂所以改为使用Nginx反向代理跨域😊current origin：http://localhost:3000target origin：http://admin.xiaoyaoeden.top 安装brew install nginx 修改配置首先进入nginx的配置文件 vim /usr/local/etc/nginx/nginx.conf 增加如下一个server 12345678910111213server &#123; listen 3001; server_name localhost; location / &#123; proxy_pass http://localhost:3000; &#125; location /api/ &#123; add_header Access-Control-Allow-Origin *; proxy_pass http://admin.xiaoyaoeden.top; &#125; &#125; 重启Nginx服务1nginx -s reload 测试打开localhost:3001，跨域问题解决了，现在可以开开心心的测试接口啦]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“工作室招新页面项目”实践中遇到的问题（一）———— React组件通信]]></title>
    <url>%2F2018%2F02%2F13%2FReact-Problem-1%2F</url>
    <content type="text"><![CDATA[最近学了React基础知识，所以有打算做一个项目来踩坑，恰好适逢大二寒假并且工作室恰好需要在开学后招新，所以天时地利人和，我就用React作为这个项目的技术栈。于是项目开发中的第一个问题就诞生了————React组件通信 问题来源material-ui中的组件AppBar和Drawer之间的通信，二者为兄弟组件。 AppBar组件 Drawer组件 功能需求： 我需要点击AppBar的左侧的icon调出Drawer。 点击Drawer中的MenuItem跳转到其他页面 调出Drawer后点击非Drawer组件后收起Drawer。 解决方案通讯是单向的，数据必须是由一方传到另一方。 父组件与子组件的通信在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。1234567891011121314151617181920212223242526class Parent extends Component &#123; constructor() &#123; this.state = &#123; msg: '今天是情人节耶' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Child msg=&#123;this.state.msg&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;p&gt;this.props.msg&lt;/p&gt; ) &#125;&#125; 子组件与父组件的通信子组件向父组件通信，同样需要父组件向子组件传递props，不过这次是传递的是以父组件自身为作用域的函数，子组件负责调用，将要传递的信息传入函数中，作为参数，传递到父组件的作用域中。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Parent extends Component &#123; constructor() &#123; this.state = &#123; msg: '今天是情人节耶' &#125;; this.transferMsg = this.transferMsg.bind(this); &#125; componentDidMount() &#123; console.log(this.state.msg); &#125; componentDidUpdate() &#123; console.log(this.state.msg); &#125; transferMsg(msg) &#123; this.setState(&#123; msg: msg &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;Child transferMsg=&#123;this.transferMsg&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); this.msg = '我也喜欢你'; &#125; componentDidMount() &#123; this.props.transferMsg(this.msg); &#125; render() &#123; return ( &lt;p&gt;情人节啊&lt;/p&gt; ) &#125;&#125; 兄弟组件之间的通信因为AppBar和Drawer为兄弟组件，它们的共同点是拥有一个相同的父组件。先看看组件结构：1234&lt;Nav&gt; &lt;AppBar /&gt; &lt;Drawer /&gt;&lt;/Nav&gt; 所以我们可以将父组件Nav作为中转站，AppBar传递信息给Nav，Nav再将信息传递给Drawer;Drawe传递信息给AppBar与此类似。解决方案如下，我们将Drawer的开关状态放在了Nav的state中，声明了更改open值的transferMsg函数，然后将这个函数分别传递个NavBar和Drawer，这样以来真正控制open的值就是NavBar和Drawer组件。具体实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Nav extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; open: false &#125; this.transferMsg = this.transferMsg.bind(this); &#125; transferMsg() &#123; this.setState(&#123; open: !this.state.open &#125;); &#125; render() &#123; return ( &lt;nav&gt; &lt;NavBar transferMsg=&#123;this.transferMsg&#125;/&gt; &lt;NavDrawer msg=&#123;this.state.open&#125; transferMsg=&#123;this.transferMsg&#125; /&gt; &lt;/nav&gt; ); &#125;&#125;class NavBar extends Component &#123; constructor(props) &#123; super(props); this.handleMenuClick = this.handleMenuClick.bind(this); &#125; handleMenuClick(event) &#123; this.props.transferMsg(); &#125; render() &#123; return ( &lt;AppBar title="CTG Club" iconClassNameRight="mudiocs-icon-navigation-expand-more" onLeftIconButtonClick=&#123;this.handleMenuClick&#125; /&gt; ); &#125;&#125;class NavDrawer extends Component &#123; constructor(props) &#123; super(props); this.handleToggle= this.handleToggle.bind(this); this.handleClose = this.handleClose.bind(this); &#125; handleToggle() &#123; this.props.transferMsg(); &#125; handleClose() &#123; this.props.transferMsg(); &#125; render() &#123; return ( &lt;Drawer docked=&#123;false&#125; width=&#123;200&#125; open=&#123;this.props.msg&#125; onRequestChange=&#123;this.handleToggle&#125; &gt; &lt;/Drawer&gt; ) &#125;&#125; 这个项目中的问题迎刃而解。这代码结构，仿佛还有一点东西。 发布者-订阅者模式定义发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。 ####运用1.发布-订阅者模式可以广泛应用于异步编程，只是一种替代回调函数的方案。2。发布-订阅者模式可以取代对象之间硬编码的通知机制，一个对象不再显式调用另一个对象的某个接口，让两个对象松耦合地联系在一起。（这一点就可以上述的解决方案的不足的地方） 实例最近一年重庆房价蹭蹭往上涨，小明迫于家里的压力，打算在解放碑买置一套总价200万的三居室。小明到了售楼处才发现心仪的房子已经被别人买了，不过后续还有一些尾房推出，但是开发商也不清楚什么时候推出这些尾房。于是售楼MM记下了小明的电话，答应他尾房一旦推出就打电话给他。后续小码也留了号码，每天等着售楼MM的电话。这就是一个典型的发布-订阅者模式的例子，逻辑代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//把发布—订阅的功能提取出来，放在一个单独的对象内:const event = &#123; clientList: [], listen(key, fn) &#123; if (!this.clientList[key]) &#123; //如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表 &#125;, trigger(...message) &#123; let key = Array.prototype.shift.call(message), //取出消息类型 fns = this.clientList[key]; //取出该消息对应的回调函数集合 if (!fns || fns.length === 0) &#123; //如果没有订阅该消息，则返回 return false; &#125; for (let i = 0, fn = fns[i++]; ) &#123; fn.apply(this, message); //message是发布消息时附送的参数 &#125; &#125;, remove(key, fn) &#123; let fns = this.clientList[key]; if (!fns) &#123; // 如果 key 对应的消息没有被人订阅，则直接返回 return false; &#125; if (!fn) &#123; //// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (let i = fns.length - 1; i &gt;= 0; i--) &#123; // 反向遍历订阅的回调函数列表 let _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); // 删除订阅者的回调函数 &#125; &#125; &#125;; &#125;&#125;;//再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能:const installEvent = function (obj) &#123; for (let i in event) &#123; obj[i] = event[i]; &#125;&#125;;const salesOffices = &#123;&#125;;installEvent(salesOffices);salesOffices.listen('squareMeter88', fn1 = function (price) &#123; console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter88', fn2 = function (price) &#123; console.log('价格= ' + price);&#125;);salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅// 小明订阅消息// 小红订阅消息salesOffices.trigger('squareMeter88', 2000000); // 输出:2000000 对于此项目中问题的解决方案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/*on、one：on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。trigger：trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。off：用于解除所有订阅了某个事件的所有函数。*/const eventProxy = &#123; onObj: &#123;&#125;, oneObj: &#123;&#125;, on: function(key, fn) &#123; if (this.onObj[key] === undefined) &#123; this.onObj[key] = []; &#125; this.onObj[key].push(fn); &#125;, one: function(key, fn) &#123; if (this.oneObj[key] === undefined) &#123; this.oneObj[key] = []; &#125; this.oneObj[key].push(fn); &#125;, off: function(key) &#123; this.onObj[key] = []; this.oneObj[key] = []; &#125;, trigger: function(...args) &#123; let key; if (args.length === 0) &#123; return false; &#125; key = args[0]; args = [].concat(Array.prototype.slice.call(args, 1)); if (this.onObj[key] !== undefined &amp;&amp; this.onObj[key].length &gt; 0) &#123; for (let i in this.onObj[key]) &#123; this.onObj[key][i].apply(null, args); &#125; &#125; if (this.oneObj[key] !== undefined &amp;&amp; this.oneObj[key].length &gt; 0) &#123; for (let i in this.oneObj[key]) &#123; this.oneObj[key][i].apply(null, args); this.oneObj[key][i] = undefined; &#125; this.oneObj[key] = []; &#125; &#125;&#125;;const BranchItemDatas = [ &#123; name: 'Web研发部', imgUrl: null, imgTitle: null, intro: null, key:1 &#125;, &#123; name: '移动开发部', imgUrl: null, imgTitle: null, intro: null, key: 2 &#125;, &#123; name: '视觉设计部', imgUrl: null, imgTitle: null, intro: null, key: 3 &#125;, &#123; name: '产品运营部', imgUrl: null, imgTitle: null, intro: null, key: 4 &#125;, &#123; name: '运维安全部', imgUrl: null, imgTitle: null, intro: null, key: 5 &#125;];class Nav extends Component &#123; render() &#123; return ( &lt;nav&gt; &lt;NavBar /&gt; &lt;NavDrawer /&gt; &lt;/nav&gt; ); &#125;&#125;class NavBar extends Component &#123; constructor(props) &#123; super(props); this.handleMenuClick = this.handleMenuClick.bind(this); &#125; handleMenuClick() &#123; eventProxy.trigger('open', true); &#125; render() &#123; return ( &lt;AppBar title="CTG Club" onLeftIconButtonClick=&#123;this.handleMenuClick&#125; /&gt; ); &#125;&#125;class NavDrawer extends Component &#123; constructor(props) &#123; super(props); this.handleToggle = this.handleToggle.bind(this); this.handleClose = this.handleClose.bind(this); this.state = &#123; open: false &#125; &#125; handleToggle() &#123; this.setState(&#123; open: !this.state.open &#125;) &#125; handleClose() &#123; this.setState(&#123; open: false &#125;) &#125; componentDidMount() &#123; eventProxy.on('open', () =&gt; &#123; this.setState(&#123; open: true &#125;); &#125;); eventProxy.on('close', () =&gt; &#123; this.setState(&#123; open: false &#125;); &#125;); &#125; render() &#123; return ( &lt;Drawer docked=&#123;false&#125; width=&#123;200&#125; open=&#123;this.state.open&#125; onRequestChange=&#123;this.handleToggle&#125; &gt; &lt;MenuItems /&gt; &lt;/Drawer&gt; ) &#125;&#125;class MenuItems extends Component &#123; handleMenuItemClick() &#123; eventProxy.trigger('close', false); &#125; render() &#123; return ( &lt;ul className='normal-list'&gt; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;0&#125;&gt;首页&lt;/MenuItem&gt; &#123;BranchItemDatas.map((item) =&gt; &#123; return ( &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;item.key&#125;&gt;&#123;item.name&#125;&lt;/MenuItem&gt; ); &#125;)&#125; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;6&#125;&gt;关于CTG&lt;/MenuItem&gt; &lt;MenuItem onClick=&#123;this.handleMenuItemClick&#125; key=&#123;7&#125;&gt;联系我们&lt;/MenuItem&gt; &lt;/ul&gt; ) &#125;&#125; 关于参考书籍或博文：《JavaScript设计模式与开发实践》“React 组件间通讯”————淘宝前端团队 情人节快乐啊情人节快乐啊情人节快乐啊情人节快乐啊]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的类型（一）———— 类型]]></title>
    <url>%2F2018%2F02%2F06%2Ftype-js%2F</url>
    <content type="text"><![CDATA[引入类型：对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。JavaScript是一门弱类型（偏向容忍隐式类型转换）语言，同时也是一门动态类型（编译的时候就知道每个变量的类型）语言。没有严格的类型的限制，使得JavaScript成为了一门特别灵活的语言，但是也带了一些麻烦，例如强制类型转换。 内置类型JavaScript中暂时有7种内置类型： 空值（null） 未定义（undefined） 布尔值（boolean） 数字（number） 字符串（string） 对象（object） 符号（symbol）通常，我们可以通过typeof操作符来查看值的类型，它会返回类型的字符串值，但是并不是这七种类型和它们的字符串值并不是一一对应。123456789101112131415//下面六种类型均有同名的字符串值与之对应,'==='会返回true。typeof undefined === 'undefined'typeof false === 'boolsean'typeof 3 === 'number'typeof '3' === 'string'typeof &#123;number: 3&#125; === 'object'typeof Symbol() === 'symbol'//对于null类型，存在一个bug（从JavaScript诞生就一直存在，以后估计也会存在），对null进行typeof操作，返回的值居然是'object'；typeof null === 'object' //truetypeof null === 'null' //false//我们需要使用复合条件来检测null值的类型：const a = null;//对于&amp;&amp;操作，如果运算符左边的值为真，则该表达式直接返回右边的值，例如 'true &amp;&amp; 3'表达式的结果为3。(!a &amp;&amp; typeof a === "object"); //true 函数函数是’object’的一个子类型，函数是一个“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。但是，对函数进行typeof操作时，返回的值可不是’object’。12typeof function()&#123;&#125; === 'object' //falsetypeof function()&#123;&#125; === 'function' //true 没错，就是’function’。看起来function就是另外一种内置类型，但是它不是。：） 值和类型变量没有类型，值才有类型JavaScript中的变量是没有类型的，只有值才具有类型，变量可以随时持有任何类型的值。前面提到过，JavaScript是一门动态弱类型的语言。例如：变量a持有的值为42，那么这个值的类型为number，并且无法直接更改42的类型（number），但可以通过强制转换将这42转换为’42’，此时值拥有的类型就为字符串（string)。 undefined and undeclared变量未持有值时为undefined，此时typeof返回’undefined’。已在作用域中声明但未赋值的比变量是undefined的，未在作用域声明过的变量是undeclared的。123let a;a; //undefinedb; //ReferenceError:b is not defined，报错 每次看到“not defined”,总以为等价于”undefined”，真让人糟心，还有更糟心的：）123let a;typeof a; //undefinedtypeof b; //undefined 一向被认为比较安全的操作符typeof也会这样闹着玩：）注：推荐一本必看的书《JavaScript语言精粹》，作者是Douglas Crockford（大神）。 安全防范机制并不是没有办法让开发人员解决’undeclared’问题，有时候通过typeof的安全防范机制（阻止报错）来检查undeclared变量不失为一个方法。当一个窗口加载多个.js文件时，这些.js文件中的代码会共享一个全局作用域，如果有重名的变量名，那么就太可怕了……减少全局变量是编写可维护的代码的基础，所有东西都应该被封装到模块或者私有/独立的命名空间里。例如：调试模式下，在debug.js声明了一个DEBUG的全局变量，把它作为调试模式的开关，在输出调试信息时我们会先判断DEBUG是否已经被声明。可是如何在程序中检查全局变量DEBUG且不会出现ReferenceError错误呢？typeof的安全防范机制就成了我们的帮手12345678//这样做是要挨Error的if (DEBUG) &#123; console.log("调试开始啰");&#125;//这样就比较安全了if (typeof DEBUG !== "undefined") &#123; console.log("调试开始啰")&#125; 不仅对于自定义的变量有用，对于内建的API也有帮助。甚至不一定要求作用域为全局，也可以用于检查我们的变量是否在宿主作用域声明过。 还有一个方法，就是检查所有全局变量是否是全局对象的属性，浏览器的全局对象是window，服务器端的全局对象为global。上述的例子我们可以这样操作：123if (window.DEBUG) &#123; //...&#125; 访问不存在的对象属性与undeclared变量不同，是不会报错的。 关于参考文献：《你不知道的JavaScript（中卷）》《JavaScript语言精粹》]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的继承方式]]></title>
    <url>%2F2018%2F02%2F03%2Finherit-in-js%2F</url>
    <content type="text"><![CDATA[引入继承是OOP的核心内容之一。JavaScript中常见继承方式为：类式继承、构造函数式继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。 类式继承类式继承，通过子类的原型prototype对父类的实例化实现。由于子类通过其原型prototype对父类实例化继承了父类，所以父类中的共有属性要是引用类型就会在子类中被所有实例共用。由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类时是无法向父类传递参数的，因而在实例化父类时无法对父类构造函数内的属性进行初始化。123456789101112131415161718//声明父类function SuperClass() &#123; this.superValue = true;&#125;//为父类添加共有方法SuperClass.prototype.getsuperValue = function() &#123; return this.superValue;&#125;//声明子类function SubClass() &#123; this.subValue = false;&#125;//继承父类（SubClass.prototype = new SuperClass();//为子类添加共有方法SubClass.prototype.getsubValue = function () &#123; return this.subValue;&#125; 构造函数式继承构造函数继承，通过在子类的构造函数作用环境中执行一次父类的构造函数来实现；由于没用涉及prototype，所以父类的原型方法不会被子类继承。要想被子类继承，就得把属性和函数放到父类的构造函数中，并且创建出来的（子类的）实例都会单独拥有一份，违背了 “代码复用”。12345678910111213141516//声明父类function SuperClass(id) &#123; //引用类型共有属性 this.books = ['JavaScript', 'html', 'css']; //值类型共有属性 this.id = id;&#125;//父类声明原型方法SuperClass.prototype.showBooks = function() &#123; console.log(this.books);&#125;//声明子类function SubClass(id) &#123; //继承父类 SuperClass.call(this, id); //将子类的变量在父类中都执行一遍，父类中是给this绑定属性的，所以通过call就使得子类继承了父类的共有属性。&#125; 组合继承组合继承，将类式继承和构造函数式继承综合，构造函数继承时执行了一遍父类的构造函数，在实现子类原型的类式继承又调用一遍父类构造函数。12345678910111213141516171819function SuperClass(name) &#123; this.name = name; this.books = ["javascript", "html", "css"];&#125;SuperClass.prototype.getName = function () &#123; return this.name;&#125;function SubClass(name, time) &#123; //构造函数式基础父类name属性 SuperClass.call(this, name); //子类新增共有属性 this.time = time;&#125;//类式继承 子类原型继承父类SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function () &#123; return this.time;&#125; 原型式继承原型式继承，借助原型prototype可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。123456789//对类式继承的封装function inheritObejct(o) &#123; //声明一个过渡函数对象 function F() &#123;&#125; //过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的一个实例， 该对象的原型继承了父对象 return new F();&#125; 基于这种在对象之间直接构建继承关系的理念，DC大神给出了上述的函数，这个inheritObject函数后来被ES5采纳，更名为Object.create()。 寄生式继承寄生式继承,对原型继承的第二次封装，并且在此过程中对继承的对象进行了拓展。123456789101112131415//声明基对象let book = &#123; name: 'js book', alikeBook: ["css book", "html book","html book"]&#125;;function createBook(obj) &#123; //通过原型继承方式创建新对象 let o = new inheritObejct(obj); //拓展新对象 o.getName = function() &#123; return name; &#125; //返回拓展后的新对象 return o;&#125; 寄生组合式继承这里的寄生继承处理的是类的原型12345678910111213141516171819202122232425262728293031function inhreitPrototype(SubClass, SuperClass) &#123; //复制一份父类的原型副本保存在变量中 let p = inheritObejct(SuperClass.prototype); //修正因为重写子类原型导致子类的constructor属性被修改 p.constructor = SubClass; //设置子类的原型 SubClass.prototype = p;&#125;//实例//定义父类function SuperClass(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;//定义父类的原型方法SuperClass.prototype.getName = function() &#123; return this.name;&#125;//定义子类function SubClass(name, time) &#123; //构造函数式继承 SuperClass.call(this,name); //子类新增属性 this.time = time;&#125;/*寄生式继承父类原型*/inhreitPrototype(SubClass, SuperClass);/*子类新增原型方法*/SubClass.prototype.getTime = function () &#123; return this.time;&#125; extend与deepCopy在JavaScript中继承是依赖于原型prototype链实现的，只有一条原型链，理论上不能继承多个父类。但是由于JavaScript是一门很灵活的语言，所以我们可是自己动手实现一个继承多对象属性的函数。 原型链定义JavaScript中每个函数都有一个指向某一对象的prototype属性，该函数被new操作符调用时会创建并返回一个对象，返回的对象中有一个指向其原型对象的proto属性，引擎在背后通过运用proto可以使得新建的对象可以调用相关原型的对象的方法和属性。原型对象本身也是对象，所以本身也包含了指向其原型的proto,由此就形成了一条链，称之为原型链。 作用如图，有了原型链，如果某个属性在对象B中而不在对象A中，我们依然可以把这个属性当作A的属性来访问。这就是继承的作用，它可以使得每个对象都能访问其继承链上的任何属性。 继承单对象属性的extend方法（针对值类型的属性）123456function extend(child, parent) &#123; for (let prop in parent) &#123; child[prop] = parent[prop]; &#125; return child;&#125; 继承多对象的属性12345678910111213function mix() &#123; let i = 1, len = arguments.length, child = arguments[0], arg; for(; i &lt; len; i++) &#123; arg = arguments[i]; for( let prop in arg) &#123; child[prop] = arg[prop]; &#125; &#125; return child;&#125; 深拷贝在JavaScript中复制一个对象的属性时，如果对象的属性为值类型则只需要简单的赋值语句即可，如果属性为引用类型，则需要依次复制该属性的属性，这里采用递归的思想解决这个问题。（如果不使用递归，则通过JSON解析解决） 为什么要这么做？当创建一个对象时，这个对象就被存储在内存中的某个物理位置，相关的变量和属性就会指向这些位置。 创建一个新对象，并让变量A指向该对象。 创建一个新变量B，并设置其与A相等，此时B和A指向了同一个对象，也就是内存中的同一个地址。 修改变量B所指的对象的color属性，将它设置为”white”,此时A.color 的值也为”white”。 再创建一个对象，然后让变量B指向这个新对象，A和B此时指向了内存中不同的位置，A、B从此再无关联。具体实现1234567891011121314function deepCopy(parent, child) &#123; child = child || &#123;&#125;; for (let prop in parent) &#123; if (parent.hasOwnProperty(prop)) &#123; if (typeof parent[prop] === 'object') &#123; child[i] = Array.isArray(parent[prop])? [] : &#123;&#125;; deepCopy( parent[prop], child); &#125; else &#123; child[prop] = parent[prop]; &#125; &#125; &#125; return child;&#125; 总结 关于参考文献：《JavaScript面向对象编程指南》《JavaScript设计模式》《你不知道的JavaScript（上卷）》]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
